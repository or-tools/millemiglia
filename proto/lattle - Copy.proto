syntax = "proto3";

package operations_research.lattle;

import "google/api/resource.proto";
import "google/api/field_behavior.proto";
import "google/protobuf/duration.proto";
import "google/type/datetime.proto";
import "google/type/latlng.proto";
import "storage/util/int128/int128.proto";

option java_package = "com.google.operationsresearch.lattle.v1";
option java_multiple_files = true;
option java_outer_classname = "LattleProto";
option use_java_stubby_library = true;

// go/lattle-dd

// ---------------------
// - Part 0: utilities -
// ---------------------

// This could be a part of the basic Protobuf API or an OR-specific standard
// library.

// Range of times between two DateTime. For a pointwise date time, use
// start == end.
// TODO(tcuvelier): think about google/type/interval.proto.
message DateTimeRange {
  google.type.DateTime first_date = 1;
  google.type.DateTime last_date = 2;
}

message IntegerRange {
  // Interval open if unset.
  optional int32 start_value = 1;
  // Interval open if unset.
  optional int32 end_value = 2;
}

message Function1D {
  // The unity of the argument of the function is supposed to be:
  // - if a weight: kg
  // - if a time: min
  // - if a number of pallets: 1
  oneof function {
    double constant = 1;
    PieceWiseAffineFunction pwl = 2;
  }
}

message PricingStrategy {
  oneof pricing_strategy {
    SeparableNDFunction separable = 1;
  }
  // TODO(tcuvelier): what about dynamic pricing? Consider API calls for the
  //  API customer to compute the price based on a path being evaluated.
}

message SeparableNDFunction {
  map<string, Function1D> components = 1;
  double constant_price = 2;
}

// A value along one predefined dimension. The field `value` must be set to the
// corresponding type of the `dimension`.
message ValueDimension {
  int64 value = 1;
  string dimension = 2;
}

// Design similar to
// https://source.corp.google.com/piper///depot/google3/util/operations_research/util/piecewise_linear_function.h
// Limited to 1D.
message PieceWiseAffineFunction {
  repeated PieceWiseAffineSegment segments = 1;
}
message PieceWiseAffineSegment {
  double start_x = 1;
  double start_y = 2;
  double end_x = 3;
  double end_y = 4;
}

// -------------------------------------------------
// - Part 1: description of the logistics network. -
// -------------------------------------------------

// Describes an instance of a problem to solve. This message should mostly be
// used to exchange data with API customers outside the API.
message Instance {
  LogisticsNetwork network = 1;
  map<string, Parcel> parcels = 2;
}

// Describes the full existing logistics network that can be used.
// A given API customer might have several networks (e.g., the main network and
// a possible future modification to evaluate).
message LogisticsNetwork {
  option (google.api.resource) = {
    type: "optimizationai-pa.googleapis.com/LogisticsNetwork"
    pattern: "networks/{network}"
  };

  // Cannot be updated.
  string name = 1;
  map<string, Line> lines = 2;
  map<string, Vehicle> vehicles = 3;
  map<string, Hub> hubs = 4;
  // Distance, weight, pallets, etc., plus scaling (to map floats to integers).
  repeated ValueDimension dimensions = 5;

  // Price to be paid by the sender for shipping a parcel that does not require
  // a dedicated line.
  PricingStrategy pricing = 6;

  // Single monetary unit used throughout the network. A given API customer can
  // have several different units for different networks; a network is only
  // allowed to have one monetary unit.
  // The unit must be encoded in ISO 4217, like google3/google/type/money.proto.
  string currency_code = 7;

  // Time discretization. Decisions are output with this precision in time.
  // Internally, state is kept with this precision.
  google.protobuf.Duration time_step = 8;

  // Distance matrix (represented a list of weighted directed edges).
  repeated DistanceMatrixEntry distance_matrix = 9;
}

// A line that is being operated at a given frequency.
// No name, it is stored as a map key within the LogisticsNetwork.
message Line {
  option (google.api.resource) = {
    type: "optimizationai-pa.googleapis.com/Line"
    pattern: "networks/{network}/lines/{line}"
  };

  // List of hubs that this line calls at, in the order vehicles stop at them.
  repeated string hub_ids = 1;

  // List of rotations with a name for each. The API server does not
  // periodically create new entries, this is up to the API customer.
  map<string, LineRotation> next_rotations = 2;
}

// One rotation of a line that is generated by Lattle and not the API customer.
// It is inherently less constrained, and could use any vehicle (unless the API
// customer decides otherwise in subsequent calls).
message GeneratedLineAndRotation {
  // No name, this line is part of the solution and not the input.

  // Map between hub IDs and times. Both maps are supposed to have the same
  // keys (minus the source hub, with no arrival time, and the destination hub,
  // with no departure time).
  map<string, google.type.DateTime> arrival_times = 1;
  map<string, google.type.DateTime> departure_times = 2;
}

// A vehicle starts operating this line at a particular time.
message LineRotation {
  option (google.api.resource) = {
    type: "optimizationai-pa.googleapis.com/LineRotation"
    pattern: "networks/{network}/lines/{line}/rotations/{rotation}"
  };

  // Ranges where departure/arrival is allowed without cost (i.e., if not
  // pointwise, the actual starting and arrival times are decided by the
  // system). Both maps are supposed to have the same keys (minus the source
  // hub, with no arrival time, and the destination hub, with no departure
  // time).
  map<string, DateTimeRange> arrival_times = 1;
  map<string, DateTimeRange> departure_times = 2;
  // Earliness/tardiness costs and bounds. Both maps are supposed to have the
  // same keys (minus the source hub, with no arrival time, and the destination
  // hub, with no departure time).
  map<string, EarlinessTardiness> starting_earliness_tardiness_costs = 3;
  map<string, EarlinessTardiness> arrival_earliness_tardiness_costs = 4;

  // Maximum number of vehicles that can be assigned to this rotation. If unset:
  // no limit in terms of vehicles for this rotation. Otherwise, upper bound on
  // the number of vehicles that can be allocated to this rotation (among the
  // allow list `vehicle_ids`).
  // In particular, a value of 0 disables this rotation (no vehicles allowed).
  optional IntegerRange maximum_number_vehicles = 5;

  // List of vehicles that could be doing this line rotation (i.e. allow list).
  // If number_vehicles reduces to one value corresponding to the number of
  // vehicles, all those vehicles will be assigned to the line rotation.
  // If no vehicles, all are considered to be available.
  repeated string vehicles = 6;

  // Cost of having *any* vehicle doing this line, regardless of vehicle
  // (driver, maintenance, etc.).
  PricingStrategy fixed_price = 7;
}

message EarlinessTardiness {
  // Maximum allowable earliness/tardiness. Useful only with costs.
  optional google.protobuf.Duration maximum_earliness = 1;
  optional google.protobuf.Duration maximum_tardiness = 2;
  // Cost of earliness/tardiness. Unset iff no cost for earliness/tardiness.
  optional Function1D earliness_cost = 3;
  optional Function1D tardiness_cost = 4;
}

// No name, it is stored as a map key within the LogisticsNetwork.
message Vehicle {
  option (google.api.resource) = {
    type: "optimizationai-pa.googleapis.com/Vehicle"
    pattern: "networks/{network}/vehicles/{vehicle}"
  };

  // Unset if not currently at a hub.
  optional string current_position_hub = 1;

  // Vehicle characteristics.
  bool refrigerated = 2;
  repeated ValueDimension capacities = 3;

  // Cost for using the vehicle. These are functions of one argument: the
  // distance the vehicle travels, the weight the vehicle transports,
  // the number of pallets the vehicle transports.
  // These functions account for maintenance, fuel, and handling costs.
  // These cost may include an upfront cost (paid once the vehicle is used,
  // mostly useful for subcontracting).
  PricingStrategy cost = 4;

  // Price to be paid by the paying party, only if the vehicle is being used in
  // a generated line (i.e. not part of the input network).
  PricingStrategy pricing = 6;

  // Whether this vehicle can be used for generated routes. If set to `false`,
  // the vehicle will be limited to predefined routes where it is allowed.
  bool allowed_for_generated_routes = 7;
}

// Parcels must be brought from one hub to another one.
// No name, it is stored as a map key within the LogisticsNetwork.
message Hub {
  option (google.api.resource) = {
    type: "optimizationai-pa.googleapis.com/Hub"
    pattern: "networks/{network}/hubs/{hub}"
  };

  // Position to compute real-world paths.
  google.type.LatLng position = 1;
  // Opening times. For now, use a very rough representation: one entry each
  // time the hub opens (if its workers have a lunch break and no one works at
  // that time, there will be two entries for that day).
  repeated DateTimeRange opening_times = 2;

  // Capacity of the complete hub.
  CrossDockingCapacity cross_docking_capacity = 3;
  CrossDockingTime cross_docking_time = 4;
}

message CrossDockingCapacity {
  repeated ValueDimension capacity_per_hour = 1;
}

message CrossDockingTime {
  google.protobuf.Duration time_constant = 1;
  // Separability is a simplifying assumption.
  SeparableNDFunction time = 2;
}

// TODO: what about transshipment?

message DistanceMatrixEntry {
  string source_hub = 1;
  string destination_hub = 2;
  repeated ValueDimension weights = 3;
}

// ---------------------------------------------------------------
// - Part 2: elements that must go through the logistics network -
// ---------------------------------------------------------------

message Parcel {
  option (google.api.resource) = {
    type: "optimizationai-pa.googleapis.com/Parcel"
    pattern: "networks/{network}/parcels/{parcel}"
  };

  string parcel = 1;
  // Ends of the path the parcel must take.
  string source_hub = 2;
  string destination_hub = 3;
  // Departure time.
  google.type.DateTime departure_time = 4;
  // *Expected* arrival time (i.e. soft constraint).
  DateTimeRange arrival_time = 5;
  // SLAs indicate that this time may be exceeded with some penalty.
  // (If later than the maximum, the package is no more useful.)
  // The penalty is given by a function of the delay (in minutes).
  EarlinessTardiness arrival_earliness_tardiness_cost = 6;
  // Requirements on the vehicles used to ship this parcel.
  bool must_be_refrigerated = 7;
  // Revenue from this package (only used to compute the reward), i.e. price
  // paid by the paying party.
  // If unset, revenue is computed by the system (depending on whether a new
  // line is generated for this parcel or not).
  optional double revenue = 8;
  // Used with vehicle and hub capacities.
  repeated ValueDimension size = 9;
}

message ParcelRoute {
  string parcel = 1;
  repeated AnnotatedPathSegment path_segments = 2;
  google.type.DateTime departure_time = 3;
  google.type.DateTime arrival_time = 4;
  double incurred_penalties_from_arrival_time_per_minute = 5;
  double cost_constant = 6;
  map<string, double> cost = 7;

  storage_util.Int128 fingerprint = 8
      [(google.api.field_behavior) = OUTPUT_ONLY];
}

message Path {
  // Segments must be in order, from a source to a destination.
  repeated PathSegment segments = 1;
}

message IncompletePath {
  // A subset of the segments of a path from a source to a destination.
  repeated PathSegment segments = 1;
}

// Represents a part of a path, either sent by the API customer to the API
// server (e.g., state change) or by the API server to the API customer (e.g.,
// routing a parcel).
message PathSegment {
  string source_hub = 1;
  string destination_hub = 2;
  string line = 3;
  string line_rotation = 4;
  string vehicle = 5;
}

// Represents a part of a path with more redundant information that can be
// computed based on the contained PathSegment and the LogisticsNetwork.
// These messages are typically returned by the API server.
message AnnotatedPathSegment {
  PathSegment path_segment = 1;

  google.type.DateTime arrival_time = 2;
  google.type.DateTime departure_time = 3;

  double segment_cost_constant = 4;
  // One entry per dimension.
  map<string, double> segment_cost_due_to_vehicle = 5;
  // Cost due to the line rotation.
  double segment_cost_due_to_departure = 6;
  double segment_cost_due_to_arrival = 7;
  // Whether the API customer has decided to commit this part of the path.
  bool is_committed = 8;
}

message EarlinessTardinessCost {
  double earliness = 1;
  double tardiness = 2;
}

// -----------------
// - Part 3: state -
// -----------------

// Stores the state for one logistics network. This message is not part of the
// API and is purely internal.
//
// The state gathers redundant information by storing both the routed parcels
// and the used capacities. There are several reasons:
// - The parcels that have been previously routed might encounter unexpected
//   conditions in the future (like a vehicle that fails), hence the need for
//   `parcels`.
// - The API customers might want to retrieve the routes for a given parcel,
//   hence the need for `parcel_routes`.
// - The used capacities are required to compute new solutions, hence the need
//   for `used_capacity_in_vehicle`.
// These sources of information are supposed to be consistent with each other.
message LogisticsNetworkState {
  // Store the total capacity that is used for one dimension of a vehicle at a
  // given time (i.e. line rotation, implicitly).
  message UsedCapacityInVehicle {
    string line = 1;
    string line_rotation = 2;
    repeated ValueDimension used_capacity = 3;
    // Design consideration: very few dimensions, no need to optimize look-up
    // with a hash table.

    string vehicle = 4;
    string source_hub = 5;
    string destination_hub = 6;
  }

  string network = 1;
  repeated Parcel routed_parcels = 2;
  repeated ParcelRoute parcel_routes = 3;
  repeated UsedCapacityInVehicle used_capacity_in_vehicle = 4;
}

// ---------------------------
// - Part 4: error reporting -
// ---------------------------

// This part of the API is identical to TourOptimization's validation, with an
// adapted list of codes and a migration to proto3.

// Describes an error encountered when validating queries for Lattle.
message LattleValidationError {
  // A validation error is defined by a code which is always present.
  // Other fields (see below) provide more context about the error.
  //
  // MULTIPLE ERRORS:
  // When there are multiple errors, the validation process tries to output
  // several of them. Much like a compiler, this is an imperfect process. Some
  // validation errors will be "fatal", meaning that they stop the entire
  // validation process. Some may cause the validation process to skip other
  // errors. This means that users may, after fixing the returned errors, get
  // new ones.
  //
  // STABILITY:
  // `code` should be very stable, but new codes may appear over time, which
  // may cause a given (invalid) request to yield a different code because the
  // new error hid the old one (see "MULTIPLE ERRORS"). Thus, users should not
  // strongly rely on a particular TourOptimizationRequest always yielding a
  // certain validation error code.

  // clang-format off
  // (-- api-linter: core::0192::has-comments=disabled
  //     aip.dev/not-precedent: Details about the errors are sent with each
  //     validation error. --)
  enum Code {
    ERROR_UNSPECIFIED = 0;

    VALIDATION_ERROR = 2;
      VALIDATION_TIMEOUT_ERROR = 200;
      VALIDATION_OBJECT_ALREADY_INITIALIZED = 201;

    LOGISTICS_NETWORK_ERROR = 4;
      LOGISTICS_NETWORK_NO_DIMENSION = 400;

    LOGISTICS_NETWORK_STATE_ERROR = 6;
      LOGISTICS_NETWORK_STATE_INTERNAL_ERROR = 600;

    VALUE_DIMENSION_ERROR = 8;
      VALUE_DIMENSION_UNKNOWN_DIMENSION = 800;

    LINE_ERROR = 10;
      LINE_NOT_IN_NETWORK = 1000;
      LINE_ROTATION_NOT_IN_NETWORK = 1001;
      LINE_HUBS_NOT_IN_NETWORK = 1002;
      LINE_ROTATION_WRONG_NUMBER_OF_ARRIVALS = 1003;
      LINE_ROTATION_WRONG_NUMBER_OF_DEPARTURES = 1004;
      LINE_ROTATION_HUB_NOT_IN_LINE = 1005;
      LINE_ROTATION_WRONG_ORDER_OF_HUBS_TIME_WISE = 1006;

    VEHICLE_ERROR = 12;
      VEHICLE_CAPACITY_DIMENSION_NOT_IN_NETWORK = 1200;

    DISTANCE_MATRIX_ERROR = 14;
      DISTANCE_MATRIX_ENTRY_SOURCE_HUB_NOT_IN_NETWORK = 1400;
      DISTANCE_MATRIX_ENTRY_DESTINATION_HUB_NOT_IN_NETWORK = 1401;
      DISTANCE_MATRIX_ENTRY_WEIGHT_DIMENSION_NOT_IN_NETWORK = 1402;
  }
  // clang-format on

  // Always present.
  Code code = 1;

  // Specifies a context for the validation error. A FieldReference always
  // refers to a given field in the lattle.proto and follows the same
  // hierarchical structure. For example, we may specify element #2 of
  // start_time_window of vehicle #5 using:
  //    name: "vehicle"
  //    index: 5
  //    sub_field { name: "start_time_window" index: 2 }
  // Similarly, for maps, we would refer the value at key "key" for the field
  // "map" using:
  //    { name: "map" key: "key" }
  // We however omit top-level entities such as RouteParcelRequest to avoid
  // crowding the message.
  message FieldReference {
    string name = 1;
    oneof index_or_key {
      int32 index = 2;
      string key = 3;
    }
    FieldReference sub_field = 4;
  }
  // Main field involved in the error. For example, referring to the
  // start_time_window field of vehicle #5 can be done as follows:
  //    name: "vehicle"
  //    index: 5
  //    sub_field { name: "start_time_window" index: 2 }
  FieldReference field = 2;

  // Human-readable string describing the error. There is a 1:1 mapping between
  // `code` and `error_message` (when code is not ERROR_UNSPECIFIED).
  // STABILITY: Not stable: the error message associated to a given code may
  // change (hopefully to clarify it) over time. Please rely on the code
  // instead.
  optional string error_message = 3;

  // May contain the value(s) of the field(s). This is not always available.
  // Users should absolutely not rely on it and use it only for manual model
  // debugging.
  optional string offending_values = 4;
}
