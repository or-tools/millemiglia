// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: lattle.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_lattle_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_lattle_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "resource.pb.h"
#include "field_behavior.pb.h"
#include <google/protobuf/duration.pb.h>
#include "datetime.pb.h"
#include "latlng.pb.h"
#include "int128.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_lattle_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_lattle_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_lattle_2eproto;
namespace operations_research {
namespace lattle {
class AnnotatedPathSegment;
struct AnnotatedPathSegmentDefaultTypeInternal;
extern AnnotatedPathSegmentDefaultTypeInternal _AnnotatedPathSegment_default_instance_;
class AnnotatedPathSegment_SegmentCostDueToVehicleEntry_DoNotUse;
struct AnnotatedPathSegment_SegmentCostDueToVehicleEntry_DoNotUseDefaultTypeInternal;
extern AnnotatedPathSegment_SegmentCostDueToVehicleEntry_DoNotUseDefaultTypeInternal _AnnotatedPathSegment_SegmentCostDueToVehicleEntry_DoNotUse_default_instance_;
class CrossDockingCapacity;
struct CrossDockingCapacityDefaultTypeInternal;
extern CrossDockingCapacityDefaultTypeInternal _CrossDockingCapacity_default_instance_;
class CrossDockingTime;
struct CrossDockingTimeDefaultTypeInternal;
extern CrossDockingTimeDefaultTypeInternal _CrossDockingTime_default_instance_;
class DateTimeRange;
struct DateTimeRangeDefaultTypeInternal;
extern DateTimeRangeDefaultTypeInternal _DateTimeRange_default_instance_;
class DistanceMatrixEntry;
struct DistanceMatrixEntryDefaultTypeInternal;
extern DistanceMatrixEntryDefaultTypeInternal _DistanceMatrixEntry_default_instance_;
class EarlinessTardiness;
struct EarlinessTardinessDefaultTypeInternal;
extern EarlinessTardinessDefaultTypeInternal _EarlinessTardiness_default_instance_;
class EarlinessTardinessCost;
struct EarlinessTardinessCostDefaultTypeInternal;
extern EarlinessTardinessCostDefaultTypeInternal _EarlinessTardinessCost_default_instance_;
class Function1D;
struct Function1DDefaultTypeInternal;
extern Function1DDefaultTypeInternal _Function1D_default_instance_;
class GeneratedLineAndRotation;
struct GeneratedLineAndRotationDefaultTypeInternal;
extern GeneratedLineAndRotationDefaultTypeInternal _GeneratedLineAndRotation_default_instance_;
class GeneratedLineAndRotation_ArrivalTimesEntry_DoNotUse;
struct GeneratedLineAndRotation_ArrivalTimesEntry_DoNotUseDefaultTypeInternal;
extern GeneratedLineAndRotation_ArrivalTimesEntry_DoNotUseDefaultTypeInternal _GeneratedLineAndRotation_ArrivalTimesEntry_DoNotUse_default_instance_;
class GeneratedLineAndRotation_DepartureTimesEntry_DoNotUse;
struct GeneratedLineAndRotation_DepartureTimesEntry_DoNotUseDefaultTypeInternal;
extern GeneratedLineAndRotation_DepartureTimesEntry_DoNotUseDefaultTypeInternal _GeneratedLineAndRotation_DepartureTimesEntry_DoNotUse_default_instance_;
class Hub;
struct HubDefaultTypeInternal;
extern HubDefaultTypeInternal _Hub_default_instance_;
class IncompletePath;
struct IncompletePathDefaultTypeInternal;
extern IncompletePathDefaultTypeInternal _IncompletePath_default_instance_;
class Instance;
struct InstanceDefaultTypeInternal;
extern InstanceDefaultTypeInternal _Instance_default_instance_;
class Instance_ParcelsEntry_DoNotUse;
struct Instance_ParcelsEntry_DoNotUseDefaultTypeInternal;
extern Instance_ParcelsEntry_DoNotUseDefaultTypeInternal _Instance_ParcelsEntry_DoNotUse_default_instance_;
class IntegerRange;
struct IntegerRangeDefaultTypeInternal;
extern IntegerRangeDefaultTypeInternal _IntegerRange_default_instance_;
class LattleValidationError;
struct LattleValidationErrorDefaultTypeInternal;
extern LattleValidationErrorDefaultTypeInternal _LattleValidationError_default_instance_;
class LattleValidationError_FieldReference;
struct LattleValidationError_FieldReferenceDefaultTypeInternal;
extern LattleValidationError_FieldReferenceDefaultTypeInternal _LattleValidationError_FieldReference_default_instance_;
class Line;
struct LineDefaultTypeInternal;
extern LineDefaultTypeInternal _Line_default_instance_;
class LineRotation;
struct LineRotationDefaultTypeInternal;
extern LineRotationDefaultTypeInternal _LineRotation_default_instance_;
class LineRotation_ArrivalEarlinessTardinessCostsEntry_DoNotUse;
struct LineRotation_ArrivalEarlinessTardinessCostsEntry_DoNotUseDefaultTypeInternal;
extern LineRotation_ArrivalEarlinessTardinessCostsEntry_DoNotUseDefaultTypeInternal _LineRotation_ArrivalEarlinessTardinessCostsEntry_DoNotUse_default_instance_;
class LineRotation_ArrivalTimesEntry_DoNotUse;
struct LineRotation_ArrivalTimesEntry_DoNotUseDefaultTypeInternal;
extern LineRotation_ArrivalTimesEntry_DoNotUseDefaultTypeInternal _LineRotation_ArrivalTimesEntry_DoNotUse_default_instance_;
class LineRotation_DepartureTimesEntry_DoNotUse;
struct LineRotation_DepartureTimesEntry_DoNotUseDefaultTypeInternal;
extern LineRotation_DepartureTimesEntry_DoNotUseDefaultTypeInternal _LineRotation_DepartureTimesEntry_DoNotUse_default_instance_;
class LineRotation_StartingEarlinessTardinessCostsEntry_DoNotUse;
struct LineRotation_StartingEarlinessTardinessCostsEntry_DoNotUseDefaultTypeInternal;
extern LineRotation_StartingEarlinessTardinessCostsEntry_DoNotUseDefaultTypeInternal _LineRotation_StartingEarlinessTardinessCostsEntry_DoNotUse_default_instance_;
class Line_NextRotationsEntry_DoNotUse;
struct Line_NextRotationsEntry_DoNotUseDefaultTypeInternal;
extern Line_NextRotationsEntry_DoNotUseDefaultTypeInternal _Line_NextRotationsEntry_DoNotUse_default_instance_;
class LogisticsNetwork;
struct LogisticsNetworkDefaultTypeInternal;
extern LogisticsNetworkDefaultTypeInternal _LogisticsNetwork_default_instance_;
class LogisticsNetworkState;
struct LogisticsNetworkStateDefaultTypeInternal;
extern LogisticsNetworkStateDefaultTypeInternal _LogisticsNetworkState_default_instance_;
class LogisticsNetworkState_UsedCapacityInVehicle;
struct LogisticsNetworkState_UsedCapacityInVehicleDefaultTypeInternal;
extern LogisticsNetworkState_UsedCapacityInVehicleDefaultTypeInternal _LogisticsNetworkState_UsedCapacityInVehicle_default_instance_;
class LogisticsNetwork_HubsEntry_DoNotUse;
struct LogisticsNetwork_HubsEntry_DoNotUseDefaultTypeInternal;
extern LogisticsNetwork_HubsEntry_DoNotUseDefaultTypeInternal _LogisticsNetwork_HubsEntry_DoNotUse_default_instance_;
class LogisticsNetwork_LinesEntry_DoNotUse;
struct LogisticsNetwork_LinesEntry_DoNotUseDefaultTypeInternal;
extern LogisticsNetwork_LinesEntry_DoNotUseDefaultTypeInternal _LogisticsNetwork_LinesEntry_DoNotUse_default_instance_;
class LogisticsNetwork_VehiclesEntry_DoNotUse;
struct LogisticsNetwork_VehiclesEntry_DoNotUseDefaultTypeInternal;
extern LogisticsNetwork_VehiclesEntry_DoNotUseDefaultTypeInternal _LogisticsNetwork_VehiclesEntry_DoNotUse_default_instance_;
class Parcel;
struct ParcelDefaultTypeInternal;
extern ParcelDefaultTypeInternal _Parcel_default_instance_;
class ParcelRoute;
struct ParcelRouteDefaultTypeInternal;
extern ParcelRouteDefaultTypeInternal _ParcelRoute_default_instance_;
class ParcelRoute_CostEntry_DoNotUse;
struct ParcelRoute_CostEntry_DoNotUseDefaultTypeInternal;
extern ParcelRoute_CostEntry_DoNotUseDefaultTypeInternal _ParcelRoute_CostEntry_DoNotUse_default_instance_;
class Path;
struct PathDefaultTypeInternal;
extern PathDefaultTypeInternal _Path_default_instance_;
class PathSegment;
struct PathSegmentDefaultTypeInternal;
extern PathSegmentDefaultTypeInternal _PathSegment_default_instance_;
class PieceWiseAffineFunction;
struct PieceWiseAffineFunctionDefaultTypeInternal;
extern PieceWiseAffineFunctionDefaultTypeInternal _PieceWiseAffineFunction_default_instance_;
class PieceWiseAffineSegment;
struct PieceWiseAffineSegmentDefaultTypeInternal;
extern PieceWiseAffineSegmentDefaultTypeInternal _PieceWiseAffineSegment_default_instance_;
class PricingStrategy;
struct PricingStrategyDefaultTypeInternal;
extern PricingStrategyDefaultTypeInternal _PricingStrategy_default_instance_;
class SeparableNDFunction;
struct SeparableNDFunctionDefaultTypeInternal;
extern SeparableNDFunctionDefaultTypeInternal _SeparableNDFunction_default_instance_;
class SeparableNDFunction_ComponentsEntry_DoNotUse;
struct SeparableNDFunction_ComponentsEntry_DoNotUseDefaultTypeInternal;
extern SeparableNDFunction_ComponentsEntry_DoNotUseDefaultTypeInternal _SeparableNDFunction_ComponentsEntry_DoNotUse_default_instance_;
class ValueDimension;
struct ValueDimensionDefaultTypeInternal;
extern ValueDimensionDefaultTypeInternal _ValueDimension_default_instance_;
class Vehicle;
struct VehicleDefaultTypeInternal;
extern VehicleDefaultTypeInternal _Vehicle_default_instance_;
}  // namespace lattle
}  // namespace operations_research
PROTOBUF_NAMESPACE_OPEN
template<> ::operations_research::lattle::AnnotatedPathSegment* Arena::CreateMaybeMessage<::operations_research::lattle::AnnotatedPathSegment>(Arena*);
template<> ::operations_research::lattle::AnnotatedPathSegment_SegmentCostDueToVehicleEntry_DoNotUse* Arena::CreateMaybeMessage<::operations_research::lattle::AnnotatedPathSegment_SegmentCostDueToVehicleEntry_DoNotUse>(Arena*);
template<> ::operations_research::lattle::CrossDockingCapacity* Arena::CreateMaybeMessage<::operations_research::lattle::CrossDockingCapacity>(Arena*);
template<> ::operations_research::lattle::CrossDockingTime* Arena::CreateMaybeMessage<::operations_research::lattle::CrossDockingTime>(Arena*);
template<> ::operations_research::lattle::DateTimeRange* Arena::CreateMaybeMessage<::operations_research::lattle::DateTimeRange>(Arena*);
template<> ::operations_research::lattle::DistanceMatrixEntry* Arena::CreateMaybeMessage<::operations_research::lattle::DistanceMatrixEntry>(Arena*);
template<> ::operations_research::lattle::EarlinessTardiness* Arena::CreateMaybeMessage<::operations_research::lattle::EarlinessTardiness>(Arena*);
template<> ::operations_research::lattle::EarlinessTardinessCost* Arena::CreateMaybeMessage<::operations_research::lattle::EarlinessTardinessCost>(Arena*);
template<> ::operations_research::lattle::Function1D* Arena::CreateMaybeMessage<::operations_research::lattle::Function1D>(Arena*);
template<> ::operations_research::lattle::GeneratedLineAndRotation* Arena::CreateMaybeMessage<::operations_research::lattle::GeneratedLineAndRotation>(Arena*);
template<> ::operations_research::lattle::GeneratedLineAndRotation_ArrivalTimesEntry_DoNotUse* Arena::CreateMaybeMessage<::operations_research::lattle::GeneratedLineAndRotation_ArrivalTimesEntry_DoNotUse>(Arena*);
template<> ::operations_research::lattle::GeneratedLineAndRotation_DepartureTimesEntry_DoNotUse* Arena::CreateMaybeMessage<::operations_research::lattle::GeneratedLineAndRotation_DepartureTimesEntry_DoNotUse>(Arena*);
template<> ::operations_research::lattle::Hub* Arena::CreateMaybeMessage<::operations_research::lattle::Hub>(Arena*);
template<> ::operations_research::lattle::IncompletePath* Arena::CreateMaybeMessage<::operations_research::lattle::IncompletePath>(Arena*);
template<> ::operations_research::lattle::Instance* Arena::CreateMaybeMessage<::operations_research::lattle::Instance>(Arena*);
template<> ::operations_research::lattle::Instance_ParcelsEntry_DoNotUse* Arena::CreateMaybeMessage<::operations_research::lattle::Instance_ParcelsEntry_DoNotUse>(Arena*);
template<> ::operations_research::lattle::IntegerRange* Arena::CreateMaybeMessage<::operations_research::lattle::IntegerRange>(Arena*);
template<> ::operations_research::lattle::LattleValidationError* Arena::CreateMaybeMessage<::operations_research::lattle::LattleValidationError>(Arena*);
template<> ::operations_research::lattle::LattleValidationError_FieldReference* Arena::CreateMaybeMessage<::operations_research::lattle::LattleValidationError_FieldReference>(Arena*);
template<> ::operations_research::lattle::Line* Arena::CreateMaybeMessage<::operations_research::lattle::Line>(Arena*);
template<> ::operations_research::lattle::LineRotation* Arena::CreateMaybeMessage<::operations_research::lattle::LineRotation>(Arena*);
template<> ::operations_research::lattle::LineRotation_ArrivalEarlinessTardinessCostsEntry_DoNotUse* Arena::CreateMaybeMessage<::operations_research::lattle::LineRotation_ArrivalEarlinessTardinessCostsEntry_DoNotUse>(Arena*);
template<> ::operations_research::lattle::LineRotation_ArrivalTimesEntry_DoNotUse* Arena::CreateMaybeMessage<::operations_research::lattle::LineRotation_ArrivalTimesEntry_DoNotUse>(Arena*);
template<> ::operations_research::lattle::LineRotation_DepartureTimesEntry_DoNotUse* Arena::CreateMaybeMessage<::operations_research::lattle::LineRotation_DepartureTimesEntry_DoNotUse>(Arena*);
template<> ::operations_research::lattle::LineRotation_StartingEarlinessTardinessCostsEntry_DoNotUse* Arena::CreateMaybeMessage<::operations_research::lattle::LineRotation_StartingEarlinessTardinessCostsEntry_DoNotUse>(Arena*);
template<> ::operations_research::lattle::Line_NextRotationsEntry_DoNotUse* Arena::CreateMaybeMessage<::operations_research::lattle::Line_NextRotationsEntry_DoNotUse>(Arena*);
template<> ::operations_research::lattle::LogisticsNetwork* Arena::CreateMaybeMessage<::operations_research::lattle::LogisticsNetwork>(Arena*);
template<> ::operations_research::lattle::LogisticsNetworkState* Arena::CreateMaybeMessage<::operations_research::lattle::LogisticsNetworkState>(Arena*);
template<> ::operations_research::lattle::LogisticsNetworkState_UsedCapacityInVehicle* Arena::CreateMaybeMessage<::operations_research::lattle::LogisticsNetworkState_UsedCapacityInVehicle>(Arena*);
template<> ::operations_research::lattle::LogisticsNetwork_HubsEntry_DoNotUse* Arena::CreateMaybeMessage<::operations_research::lattle::LogisticsNetwork_HubsEntry_DoNotUse>(Arena*);
template<> ::operations_research::lattle::LogisticsNetwork_LinesEntry_DoNotUse* Arena::CreateMaybeMessage<::operations_research::lattle::LogisticsNetwork_LinesEntry_DoNotUse>(Arena*);
template<> ::operations_research::lattle::LogisticsNetwork_VehiclesEntry_DoNotUse* Arena::CreateMaybeMessage<::operations_research::lattle::LogisticsNetwork_VehiclesEntry_DoNotUse>(Arena*);
template<> ::operations_research::lattle::Parcel* Arena::CreateMaybeMessage<::operations_research::lattle::Parcel>(Arena*);
template<> ::operations_research::lattle::ParcelRoute* Arena::CreateMaybeMessage<::operations_research::lattle::ParcelRoute>(Arena*);
template<> ::operations_research::lattle::ParcelRoute_CostEntry_DoNotUse* Arena::CreateMaybeMessage<::operations_research::lattle::ParcelRoute_CostEntry_DoNotUse>(Arena*);
template<> ::operations_research::lattle::Path* Arena::CreateMaybeMessage<::operations_research::lattle::Path>(Arena*);
template<> ::operations_research::lattle::PathSegment* Arena::CreateMaybeMessage<::operations_research::lattle::PathSegment>(Arena*);
template<> ::operations_research::lattle::PieceWiseAffineFunction* Arena::CreateMaybeMessage<::operations_research::lattle::PieceWiseAffineFunction>(Arena*);
template<> ::operations_research::lattle::PieceWiseAffineSegment* Arena::CreateMaybeMessage<::operations_research::lattle::PieceWiseAffineSegment>(Arena*);
template<> ::operations_research::lattle::PricingStrategy* Arena::CreateMaybeMessage<::operations_research::lattle::PricingStrategy>(Arena*);
template<> ::operations_research::lattle::SeparableNDFunction* Arena::CreateMaybeMessage<::operations_research::lattle::SeparableNDFunction>(Arena*);
template<> ::operations_research::lattle::SeparableNDFunction_ComponentsEntry_DoNotUse* Arena::CreateMaybeMessage<::operations_research::lattle::SeparableNDFunction_ComponentsEntry_DoNotUse>(Arena*);
template<> ::operations_research::lattle::ValueDimension* Arena::CreateMaybeMessage<::operations_research::lattle::ValueDimension>(Arena*);
template<> ::operations_research::lattle::Vehicle* Arena::CreateMaybeMessage<::operations_research::lattle::Vehicle>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace operations_research {
namespace lattle {

enum LattleValidationError_Code : int {
  LattleValidationError_Code_ERROR_UNSPECIFIED = 0,
  LattleValidationError_Code_VALIDATION_ERROR = 2,
  LattleValidationError_Code_VALIDATION_TIMEOUT_ERROR = 200,
  LattleValidationError_Code_VALIDATION_OBJECT_ALREADY_INITIALIZED = 201,
  LattleValidationError_Code_LOGISTICS_NETWORK_ERROR = 4,
  LattleValidationError_Code_LOGISTICS_NETWORK_NO_DIMENSION = 400,
  LattleValidationError_Code_LOGISTICS_NETWORK_STATE_ERROR = 6,
  LattleValidationError_Code_LOGISTICS_NETWORK_STATE_INTERNAL_ERROR = 600,
  LattleValidationError_Code_VALUE_DIMENSION_ERROR = 8,
  LattleValidationError_Code_VALUE_DIMENSION_UNKNOWN_DIMENSION = 800,
  LattleValidationError_Code_LINE_ERROR = 10,
  LattleValidationError_Code_LINE_NOT_IN_NETWORK = 1000,
  LattleValidationError_Code_LINE_ROTATION_NOT_IN_NETWORK = 1001,
  LattleValidationError_Code_LINE_HUBS_NOT_IN_NETWORK = 1002,
  LattleValidationError_Code_LINE_ROTATION_WRONG_NUMBER_OF_ARRIVALS = 1003,
  LattleValidationError_Code_LINE_ROTATION_WRONG_NUMBER_OF_DEPARTURES = 1004,
  LattleValidationError_Code_LINE_ROTATION_HUB_NOT_IN_LINE = 1005,
  LattleValidationError_Code_LINE_ROTATION_WRONG_ORDER_OF_HUBS_TIME_WISE = 1006,
  LattleValidationError_Code_VEHICLE_ERROR = 12,
  LattleValidationError_Code_VEHICLE_CAPACITY_DIMENSION_NOT_IN_NETWORK = 1200,
  LattleValidationError_Code_DISTANCE_MATRIX_ERROR = 14,
  LattleValidationError_Code_DISTANCE_MATRIX_ENTRY_SOURCE_HUB_NOT_IN_NETWORK = 1400,
  LattleValidationError_Code_DISTANCE_MATRIX_ENTRY_DESTINATION_HUB_NOT_IN_NETWORK = 1401,
  LattleValidationError_Code_DISTANCE_MATRIX_ENTRY_WEIGHT_DIMENSION_NOT_IN_NETWORK = 1402,
  LattleValidationError_Code_LattleValidationError_Code_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LattleValidationError_Code_LattleValidationError_Code_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LattleValidationError_Code_IsValid(int value);
constexpr LattleValidationError_Code LattleValidationError_Code_Code_MIN = LattleValidationError_Code_ERROR_UNSPECIFIED;
constexpr LattleValidationError_Code LattleValidationError_Code_Code_MAX = LattleValidationError_Code_DISTANCE_MATRIX_ENTRY_WEIGHT_DIMENSION_NOT_IN_NETWORK;
constexpr int LattleValidationError_Code_Code_ARRAYSIZE = LattleValidationError_Code_Code_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LattleValidationError_Code_descriptor();
template<typename T>
inline const std::string& LattleValidationError_Code_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LattleValidationError_Code>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LattleValidationError_Code_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LattleValidationError_Code_descriptor(), enum_t_value);
}
inline bool LattleValidationError_Code_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LattleValidationError_Code* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LattleValidationError_Code>(
    LattleValidationError_Code_descriptor(), name, value);
}
// ===================================================================

class DateTimeRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.DateTimeRange) */ {
 public:
  inline DateTimeRange() : DateTimeRange(nullptr) {}
  ~DateTimeRange() override;
  explicit PROTOBUF_CONSTEXPR DateTimeRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DateTimeRange(const DateTimeRange& from);
  DateTimeRange(DateTimeRange&& from) noexcept
    : DateTimeRange() {
    *this = ::std::move(from);
  }

  inline DateTimeRange& operator=(const DateTimeRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline DateTimeRange& operator=(DateTimeRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DateTimeRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const DateTimeRange* internal_default_instance() {
    return reinterpret_cast<const DateTimeRange*>(
               &_DateTimeRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DateTimeRange& a, DateTimeRange& b) {
    a.Swap(&b);
  }
  inline void Swap(DateTimeRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DateTimeRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DateTimeRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DateTimeRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DateTimeRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DateTimeRange& from) {
    DateTimeRange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DateTimeRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.DateTimeRange";
  }
  protected:
  explicit DateTimeRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstDateFieldNumber = 1,
    kLastDateFieldNumber = 2,
  };
  // .google.type.DateTime first_date = 1;
  bool has_first_date() const;
  private:
  bool _internal_has_first_date() const;
  public:
  void clear_first_date();
  const ::google::type::DateTime& first_date() const;
  PROTOBUF_NODISCARD ::google::type::DateTime* release_first_date();
  ::google::type::DateTime* mutable_first_date();
  void set_allocated_first_date(::google::type::DateTime* first_date);
  private:
  const ::google::type::DateTime& _internal_first_date() const;
  ::google::type::DateTime* _internal_mutable_first_date();
  public:
  void unsafe_arena_set_allocated_first_date(
      ::google::type::DateTime* first_date);
  ::google::type::DateTime* unsafe_arena_release_first_date();

  // .google.type.DateTime last_date = 2;
  bool has_last_date() const;
  private:
  bool _internal_has_last_date() const;
  public:
  void clear_last_date();
  const ::google::type::DateTime& last_date() const;
  PROTOBUF_NODISCARD ::google::type::DateTime* release_last_date();
  ::google::type::DateTime* mutable_last_date();
  void set_allocated_last_date(::google::type::DateTime* last_date);
  private:
  const ::google::type::DateTime& _internal_last_date() const;
  ::google::type::DateTime* _internal_mutable_last_date();
  public:
  void unsafe_arena_set_allocated_last_date(
      ::google::type::DateTime* last_date);
  ::google::type::DateTime* unsafe_arena_release_last_date();

  // @@protoc_insertion_point(class_scope:operations_research.lattle.DateTimeRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::type::DateTime* first_date_;
    ::google::type::DateTime* last_date_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class IntegerRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.IntegerRange) */ {
 public:
  inline IntegerRange() : IntegerRange(nullptr) {}
  ~IntegerRange() override;
  explicit PROTOBUF_CONSTEXPR IntegerRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntegerRange(const IntegerRange& from);
  IntegerRange(IntegerRange&& from) noexcept
    : IntegerRange() {
    *this = ::std::move(from);
  }

  inline IntegerRange& operator=(const IntegerRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntegerRange& operator=(IntegerRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntegerRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntegerRange* internal_default_instance() {
    return reinterpret_cast<const IntegerRange*>(
               &_IntegerRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(IntegerRange& a, IntegerRange& b) {
    a.Swap(&b);
  }
  inline void Swap(IntegerRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntegerRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntegerRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntegerRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntegerRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntegerRange& from) {
    IntegerRange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntegerRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.IntegerRange";
  }
  protected:
  explicit IntegerRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartValueFieldNumber = 1,
    kEndValueFieldNumber = 2,
  };
  // optional int32 start_value = 1;
  bool has_start_value() const;
  private:
  bool _internal_has_start_value() const;
  public:
  void clear_start_value();
  int32_t start_value() const;
  void set_start_value(int32_t value);
  private:
  int32_t _internal_start_value() const;
  void _internal_set_start_value(int32_t value);
  public:

  // optional int32 end_value = 2;
  bool has_end_value() const;
  private:
  bool _internal_has_end_value() const;
  public:
  void clear_end_value();
  int32_t end_value() const;
  void set_end_value(int32_t value);
  private:
  int32_t _internal_end_value() const;
  void _internal_set_end_value(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:operations_research.lattle.IntegerRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t start_value_;
    int32_t end_value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class Function1D final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.Function1D) */ {
 public:
  inline Function1D() : Function1D(nullptr) {}
  ~Function1D() override;
  explicit PROTOBUF_CONSTEXPR Function1D(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Function1D(const Function1D& from);
  Function1D(Function1D&& from) noexcept
    : Function1D() {
    *this = ::std::move(from);
  }

  inline Function1D& operator=(const Function1D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Function1D& operator=(Function1D&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Function1D& default_instance() {
    return *internal_default_instance();
  }
  enum FunctionCase {
    kConstant = 1,
    kPwl = 2,
    FUNCTION_NOT_SET = 0,
  };

  static inline const Function1D* internal_default_instance() {
    return reinterpret_cast<const Function1D*>(
               &_Function1D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Function1D& a, Function1D& b) {
    a.Swap(&b);
  }
  inline void Swap(Function1D* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Function1D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Function1D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Function1D>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Function1D& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Function1D& from) {
    Function1D::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Function1D* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.Function1D";
  }
  protected:
  explicit Function1D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConstantFieldNumber = 1,
    kPwlFieldNumber = 2,
  };
  // double constant = 1;
  bool has_constant() const;
  private:
  bool _internal_has_constant() const;
  public:
  void clear_constant();
  double constant() const;
  void set_constant(double value);
  private:
  double _internal_constant() const;
  void _internal_set_constant(double value);
  public:

  // .operations_research.lattle.PieceWiseAffineFunction pwl = 2;
  bool has_pwl() const;
  private:
  bool _internal_has_pwl() const;
  public:
  void clear_pwl();
  const ::operations_research::lattle::PieceWiseAffineFunction& pwl() const;
  PROTOBUF_NODISCARD ::operations_research::lattle::PieceWiseAffineFunction* release_pwl();
  ::operations_research::lattle::PieceWiseAffineFunction* mutable_pwl();
  void set_allocated_pwl(::operations_research::lattle::PieceWiseAffineFunction* pwl);
  private:
  const ::operations_research::lattle::PieceWiseAffineFunction& _internal_pwl() const;
  ::operations_research::lattle::PieceWiseAffineFunction* _internal_mutable_pwl();
  public:
  void unsafe_arena_set_allocated_pwl(
      ::operations_research::lattle::PieceWiseAffineFunction* pwl);
  ::operations_research::lattle::PieceWiseAffineFunction* unsafe_arena_release_pwl();

  void clear_function();
  FunctionCase function_case() const;
  // @@protoc_insertion_point(class_scope:operations_research.lattle.Function1D)
 private:
  class _Internal;
  void set_has_constant();
  void set_has_pwl();

  inline bool has_function() const;
  inline void clear_has_function();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union FunctionUnion {
      constexpr FunctionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      double constant_;
      ::operations_research::lattle::PieceWiseAffineFunction* pwl_;
    } function_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class PricingStrategy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.PricingStrategy) */ {
 public:
  inline PricingStrategy() : PricingStrategy(nullptr) {}
  ~PricingStrategy() override;
  explicit PROTOBUF_CONSTEXPR PricingStrategy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PricingStrategy(const PricingStrategy& from);
  PricingStrategy(PricingStrategy&& from) noexcept
    : PricingStrategy() {
    *this = ::std::move(from);
  }

  inline PricingStrategy& operator=(const PricingStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  inline PricingStrategy& operator=(PricingStrategy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PricingStrategy& default_instance() {
    return *internal_default_instance();
  }
  enum PricingStrategyCase {
    kSeparable = 1,
    PRICING_STRATEGY_NOT_SET = 0,
  };

  static inline const PricingStrategy* internal_default_instance() {
    return reinterpret_cast<const PricingStrategy*>(
               &_PricingStrategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PricingStrategy& a, PricingStrategy& b) {
    a.Swap(&b);
  }
  inline void Swap(PricingStrategy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PricingStrategy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PricingStrategy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PricingStrategy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PricingStrategy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PricingStrategy& from) {
    PricingStrategy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PricingStrategy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.PricingStrategy";
  }
  protected:
  explicit PricingStrategy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeparableFieldNumber = 1,
  };
  // .operations_research.lattle.SeparableNDFunction separable = 1;
  bool has_separable() const;
  private:
  bool _internal_has_separable() const;
  public:
  void clear_separable();
  const ::operations_research::lattle::SeparableNDFunction& separable() const;
  PROTOBUF_NODISCARD ::operations_research::lattle::SeparableNDFunction* release_separable();
  ::operations_research::lattle::SeparableNDFunction* mutable_separable();
  void set_allocated_separable(::operations_research::lattle::SeparableNDFunction* separable);
  private:
  const ::operations_research::lattle::SeparableNDFunction& _internal_separable() const;
  ::operations_research::lattle::SeparableNDFunction* _internal_mutable_separable();
  public:
  void unsafe_arena_set_allocated_separable(
      ::operations_research::lattle::SeparableNDFunction* separable);
  ::operations_research::lattle::SeparableNDFunction* unsafe_arena_release_separable();

  void clear_pricing_strategy();
  PricingStrategyCase pricing_strategy_case() const;
  // @@protoc_insertion_point(class_scope:operations_research.lattle.PricingStrategy)
 private:
  class _Internal;
  void set_has_separable();

  inline bool has_pricing_strategy() const;
  inline void clear_has_pricing_strategy();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union PricingStrategyUnion {
      constexpr PricingStrategyUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::operations_research::lattle::SeparableNDFunction* separable_;
    } pricing_strategy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class SeparableNDFunction_ComponentsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SeparableNDFunction_ComponentsEntry_DoNotUse, 
    std::string, ::operations_research::lattle::Function1D,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SeparableNDFunction_ComponentsEntry_DoNotUse, 
    std::string, ::operations_research::lattle::Function1D,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SeparableNDFunction_ComponentsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SeparableNDFunction_ComponentsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SeparableNDFunction_ComponentsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SeparableNDFunction_ComponentsEntry_DoNotUse& other);
  static const SeparableNDFunction_ComponentsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SeparableNDFunction_ComponentsEntry_DoNotUse*>(&_SeparableNDFunction_ComponentsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "operations_research.lattle.SeparableNDFunction.ComponentsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lattle_2eproto;
};

// -------------------------------------------------------------------

class SeparableNDFunction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.SeparableNDFunction) */ {
 public:
  inline SeparableNDFunction() : SeparableNDFunction(nullptr) {}
  ~SeparableNDFunction() override;
  explicit PROTOBUF_CONSTEXPR SeparableNDFunction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SeparableNDFunction(const SeparableNDFunction& from);
  SeparableNDFunction(SeparableNDFunction&& from) noexcept
    : SeparableNDFunction() {
    *this = ::std::move(from);
  }

  inline SeparableNDFunction& operator=(const SeparableNDFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline SeparableNDFunction& operator=(SeparableNDFunction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SeparableNDFunction& default_instance() {
    return *internal_default_instance();
  }
  static inline const SeparableNDFunction* internal_default_instance() {
    return reinterpret_cast<const SeparableNDFunction*>(
               &_SeparableNDFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SeparableNDFunction& a, SeparableNDFunction& b) {
    a.Swap(&b);
  }
  inline void Swap(SeparableNDFunction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SeparableNDFunction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SeparableNDFunction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SeparableNDFunction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SeparableNDFunction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SeparableNDFunction& from) {
    SeparableNDFunction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SeparableNDFunction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.SeparableNDFunction";
  }
  protected:
  explicit SeparableNDFunction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kComponentsFieldNumber = 1,
    kConstantPriceFieldNumber = 2,
  };
  // map<string, .operations_research.lattle.Function1D> components = 1;
  int components_size() const;
  private:
  int _internal_components_size() const;
  public:
  void clear_components();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Function1D >&
      _internal_components() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Function1D >*
      _internal_mutable_components();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Function1D >&
      components() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Function1D >*
      mutable_components();

  // double constant_price = 2;
  void clear_constant_price();
  double constant_price() const;
  void set_constant_price(double value);
  private:
  double _internal_constant_price() const;
  void _internal_set_constant_price(double value);
  public:

  // @@protoc_insertion_point(class_scope:operations_research.lattle.SeparableNDFunction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SeparableNDFunction_ComponentsEntry_DoNotUse,
        std::string, ::operations_research::lattle::Function1D,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> components_;
    double constant_price_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class ValueDimension final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.ValueDimension) */ {
 public:
  inline ValueDimension() : ValueDimension(nullptr) {}
  ~ValueDimension() override;
  explicit PROTOBUF_CONSTEXPR ValueDimension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValueDimension(const ValueDimension& from);
  ValueDimension(ValueDimension&& from) noexcept
    : ValueDimension() {
    *this = ::std::move(from);
  }

  inline ValueDimension& operator=(const ValueDimension& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValueDimension& operator=(ValueDimension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValueDimension& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValueDimension* internal_default_instance() {
    return reinterpret_cast<const ValueDimension*>(
               &_ValueDimension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ValueDimension& a, ValueDimension& b) {
    a.Swap(&b);
  }
  inline void Swap(ValueDimension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValueDimension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValueDimension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValueDimension>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValueDimension& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValueDimension& from) {
    ValueDimension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValueDimension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.ValueDimension";
  }
  protected:
  explicit ValueDimension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionFieldNumber = 2,
    kValueFieldNumber = 1,
  };
  // string dimension = 2;
  void clear_dimension();
  const std::string& dimension() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dimension(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dimension();
  PROTOBUF_NODISCARD std::string* release_dimension();
  void set_allocated_dimension(std::string* dimension);
  private:
  const std::string& _internal_dimension() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimension(const std::string& value);
  std::string* _internal_mutable_dimension();
  public:

  // int64 value = 1;
  void clear_value();
  int64_t value() const;
  void set_value(int64_t value);
  private:
  int64_t _internal_value() const;
  void _internal_set_value(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:operations_research.lattle.ValueDimension)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dimension_;
    int64_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class PieceWiseAffineFunction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.PieceWiseAffineFunction) */ {
 public:
  inline PieceWiseAffineFunction() : PieceWiseAffineFunction(nullptr) {}
  ~PieceWiseAffineFunction() override;
  explicit PROTOBUF_CONSTEXPR PieceWiseAffineFunction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PieceWiseAffineFunction(const PieceWiseAffineFunction& from);
  PieceWiseAffineFunction(PieceWiseAffineFunction&& from) noexcept
    : PieceWiseAffineFunction() {
    *this = ::std::move(from);
  }

  inline PieceWiseAffineFunction& operator=(const PieceWiseAffineFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline PieceWiseAffineFunction& operator=(PieceWiseAffineFunction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PieceWiseAffineFunction& default_instance() {
    return *internal_default_instance();
  }
  static inline const PieceWiseAffineFunction* internal_default_instance() {
    return reinterpret_cast<const PieceWiseAffineFunction*>(
               &_PieceWiseAffineFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PieceWiseAffineFunction& a, PieceWiseAffineFunction& b) {
    a.Swap(&b);
  }
  inline void Swap(PieceWiseAffineFunction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PieceWiseAffineFunction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PieceWiseAffineFunction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PieceWiseAffineFunction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PieceWiseAffineFunction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PieceWiseAffineFunction& from) {
    PieceWiseAffineFunction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PieceWiseAffineFunction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.PieceWiseAffineFunction";
  }
  protected:
  explicit PieceWiseAffineFunction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegmentsFieldNumber = 1,
  };
  // repeated .operations_research.lattle.PieceWiseAffineSegment segments = 1;
  int segments_size() const;
  private:
  int _internal_segments_size() const;
  public:
  void clear_segments();
  ::operations_research::lattle::PieceWiseAffineSegment* mutable_segments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::PieceWiseAffineSegment >*
      mutable_segments();
  private:
  const ::operations_research::lattle::PieceWiseAffineSegment& _internal_segments(int index) const;
  ::operations_research::lattle::PieceWiseAffineSegment* _internal_add_segments();
  public:
  const ::operations_research::lattle::PieceWiseAffineSegment& segments(int index) const;
  ::operations_research::lattle::PieceWiseAffineSegment* add_segments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::PieceWiseAffineSegment >&
      segments() const;

  // @@protoc_insertion_point(class_scope:operations_research.lattle.PieceWiseAffineFunction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::PieceWiseAffineSegment > segments_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class PieceWiseAffineSegment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.PieceWiseAffineSegment) */ {
 public:
  inline PieceWiseAffineSegment() : PieceWiseAffineSegment(nullptr) {}
  ~PieceWiseAffineSegment() override;
  explicit PROTOBUF_CONSTEXPR PieceWiseAffineSegment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PieceWiseAffineSegment(const PieceWiseAffineSegment& from);
  PieceWiseAffineSegment(PieceWiseAffineSegment&& from) noexcept
    : PieceWiseAffineSegment() {
    *this = ::std::move(from);
  }

  inline PieceWiseAffineSegment& operator=(const PieceWiseAffineSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline PieceWiseAffineSegment& operator=(PieceWiseAffineSegment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PieceWiseAffineSegment& default_instance() {
    return *internal_default_instance();
  }
  static inline const PieceWiseAffineSegment* internal_default_instance() {
    return reinterpret_cast<const PieceWiseAffineSegment*>(
               &_PieceWiseAffineSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PieceWiseAffineSegment& a, PieceWiseAffineSegment& b) {
    a.Swap(&b);
  }
  inline void Swap(PieceWiseAffineSegment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PieceWiseAffineSegment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PieceWiseAffineSegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PieceWiseAffineSegment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PieceWiseAffineSegment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PieceWiseAffineSegment& from) {
    PieceWiseAffineSegment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PieceWiseAffineSegment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.PieceWiseAffineSegment";
  }
  protected:
  explicit PieceWiseAffineSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartXFieldNumber = 1,
    kStartYFieldNumber = 2,
    kEndXFieldNumber = 3,
    kEndYFieldNumber = 4,
  };
  // double start_x = 1;
  void clear_start_x();
  double start_x() const;
  void set_start_x(double value);
  private:
  double _internal_start_x() const;
  void _internal_set_start_x(double value);
  public:

  // double start_y = 2;
  void clear_start_y();
  double start_y() const;
  void set_start_y(double value);
  private:
  double _internal_start_y() const;
  void _internal_set_start_y(double value);
  public:

  // double end_x = 3;
  void clear_end_x();
  double end_x() const;
  void set_end_x(double value);
  private:
  double _internal_end_x() const;
  void _internal_set_end_x(double value);
  public:

  // double end_y = 4;
  void clear_end_y();
  double end_y() const;
  void set_end_y(double value);
  private:
  double _internal_end_y() const;
  void _internal_set_end_y(double value);
  public:

  // @@protoc_insertion_point(class_scope:operations_research.lattle.PieceWiseAffineSegment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double start_x_;
    double start_y_;
    double end_x_;
    double end_y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class Instance_ParcelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Instance_ParcelsEntry_DoNotUse, 
    std::string, ::operations_research::lattle::Parcel,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Instance_ParcelsEntry_DoNotUse, 
    std::string, ::operations_research::lattle::Parcel,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Instance_ParcelsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Instance_ParcelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Instance_ParcelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Instance_ParcelsEntry_DoNotUse& other);
  static const Instance_ParcelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Instance_ParcelsEntry_DoNotUse*>(&_Instance_ParcelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "operations_research.lattle.Instance.ParcelsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lattle_2eproto;
};

// -------------------------------------------------------------------

class Instance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.Instance) */ {
 public:
  inline Instance() : Instance(nullptr) {}
  ~Instance() override;
  explicit PROTOBUF_CONSTEXPR Instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Instance(const Instance& from);
  Instance(Instance&& from) noexcept
    : Instance() {
    *this = ::std::move(from);
  }

  inline Instance& operator=(const Instance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Instance& operator=(Instance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Instance& default_instance() {
    return *internal_default_instance();
  }
  static inline const Instance* internal_default_instance() {
    return reinterpret_cast<const Instance*>(
               &_Instance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Instance& a, Instance& b) {
    a.Swap(&b);
  }
  inline void Swap(Instance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Instance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Instance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Instance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Instance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Instance& from) {
    Instance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Instance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.Instance";
  }
  protected:
  explicit Instance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParcelsFieldNumber = 2,
    kNetworkFieldNumber = 1,
  };
  // map<string, .operations_research.lattle.Parcel> parcels = 2;
  int parcels_size() const;
  private:
  int _internal_parcels_size() const;
  public:
  void clear_parcels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Parcel >&
      _internal_parcels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Parcel >*
      _internal_mutable_parcels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Parcel >&
      parcels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Parcel >*
      mutable_parcels();

  // .operations_research.lattle.LogisticsNetwork network = 1;
  bool has_network() const;
  private:
  bool _internal_has_network() const;
  public:
  void clear_network();
  const ::operations_research::lattle::LogisticsNetwork& network() const;
  PROTOBUF_NODISCARD ::operations_research::lattle::LogisticsNetwork* release_network();
  ::operations_research::lattle::LogisticsNetwork* mutable_network();
  void set_allocated_network(::operations_research::lattle::LogisticsNetwork* network);
  private:
  const ::operations_research::lattle::LogisticsNetwork& _internal_network() const;
  ::operations_research::lattle::LogisticsNetwork* _internal_mutable_network();
  public:
  void unsafe_arena_set_allocated_network(
      ::operations_research::lattle::LogisticsNetwork* network);
  ::operations_research::lattle::LogisticsNetwork* unsafe_arena_release_network();

  // @@protoc_insertion_point(class_scope:operations_research.lattle.Instance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Instance_ParcelsEntry_DoNotUse,
        std::string, ::operations_research::lattle::Parcel,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> parcels_;
    ::operations_research::lattle::LogisticsNetwork* network_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class LogisticsNetwork_LinesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LogisticsNetwork_LinesEntry_DoNotUse, 
    std::string, ::operations_research::lattle::Line,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LogisticsNetwork_LinesEntry_DoNotUse, 
    std::string, ::operations_research::lattle::Line,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  LogisticsNetwork_LinesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR LogisticsNetwork_LinesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LogisticsNetwork_LinesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LogisticsNetwork_LinesEntry_DoNotUse& other);
  static const LogisticsNetwork_LinesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LogisticsNetwork_LinesEntry_DoNotUse*>(&_LogisticsNetwork_LinesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "operations_research.lattle.LogisticsNetwork.LinesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lattle_2eproto;
};

// -------------------------------------------------------------------

class LogisticsNetwork_VehiclesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LogisticsNetwork_VehiclesEntry_DoNotUse, 
    std::string, ::operations_research::lattle::Vehicle,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LogisticsNetwork_VehiclesEntry_DoNotUse, 
    std::string, ::operations_research::lattle::Vehicle,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  LogisticsNetwork_VehiclesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR LogisticsNetwork_VehiclesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LogisticsNetwork_VehiclesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LogisticsNetwork_VehiclesEntry_DoNotUse& other);
  static const LogisticsNetwork_VehiclesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LogisticsNetwork_VehiclesEntry_DoNotUse*>(&_LogisticsNetwork_VehiclesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "operations_research.lattle.LogisticsNetwork.VehiclesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lattle_2eproto;
};

// -------------------------------------------------------------------

class LogisticsNetwork_HubsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LogisticsNetwork_HubsEntry_DoNotUse, 
    std::string, ::operations_research::lattle::Hub,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LogisticsNetwork_HubsEntry_DoNotUse, 
    std::string, ::operations_research::lattle::Hub,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  LogisticsNetwork_HubsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR LogisticsNetwork_HubsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LogisticsNetwork_HubsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LogisticsNetwork_HubsEntry_DoNotUse& other);
  static const LogisticsNetwork_HubsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LogisticsNetwork_HubsEntry_DoNotUse*>(&_LogisticsNetwork_HubsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "operations_research.lattle.LogisticsNetwork.HubsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lattle_2eproto;
};

// -------------------------------------------------------------------

class LogisticsNetwork final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.LogisticsNetwork) */ {
 public:
  inline LogisticsNetwork() : LogisticsNetwork(nullptr) {}
  ~LogisticsNetwork() override;
  explicit PROTOBUF_CONSTEXPR LogisticsNetwork(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogisticsNetwork(const LogisticsNetwork& from);
  LogisticsNetwork(LogisticsNetwork&& from) noexcept
    : LogisticsNetwork() {
    *this = ::std::move(from);
  }

  inline LogisticsNetwork& operator=(const LogisticsNetwork& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogisticsNetwork& operator=(LogisticsNetwork&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogisticsNetwork& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogisticsNetwork* internal_default_instance() {
    return reinterpret_cast<const LogisticsNetwork*>(
               &_LogisticsNetwork_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(LogisticsNetwork& a, LogisticsNetwork& b) {
    a.Swap(&b);
  }
  inline void Swap(LogisticsNetwork* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogisticsNetwork* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogisticsNetwork* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogisticsNetwork>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogisticsNetwork& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogisticsNetwork& from) {
    LogisticsNetwork::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogisticsNetwork* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.LogisticsNetwork";
  }
  protected:
  explicit LogisticsNetwork(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kLinesFieldNumber = 2,
    kVehiclesFieldNumber = 3,
    kHubsFieldNumber = 4,
    kDimensionsFieldNumber = 5,
    kDistanceMatrixFieldNumber = 9,
    kNameFieldNumber = 1,
    kCurrencyCodeFieldNumber = 7,
    kPricingFieldNumber = 6,
    kTimeStepFieldNumber = 8,
  };
  // map<string, .operations_research.lattle.Line> lines = 2;
  int lines_size() const;
  private:
  int _internal_lines_size() const;
  public:
  void clear_lines();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Line >&
      _internal_lines() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Line >*
      _internal_mutable_lines();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Line >&
      lines() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Line >*
      mutable_lines();

  // map<string, .operations_research.lattle.Vehicle> vehicles = 3;
  int vehicles_size() const;
  private:
  int _internal_vehicles_size() const;
  public:
  void clear_vehicles();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Vehicle >&
      _internal_vehicles() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Vehicle >*
      _internal_mutable_vehicles();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Vehicle >&
      vehicles() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Vehicle >*
      mutable_vehicles();

  // map<string, .operations_research.lattle.Hub> hubs = 4;
  int hubs_size() const;
  private:
  int _internal_hubs_size() const;
  public:
  void clear_hubs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Hub >&
      _internal_hubs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Hub >*
      _internal_mutable_hubs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Hub >&
      hubs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Hub >*
      mutable_hubs();

  // repeated .operations_research.lattle.ValueDimension dimensions = 5;
  int dimensions_size() const;
  private:
  int _internal_dimensions_size() const;
  public:
  void clear_dimensions();
  ::operations_research::lattle::ValueDimension* mutable_dimensions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >*
      mutable_dimensions();
  private:
  const ::operations_research::lattle::ValueDimension& _internal_dimensions(int index) const;
  ::operations_research::lattle::ValueDimension* _internal_add_dimensions();
  public:
  const ::operations_research::lattle::ValueDimension& dimensions(int index) const;
  ::operations_research::lattle::ValueDimension* add_dimensions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >&
      dimensions() const;

  // repeated .operations_research.lattle.DistanceMatrixEntry distance_matrix = 9;
  int distance_matrix_size() const;
  private:
  int _internal_distance_matrix_size() const;
  public:
  void clear_distance_matrix();
  ::operations_research::lattle::DistanceMatrixEntry* mutable_distance_matrix(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::DistanceMatrixEntry >*
      mutable_distance_matrix();
  private:
  const ::operations_research::lattle::DistanceMatrixEntry& _internal_distance_matrix(int index) const;
  ::operations_research::lattle::DistanceMatrixEntry* _internal_add_distance_matrix();
  public:
  const ::operations_research::lattle::DistanceMatrixEntry& distance_matrix(int index) const;
  ::operations_research::lattle::DistanceMatrixEntry* add_distance_matrix();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::DistanceMatrixEntry >&
      distance_matrix() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string currency_code = 7;
  void clear_currency_code();
  const std::string& currency_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_currency_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_currency_code();
  PROTOBUF_NODISCARD std::string* release_currency_code();
  void set_allocated_currency_code(std::string* currency_code);
  private:
  const std::string& _internal_currency_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_currency_code(const std::string& value);
  std::string* _internal_mutable_currency_code();
  public:

  // .operations_research.lattle.PricingStrategy pricing = 6;
  bool has_pricing() const;
  private:
  bool _internal_has_pricing() const;
  public:
  void clear_pricing();
  const ::operations_research::lattle::PricingStrategy& pricing() const;
  PROTOBUF_NODISCARD ::operations_research::lattle::PricingStrategy* release_pricing();
  ::operations_research::lattle::PricingStrategy* mutable_pricing();
  void set_allocated_pricing(::operations_research::lattle::PricingStrategy* pricing);
  private:
  const ::operations_research::lattle::PricingStrategy& _internal_pricing() const;
  ::operations_research::lattle::PricingStrategy* _internal_mutable_pricing();
  public:
  void unsafe_arena_set_allocated_pricing(
      ::operations_research::lattle::PricingStrategy* pricing);
  ::operations_research::lattle::PricingStrategy* unsafe_arena_release_pricing();

  // .google.protobuf.Duration time_step = 8;
  bool has_time_step() const;
  private:
  bool _internal_has_time_step() const;
  public:
  void clear_time_step();
  const ::PROTOBUF_NAMESPACE_ID::Duration& time_step() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_time_step();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_time_step();
  void set_allocated_time_step(::PROTOBUF_NAMESPACE_ID::Duration* time_step);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_time_step() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_time_step();
  public:
  void unsafe_arena_set_allocated_time_step(
      ::PROTOBUF_NAMESPACE_ID::Duration* time_step);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_time_step();

  // @@protoc_insertion_point(class_scope:operations_research.lattle.LogisticsNetwork)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LogisticsNetwork_LinesEntry_DoNotUse,
        std::string, ::operations_research::lattle::Line,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> lines_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LogisticsNetwork_VehiclesEntry_DoNotUse,
        std::string, ::operations_research::lattle::Vehicle,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> vehicles_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LogisticsNetwork_HubsEntry_DoNotUse,
        std::string, ::operations_research::lattle::Hub,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> hubs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension > dimensions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::DistanceMatrixEntry > distance_matrix_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currency_code_;
    ::operations_research::lattle::PricingStrategy* pricing_;
    ::PROTOBUF_NAMESPACE_ID::Duration* time_step_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class Line_NextRotationsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Line_NextRotationsEntry_DoNotUse, 
    std::string, ::operations_research::lattle::LineRotation,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Line_NextRotationsEntry_DoNotUse, 
    std::string, ::operations_research::lattle::LineRotation,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Line_NextRotationsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Line_NextRotationsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Line_NextRotationsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Line_NextRotationsEntry_DoNotUse& other);
  static const Line_NextRotationsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Line_NextRotationsEntry_DoNotUse*>(&_Line_NextRotationsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "operations_research.lattle.Line.NextRotationsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lattle_2eproto;
};

// -------------------------------------------------------------------

class Line final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.Line) */ {
 public:
  inline Line() : Line(nullptr) {}
  ~Line() override;
  explicit PROTOBUF_CONSTEXPR Line(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Line(const Line& from);
  Line(Line&& from) noexcept
    : Line() {
    *this = ::std::move(from);
  }

  inline Line& operator=(const Line& from) {
    CopyFrom(from);
    return *this;
  }
  inline Line& operator=(Line&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Line& default_instance() {
    return *internal_default_instance();
  }
  static inline const Line* internal_default_instance() {
    return reinterpret_cast<const Line*>(
               &_Line_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Line& a, Line& b) {
    a.Swap(&b);
  }
  inline void Swap(Line* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Line* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Line* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Line>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Line& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Line& from) {
    Line::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Line* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.Line";
  }
  protected:
  explicit Line(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kHubIdsFieldNumber = 1,
    kNextRotationsFieldNumber = 2,
  };
  // repeated string hub_ids = 1;
  int hub_ids_size() const;
  private:
  int _internal_hub_ids_size() const;
  public:
  void clear_hub_ids();
  const std::string& hub_ids(int index) const;
  std::string* mutable_hub_ids(int index);
  void set_hub_ids(int index, const std::string& value);
  void set_hub_ids(int index, std::string&& value);
  void set_hub_ids(int index, const char* value);
  void set_hub_ids(int index, const char* value, size_t size);
  std::string* add_hub_ids();
  void add_hub_ids(const std::string& value);
  void add_hub_ids(std::string&& value);
  void add_hub_ids(const char* value);
  void add_hub_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hub_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hub_ids();
  private:
  const std::string& _internal_hub_ids(int index) const;
  std::string* _internal_add_hub_ids();
  public:

  // map<string, .operations_research.lattle.LineRotation> next_rotations = 2;
  int next_rotations_size() const;
  private:
  int _internal_next_rotations_size() const;
  public:
  void clear_next_rotations();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::LineRotation >&
      _internal_next_rotations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::LineRotation >*
      _internal_mutable_next_rotations();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::LineRotation >&
      next_rotations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::LineRotation >*
      mutable_next_rotations();

  // @@protoc_insertion_point(class_scope:operations_research.lattle.Line)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hub_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Line_NextRotationsEntry_DoNotUse,
        std::string, ::operations_research::lattle::LineRotation,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> next_rotations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class GeneratedLineAndRotation_ArrivalTimesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GeneratedLineAndRotation_ArrivalTimesEntry_DoNotUse, 
    std::string, ::google::type::DateTime,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GeneratedLineAndRotation_ArrivalTimesEntry_DoNotUse, 
    std::string, ::google::type::DateTime,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  GeneratedLineAndRotation_ArrivalTimesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR GeneratedLineAndRotation_ArrivalTimesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GeneratedLineAndRotation_ArrivalTimesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GeneratedLineAndRotation_ArrivalTimesEntry_DoNotUse& other);
  static const GeneratedLineAndRotation_ArrivalTimesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GeneratedLineAndRotation_ArrivalTimesEntry_DoNotUse*>(&_GeneratedLineAndRotation_ArrivalTimesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "operations_research.lattle.GeneratedLineAndRotation.ArrivalTimesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lattle_2eproto;
};

// -------------------------------------------------------------------

class GeneratedLineAndRotation_DepartureTimesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GeneratedLineAndRotation_DepartureTimesEntry_DoNotUse, 
    std::string, ::google::type::DateTime,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GeneratedLineAndRotation_DepartureTimesEntry_DoNotUse, 
    std::string, ::google::type::DateTime,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  GeneratedLineAndRotation_DepartureTimesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR GeneratedLineAndRotation_DepartureTimesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GeneratedLineAndRotation_DepartureTimesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GeneratedLineAndRotation_DepartureTimesEntry_DoNotUse& other);
  static const GeneratedLineAndRotation_DepartureTimesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GeneratedLineAndRotation_DepartureTimesEntry_DoNotUse*>(&_GeneratedLineAndRotation_DepartureTimesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "operations_research.lattle.GeneratedLineAndRotation.DepartureTimesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lattle_2eproto;
};

// -------------------------------------------------------------------

class GeneratedLineAndRotation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.GeneratedLineAndRotation) */ {
 public:
  inline GeneratedLineAndRotation() : GeneratedLineAndRotation(nullptr) {}
  ~GeneratedLineAndRotation() override;
  explicit PROTOBUF_CONSTEXPR GeneratedLineAndRotation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GeneratedLineAndRotation(const GeneratedLineAndRotation& from);
  GeneratedLineAndRotation(GeneratedLineAndRotation&& from) noexcept
    : GeneratedLineAndRotation() {
    *this = ::std::move(from);
  }

  inline GeneratedLineAndRotation& operator=(const GeneratedLineAndRotation& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeneratedLineAndRotation& operator=(GeneratedLineAndRotation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeneratedLineAndRotation& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeneratedLineAndRotation* internal_default_instance() {
    return reinterpret_cast<const GeneratedLineAndRotation*>(
               &_GeneratedLineAndRotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GeneratedLineAndRotation& a, GeneratedLineAndRotation& b) {
    a.Swap(&b);
  }
  inline void Swap(GeneratedLineAndRotation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeneratedLineAndRotation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeneratedLineAndRotation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GeneratedLineAndRotation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GeneratedLineAndRotation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GeneratedLineAndRotation& from) {
    GeneratedLineAndRotation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeneratedLineAndRotation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.GeneratedLineAndRotation";
  }
  protected:
  explicit GeneratedLineAndRotation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kArrivalTimesFieldNumber = 1,
    kDepartureTimesFieldNumber = 2,
  };
  // map<string, .google.type.DateTime> arrival_times = 1;
  int arrival_times_size() const;
  private:
  int _internal_arrival_times_size() const;
  public:
  void clear_arrival_times();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::type::DateTime >&
      _internal_arrival_times() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::type::DateTime >*
      _internal_mutable_arrival_times();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::type::DateTime >&
      arrival_times() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::type::DateTime >*
      mutable_arrival_times();

  // map<string, .google.type.DateTime> departure_times = 2;
  int departure_times_size() const;
  private:
  int _internal_departure_times_size() const;
  public:
  void clear_departure_times();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::type::DateTime >&
      _internal_departure_times() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::type::DateTime >*
      _internal_mutable_departure_times();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::type::DateTime >&
      departure_times() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::type::DateTime >*
      mutable_departure_times();

  // @@protoc_insertion_point(class_scope:operations_research.lattle.GeneratedLineAndRotation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GeneratedLineAndRotation_ArrivalTimesEntry_DoNotUse,
        std::string, ::google::type::DateTime,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> arrival_times_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GeneratedLineAndRotation_DepartureTimesEntry_DoNotUse,
        std::string, ::google::type::DateTime,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> departure_times_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class LineRotation_ArrivalTimesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LineRotation_ArrivalTimesEntry_DoNotUse, 
    std::string, ::operations_research::lattle::DateTimeRange,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LineRotation_ArrivalTimesEntry_DoNotUse, 
    std::string, ::operations_research::lattle::DateTimeRange,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  LineRotation_ArrivalTimesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR LineRotation_ArrivalTimesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LineRotation_ArrivalTimesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LineRotation_ArrivalTimesEntry_DoNotUse& other);
  static const LineRotation_ArrivalTimesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LineRotation_ArrivalTimesEntry_DoNotUse*>(&_LineRotation_ArrivalTimesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "operations_research.lattle.LineRotation.ArrivalTimesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lattle_2eproto;
};

// -------------------------------------------------------------------

class LineRotation_DepartureTimesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LineRotation_DepartureTimesEntry_DoNotUse, 
    std::string, ::operations_research::lattle::DateTimeRange,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LineRotation_DepartureTimesEntry_DoNotUse, 
    std::string, ::operations_research::lattle::DateTimeRange,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  LineRotation_DepartureTimesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR LineRotation_DepartureTimesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LineRotation_DepartureTimesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LineRotation_DepartureTimesEntry_DoNotUse& other);
  static const LineRotation_DepartureTimesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LineRotation_DepartureTimesEntry_DoNotUse*>(&_LineRotation_DepartureTimesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "operations_research.lattle.LineRotation.DepartureTimesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lattle_2eproto;
};

// -------------------------------------------------------------------

class LineRotation_StartingEarlinessTardinessCostsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LineRotation_StartingEarlinessTardinessCostsEntry_DoNotUse, 
    std::string, ::operations_research::lattle::EarlinessTardiness,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LineRotation_StartingEarlinessTardinessCostsEntry_DoNotUse, 
    std::string, ::operations_research::lattle::EarlinessTardiness,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  LineRotation_StartingEarlinessTardinessCostsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR LineRotation_StartingEarlinessTardinessCostsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LineRotation_StartingEarlinessTardinessCostsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LineRotation_StartingEarlinessTardinessCostsEntry_DoNotUse& other);
  static const LineRotation_StartingEarlinessTardinessCostsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LineRotation_StartingEarlinessTardinessCostsEntry_DoNotUse*>(&_LineRotation_StartingEarlinessTardinessCostsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "operations_research.lattle.LineRotation.StartingEarlinessTardinessCostsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lattle_2eproto;
};

// -------------------------------------------------------------------

class LineRotation_ArrivalEarlinessTardinessCostsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LineRotation_ArrivalEarlinessTardinessCostsEntry_DoNotUse, 
    std::string, ::operations_research::lattle::EarlinessTardiness,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LineRotation_ArrivalEarlinessTardinessCostsEntry_DoNotUse, 
    std::string, ::operations_research::lattle::EarlinessTardiness,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  LineRotation_ArrivalEarlinessTardinessCostsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR LineRotation_ArrivalEarlinessTardinessCostsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LineRotation_ArrivalEarlinessTardinessCostsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LineRotation_ArrivalEarlinessTardinessCostsEntry_DoNotUse& other);
  static const LineRotation_ArrivalEarlinessTardinessCostsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LineRotation_ArrivalEarlinessTardinessCostsEntry_DoNotUse*>(&_LineRotation_ArrivalEarlinessTardinessCostsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "operations_research.lattle.LineRotation.ArrivalEarlinessTardinessCostsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lattle_2eproto;
};

// -------------------------------------------------------------------

class LineRotation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.LineRotation) */ {
 public:
  inline LineRotation() : LineRotation(nullptr) {}
  ~LineRotation() override;
  explicit PROTOBUF_CONSTEXPR LineRotation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LineRotation(const LineRotation& from);
  LineRotation(LineRotation&& from) noexcept
    : LineRotation() {
    *this = ::std::move(from);
  }

  inline LineRotation& operator=(const LineRotation& from) {
    CopyFrom(from);
    return *this;
  }
  inline LineRotation& operator=(LineRotation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LineRotation& default_instance() {
    return *internal_default_instance();
  }
  static inline const LineRotation* internal_default_instance() {
    return reinterpret_cast<const LineRotation*>(
               &_LineRotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(LineRotation& a, LineRotation& b) {
    a.Swap(&b);
  }
  inline void Swap(LineRotation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LineRotation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LineRotation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LineRotation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LineRotation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LineRotation& from) {
    LineRotation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LineRotation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.LineRotation";
  }
  protected:
  explicit LineRotation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kArrivalTimesFieldNumber = 1,
    kDepartureTimesFieldNumber = 2,
    kStartingEarlinessTardinessCostsFieldNumber = 3,
    kArrivalEarlinessTardinessCostsFieldNumber = 4,
    kVehiclesFieldNumber = 6,
    kMaximumNumberVehiclesFieldNumber = 5,
    kFixedPriceFieldNumber = 7,
  };
  // map<string, .operations_research.lattle.DateTimeRange> arrival_times = 1;
  int arrival_times_size() const;
  private:
  int _internal_arrival_times_size() const;
  public:
  void clear_arrival_times();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::DateTimeRange >&
      _internal_arrival_times() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::DateTimeRange >*
      _internal_mutable_arrival_times();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::DateTimeRange >&
      arrival_times() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::DateTimeRange >*
      mutable_arrival_times();

  // map<string, .operations_research.lattle.DateTimeRange> departure_times = 2;
  int departure_times_size() const;
  private:
  int _internal_departure_times_size() const;
  public:
  void clear_departure_times();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::DateTimeRange >&
      _internal_departure_times() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::DateTimeRange >*
      _internal_mutable_departure_times();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::DateTimeRange >&
      departure_times() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::DateTimeRange >*
      mutable_departure_times();

  // map<string, .operations_research.lattle.EarlinessTardiness> starting_earliness_tardiness_costs = 3;
  int starting_earliness_tardiness_costs_size() const;
  private:
  int _internal_starting_earliness_tardiness_costs_size() const;
  public:
  void clear_starting_earliness_tardiness_costs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::EarlinessTardiness >&
      _internal_starting_earliness_tardiness_costs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::EarlinessTardiness >*
      _internal_mutable_starting_earliness_tardiness_costs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::EarlinessTardiness >&
      starting_earliness_tardiness_costs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::EarlinessTardiness >*
      mutable_starting_earliness_tardiness_costs();

  // map<string, .operations_research.lattle.EarlinessTardiness> arrival_earliness_tardiness_costs = 4;
  int arrival_earliness_tardiness_costs_size() const;
  private:
  int _internal_arrival_earliness_tardiness_costs_size() const;
  public:
  void clear_arrival_earliness_tardiness_costs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::EarlinessTardiness >&
      _internal_arrival_earliness_tardiness_costs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::EarlinessTardiness >*
      _internal_mutable_arrival_earliness_tardiness_costs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::EarlinessTardiness >&
      arrival_earliness_tardiness_costs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::EarlinessTardiness >*
      mutable_arrival_earliness_tardiness_costs();

  // repeated string vehicles = 6;
  int vehicles_size() const;
  private:
  int _internal_vehicles_size() const;
  public:
  void clear_vehicles();
  const std::string& vehicles(int index) const;
  std::string* mutable_vehicles(int index);
  void set_vehicles(int index, const std::string& value);
  void set_vehicles(int index, std::string&& value);
  void set_vehicles(int index, const char* value);
  void set_vehicles(int index, const char* value, size_t size);
  std::string* add_vehicles();
  void add_vehicles(const std::string& value);
  void add_vehicles(std::string&& value);
  void add_vehicles(const char* value);
  void add_vehicles(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& vehicles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_vehicles();
  private:
  const std::string& _internal_vehicles(int index) const;
  std::string* _internal_add_vehicles();
  public:

  // optional .operations_research.lattle.IntegerRange maximum_number_vehicles = 5;
  bool has_maximum_number_vehicles() const;
  private:
  bool _internal_has_maximum_number_vehicles() const;
  public:
  void clear_maximum_number_vehicles();
  const ::operations_research::lattle::IntegerRange& maximum_number_vehicles() const;
  PROTOBUF_NODISCARD ::operations_research::lattle::IntegerRange* release_maximum_number_vehicles();
  ::operations_research::lattle::IntegerRange* mutable_maximum_number_vehicles();
  void set_allocated_maximum_number_vehicles(::operations_research::lattle::IntegerRange* maximum_number_vehicles);
  private:
  const ::operations_research::lattle::IntegerRange& _internal_maximum_number_vehicles() const;
  ::operations_research::lattle::IntegerRange* _internal_mutable_maximum_number_vehicles();
  public:
  void unsafe_arena_set_allocated_maximum_number_vehicles(
      ::operations_research::lattle::IntegerRange* maximum_number_vehicles);
  ::operations_research::lattle::IntegerRange* unsafe_arena_release_maximum_number_vehicles();

  // .operations_research.lattle.PricingStrategy fixed_price = 7;
  bool has_fixed_price() const;
  private:
  bool _internal_has_fixed_price() const;
  public:
  void clear_fixed_price();
  const ::operations_research::lattle::PricingStrategy& fixed_price() const;
  PROTOBUF_NODISCARD ::operations_research::lattle::PricingStrategy* release_fixed_price();
  ::operations_research::lattle::PricingStrategy* mutable_fixed_price();
  void set_allocated_fixed_price(::operations_research::lattle::PricingStrategy* fixed_price);
  private:
  const ::operations_research::lattle::PricingStrategy& _internal_fixed_price() const;
  ::operations_research::lattle::PricingStrategy* _internal_mutable_fixed_price();
  public:
  void unsafe_arena_set_allocated_fixed_price(
      ::operations_research::lattle::PricingStrategy* fixed_price);
  ::operations_research::lattle::PricingStrategy* unsafe_arena_release_fixed_price();

  // @@protoc_insertion_point(class_scope:operations_research.lattle.LineRotation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LineRotation_ArrivalTimesEntry_DoNotUse,
        std::string, ::operations_research::lattle::DateTimeRange,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> arrival_times_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LineRotation_DepartureTimesEntry_DoNotUse,
        std::string, ::operations_research::lattle::DateTimeRange,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> departure_times_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LineRotation_StartingEarlinessTardinessCostsEntry_DoNotUse,
        std::string, ::operations_research::lattle::EarlinessTardiness,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> starting_earliness_tardiness_costs_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LineRotation_ArrivalEarlinessTardinessCostsEntry_DoNotUse,
        std::string, ::operations_research::lattle::EarlinessTardiness,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> arrival_earliness_tardiness_costs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> vehicles_;
    ::operations_research::lattle::IntegerRange* maximum_number_vehicles_;
    ::operations_research::lattle::PricingStrategy* fixed_price_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class EarlinessTardiness final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.EarlinessTardiness) */ {
 public:
  inline EarlinessTardiness() : EarlinessTardiness(nullptr) {}
  ~EarlinessTardiness() override;
  explicit PROTOBUF_CONSTEXPR EarlinessTardiness(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EarlinessTardiness(const EarlinessTardiness& from);
  EarlinessTardiness(EarlinessTardiness&& from) noexcept
    : EarlinessTardiness() {
    *this = ::std::move(from);
  }

  inline EarlinessTardiness& operator=(const EarlinessTardiness& from) {
    CopyFrom(from);
    return *this;
  }
  inline EarlinessTardiness& operator=(EarlinessTardiness&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EarlinessTardiness& default_instance() {
    return *internal_default_instance();
  }
  static inline const EarlinessTardiness* internal_default_instance() {
    return reinterpret_cast<const EarlinessTardiness*>(
               &_EarlinessTardiness_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(EarlinessTardiness& a, EarlinessTardiness& b) {
    a.Swap(&b);
  }
  inline void Swap(EarlinessTardiness* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EarlinessTardiness* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EarlinessTardiness* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EarlinessTardiness>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EarlinessTardiness& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EarlinessTardiness& from) {
    EarlinessTardiness::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EarlinessTardiness* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.EarlinessTardiness";
  }
  protected:
  explicit EarlinessTardiness(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaximumEarlinessFieldNumber = 1,
    kMaximumTardinessFieldNumber = 2,
    kEarlinessCostFieldNumber = 3,
    kTardinessCostFieldNumber = 4,
  };
  // optional .google.protobuf.Duration maximum_earliness = 1;
  bool has_maximum_earliness() const;
  private:
  bool _internal_has_maximum_earliness() const;
  public:
  void clear_maximum_earliness();
  const ::PROTOBUF_NAMESPACE_ID::Duration& maximum_earliness() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_maximum_earliness();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_maximum_earliness();
  void set_allocated_maximum_earliness(::PROTOBUF_NAMESPACE_ID::Duration* maximum_earliness);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_maximum_earliness() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_maximum_earliness();
  public:
  void unsafe_arena_set_allocated_maximum_earliness(
      ::PROTOBUF_NAMESPACE_ID::Duration* maximum_earliness);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_maximum_earliness();

  // optional .google.protobuf.Duration maximum_tardiness = 2;
  bool has_maximum_tardiness() const;
  private:
  bool _internal_has_maximum_tardiness() const;
  public:
  void clear_maximum_tardiness();
  const ::PROTOBUF_NAMESPACE_ID::Duration& maximum_tardiness() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_maximum_tardiness();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_maximum_tardiness();
  void set_allocated_maximum_tardiness(::PROTOBUF_NAMESPACE_ID::Duration* maximum_tardiness);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_maximum_tardiness() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_maximum_tardiness();
  public:
  void unsafe_arena_set_allocated_maximum_tardiness(
      ::PROTOBUF_NAMESPACE_ID::Duration* maximum_tardiness);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_maximum_tardiness();

  // optional .operations_research.lattle.Function1D earliness_cost = 3;
  bool has_earliness_cost() const;
  private:
  bool _internal_has_earliness_cost() const;
  public:
  void clear_earliness_cost();
  const ::operations_research::lattle::Function1D& earliness_cost() const;
  PROTOBUF_NODISCARD ::operations_research::lattle::Function1D* release_earliness_cost();
  ::operations_research::lattle::Function1D* mutable_earliness_cost();
  void set_allocated_earliness_cost(::operations_research::lattle::Function1D* earliness_cost);
  private:
  const ::operations_research::lattle::Function1D& _internal_earliness_cost() const;
  ::operations_research::lattle::Function1D* _internal_mutable_earliness_cost();
  public:
  void unsafe_arena_set_allocated_earliness_cost(
      ::operations_research::lattle::Function1D* earliness_cost);
  ::operations_research::lattle::Function1D* unsafe_arena_release_earliness_cost();

  // optional .operations_research.lattle.Function1D tardiness_cost = 4;
  bool has_tardiness_cost() const;
  private:
  bool _internal_has_tardiness_cost() const;
  public:
  void clear_tardiness_cost();
  const ::operations_research::lattle::Function1D& tardiness_cost() const;
  PROTOBUF_NODISCARD ::operations_research::lattle::Function1D* release_tardiness_cost();
  ::operations_research::lattle::Function1D* mutable_tardiness_cost();
  void set_allocated_tardiness_cost(::operations_research::lattle::Function1D* tardiness_cost);
  private:
  const ::operations_research::lattle::Function1D& _internal_tardiness_cost() const;
  ::operations_research::lattle::Function1D* _internal_mutable_tardiness_cost();
  public:
  void unsafe_arena_set_allocated_tardiness_cost(
      ::operations_research::lattle::Function1D* tardiness_cost);
  ::operations_research::lattle::Function1D* unsafe_arena_release_tardiness_cost();

  // @@protoc_insertion_point(class_scope:operations_research.lattle.EarlinessTardiness)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::Duration* maximum_earliness_;
    ::PROTOBUF_NAMESPACE_ID::Duration* maximum_tardiness_;
    ::operations_research::lattle::Function1D* earliness_cost_;
    ::operations_research::lattle::Function1D* tardiness_cost_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class Vehicle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.Vehicle) */ {
 public:
  inline Vehicle() : Vehicle(nullptr) {}
  ~Vehicle() override;
  explicit PROTOBUF_CONSTEXPR Vehicle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vehicle(const Vehicle& from);
  Vehicle(Vehicle&& from) noexcept
    : Vehicle() {
    *this = ::std::move(from);
  }

  inline Vehicle& operator=(const Vehicle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vehicle& operator=(Vehicle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vehicle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vehicle* internal_default_instance() {
    return reinterpret_cast<const Vehicle*>(
               &_Vehicle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Vehicle& a, Vehicle& b) {
    a.Swap(&b);
  }
  inline void Swap(Vehicle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vehicle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vehicle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vehicle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vehicle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vehicle& from) {
    Vehicle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.Vehicle";
  }
  protected:
  explicit Vehicle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapacitiesFieldNumber = 3,
    kCurrentPositionHubFieldNumber = 1,
    kCostFieldNumber = 4,
    kPricingFieldNumber = 6,
    kRefrigeratedFieldNumber = 2,
    kAllowedForGeneratedRoutesFieldNumber = 7,
  };
  // repeated .operations_research.lattle.ValueDimension capacities = 3;
  int capacities_size() const;
  private:
  int _internal_capacities_size() const;
  public:
  void clear_capacities();
  ::operations_research::lattle::ValueDimension* mutable_capacities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >*
      mutable_capacities();
  private:
  const ::operations_research::lattle::ValueDimension& _internal_capacities(int index) const;
  ::operations_research::lattle::ValueDimension* _internal_add_capacities();
  public:
  const ::operations_research::lattle::ValueDimension& capacities(int index) const;
  ::operations_research::lattle::ValueDimension* add_capacities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >&
      capacities() const;

  // optional string current_position_hub = 1;
  bool has_current_position_hub() const;
  private:
  bool _internal_has_current_position_hub() const;
  public:
  void clear_current_position_hub();
  const std::string& current_position_hub() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_current_position_hub(ArgT0&& arg0, ArgT... args);
  std::string* mutable_current_position_hub();
  PROTOBUF_NODISCARD std::string* release_current_position_hub();
  void set_allocated_current_position_hub(std::string* current_position_hub);
  private:
  const std::string& _internal_current_position_hub() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_position_hub(const std::string& value);
  std::string* _internal_mutable_current_position_hub();
  public:

  // .operations_research.lattle.PricingStrategy cost = 4;
  bool has_cost() const;
  private:
  bool _internal_has_cost() const;
  public:
  void clear_cost();
  const ::operations_research::lattle::PricingStrategy& cost() const;
  PROTOBUF_NODISCARD ::operations_research::lattle::PricingStrategy* release_cost();
  ::operations_research::lattle::PricingStrategy* mutable_cost();
  void set_allocated_cost(::operations_research::lattle::PricingStrategy* cost);
  private:
  const ::operations_research::lattle::PricingStrategy& _internal_cost() const;
  ::operations_research::lattle::PricingStrategy* _internal_mutable_cost();
  public:
  void unsafe_arena_set_allocated_cost(
      ::operations_research::lattle::PricingStrategy* cost);
  ::operations_research::lattle::PricingStrategy* unsafe_arena_release_cost();

  // .operations_research.lattle.PricingStrategy pricing = 6;
  bool has_pricing() const;
  private:
  bool _internal_has_pricing() const;
  public:
  void clear_pricing();
  const ::operations_research::lattle::PricingStrategy& pricing() const;
  PROTOBUF_NODISCARD ::operations_research::lattle::PricingStrategy* release_pricing();
  ::operations_research::lattle::PricingStrategy* mutable_pricing();
  void set_allocated_pricing(::operations_research::lattle::PricingStrategy* pricing);
  private:
  const ::operations_research::lattle::PricingStrategy& _internal_pricing() const;
  ::operations_research::lattle::PricingStrategy* _internal_mutable_pricing();
  public:
  void unsafe_arena_set_allocated_pricing(
      ::operations_research::lattle::PricingStrategy* pricing);
  ::operations_research::lattle::PricingStrategy* unsafe_arena_release_pricing();

  // bool refrigerated = 2;
  void clear_refrigerated();
  bool refrigerated() const;
  void set_refrigerated(bool value);
  private:
  bool _internal_refrigerated() const;
  void _internal_set_refrigerated(bool value);
  public:

  // bool allowed_for_generated_routes = 7;
  void clear_allowed_for_generated_routes();
  bool allowed_for_generated_routes() const;
  void set_allowed_for_generated_routes(bool value);
  private:
  bool _internal_allowed_for_generated_routes() const;
  void _internal_set_allowed_for_generated_routes(bool value);
  public:

  // @@protoc_insertion_point(class_scope:operations_research.lattle.Vehicle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension > capacities_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_position_hub_;
    ::operations_research::lattle::PricingStrategy* cost_;
    ::operations_research::lattle::PricingStrategy* pricing_;
    bool refrigerated_;
    bool allowed_for_generated_routes_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class Hub final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.Hub) */ {
 public:
  inline Hub() : Hub(nullptr) {}
  ~Hub() override;
  explicit PROTOBUF_CONSTEXPR Hub(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Hub(const Hub& from);
  Hub(Hub&& from) noexcept
    : Hub() {
    *this = ::std::move(from);
  }

  inline Hub& operator=(const Hub& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hub& operator=(Hub&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Hub& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hub* internal_default_instance() {
    return reinterpret_cast<const Hub*>(
               &_Hub_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Hub& a, Hub& b) {
    a.Swap(&b);
  }
  inline void Swap(Hub* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hub* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hub* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hub>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Hub& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Hub& from) {
    Hub::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Hub* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.Hub";
  }
  protected:
  explicit Hub(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpeningTimesFieldNumber = 2,
    kPositionFieldNumber = 1,
    kCrossDockingCapacityFieldNumber = 3,
    kCrossDockingTimeFieldNumber = 4,
  };
  // repeated .operations_research.lattle.DateTimeRange opening_times = 2;
  int opening_times_size() const;
  private:
  int _internal_opening_times_size() const;
  public:
  void clear_opening_times();
  ::operations_research::lattle::DateTimeRange* mutable_opening_times(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::DateTimeRange >*
      mutable_opening_times();
  private:
  const ::operations_research::lattle::DateTimeRange& _internal_opening_times(int index) const;
  ::operations_research::lattle::DateTimeRange* _internal_add_opening_times();
  public:
  const ::operations_research::lattle::DateTimeRange& opening_times(int index) const;
  ::operations_research::lattle::DateTimeRange* add_opening_times();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::DateTimeRange >&
      opening_times() const;

  // .google.type.LatLng position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::google::type::LatLng& position() const;
  PROTOBUF_NODISCARD ::google::type::LatLng* release_position();
  ::google::type::LatLng* mutable_position();
  void set_allocated_position(::google::type::LatLng* position);
  private:
  const ::google::type::LatLng& _internal_position() const;
  ::google::type::LatLng* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::google::type::LatLng* position);
  ::google::type::LatLng* unsafe_arena_release_position();

  // .operations_research.lattle.CrossDockingCapacity cross_docking_capacity = 3;
  bool has_cross_docking_capacity() const;
  private:
  bool _internal_has_cross_docking_capacity() const;
  public:
  void clear_cross_docking_capacity();
  const ::operations_research::lattle::CrossDockingCapacity& cross_docking_capacity() const;
  PROTOBUF_NODISCARD ::operations_research::lattle::CrossDockingCapacity* release_cross_docking_capacity();
  ::operations_research::lattle::CrossDockingCapacity* mutable_cross_docking_capacity();
  void set_allocated_cross_docking_capacity(::operations_research::lattle::CrossDockingCapacity* cross_docking_capacity);
  private:
  const ::operations_research::lattle::CrossDockingCapacity& _internal_cross_docking_capacity() const;
  ::operations_research::lattle::CrossDockingCapacity* _internal_mutable_cross_docking_capacity();
  public:
  void unsafe_arena_set_allocated_cross_docking_capacity(
      ::operations_research::lattle::CrossDockingCapacity* cross_docking_capacity);
  ::operations_research::lattle::CrossDockingCapacity* unsafe_arena_release_cross_docking_capacity();

  // .operations_research.lattle.CrossDockingTime cross_docking_time = 4;
  bool has_cross_docking_time() const;
  private:
  bool _internal_has_cross_docking_time() const;
  public:
  void clear_cross_docking_time();
  const ::operations_research::lattle::CrossDockingTime& cross_docking_time() const;
  PROTOBUF_NODISCARD ::operations_research::lattle::CrossDockingTime* release_cross_docking_time();
  ::operations_research::lattle::CrossDockingTime* mutable_cross_docking_time();
  void set_allocated_cross_docking_time(::operations_research::lattle::CrossDockingTime* cross_docking_time);
  private:
  const ::operations_research::lattle::CrossDockingTime& _internal_cross_docking_time() const;
  ::operations_research::lattle::CrossDockingTime* _internal_mutable_cross_docking_time();
  public:
  void unsafe_arena_set_allocated_cross_docking_time(
      ::operations_research::lattle::CrossDockingTime* cross_docking_time);
  ::operations_research::lattle::CrossDockingTime* unsafe_arena_release_cross_docking_time();

  // @@protoc_insertion_point(class_scope:operations_research.lattle.Hub)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::DateTimeRange > opening_times_;
    ::google::type::LatLng* position_;
    ::operations_research::lattle::CrossDockingCapacity* cross_docking_capacity_;
    ::operations_research::lattle::CrossDockingTime* cross_docking_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class CrossDockingCapacity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.CrossDockingCapacity) */ {
 public:
  inline CrossDockingCapacity() : CrossDockingCapacity(nullptr) {}
  ~CrossDockingCapacity() override;
  explicit PROTOBUF_CONSTEXPR CrossDockingCapacity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CrossDockingCapacity(const CrossDockingCapacity& from);
  CrossDockingCapacity(CrossDockingCapacity&& from) noexcept
    : CrossDockingCapacity() {
    *this = ::std::move(from);
  }

  inline CrossDockingCapacity& operator=(const CrossDockingCapacity& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrossDockingCapacity& operator=(CrossDockingCapacity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CrossDockingCapacity& default_instance() {
    return *internal_default_instance();
  }
  static inline const CrossDockingCapacity* internal_default_instance() {
    return reinterpret_cast<const CrossDockingCapacity*>(
               &_CrossDockingCapacity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CrossDockingCapacity& a, CrossDockingCapacity& b) {
    a.Swap(&b);
  }
  inline void Swap(CrossDockingCapacity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CrossDockingCapacity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CrossDockingCapacity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CrossDockingCapacity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CrossDockingCapacity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CrossDockingCapacity& from) {
    CrossDockingCapacity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrossDockingCapacity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.CrossDockingCapacity";
  }
  protected:
  explicit CrossDockingCapacity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapacityPerHourFieldNumber = 1,
  };
  // repeated .operations_research.lattle.ValueDimension capacity_per_hour = 1;
  int capacity_per_hour_size() const;
  private:
  int _internal_capacity_per_hour_size() const;
  public:
  void clear_capacity_per_hour();
  ::operations_research::lattle::ValueDimension* mutable_capacity_per_hour(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >*
      mutable_capacity_per_hour();
  private:
  const ::operations_research::lattle::ValueDimension& _internal_capacity_per_hour(int index) const;
  ::operations_research::lattle::ValueDimension* _internal_add_capacity_per_hour();
  public:
  const ::operations_research::lattle::ValueDimension& capacity_per_hour(int index) const;
  ::operations_research::lattle::ValueDimension* add_capacity_per_hour();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >&
      capacity_per_hour() const;

  // @@protoc_insertion_point(class_scope:operations_research.lattle.CrossDockingCapacity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension > capacity_per_hour_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class CrossDockingTime final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.CrossDockingTime) */ {
 public:
  inline CrossDockingTime() : CrossDockingTime(nullptr) {}
  ~CrossDockingTime() override;
  explicit PROTOBUF_CONSTEXPR CrossDockingTime(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CrossDockingTime(const CrossDockingTime& from);
  CrossDockingTime(CrossDockingTime&& from) noexcept
    : CrossDockingTime() {
    *this = ::std::move(from);
  }

  inline CrossDockingTime& operator=(const CrossDockingTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrossDockingTime& operator=(CrossDockingTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CrossDockingTime& default_instance() {
    return *internal_default_instance();
  }
  static inline const CrossDockingTime* internal_default_instance() {
    return reinterpret_cast<const CrossDockingTime*>(
               &_CrossDockingTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CrossDockingTime& a, CrossDockingTime& b) {
    a.Swap(&b);
  }
  inline void Swap(CrossDockingTime* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CrossDockingTime* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CrossDockingTime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CrossDockingTime>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CrossDockingTime& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CrossDockingTime& from) {
    CrossDockingTime::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrossDockingTime* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.CrossDockingTime";
  }
  protected:
  explicit CrossDockingTime(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeConstantFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // .google.protobuf.Duration time_constant = 1;
  bool has_time_constant() const;
  private:
  bool _internal_has_time_constant() const;
  public:
  void clear_time_constant();
  const ::PROTOBUF_NAMESPACE_ID::Duration& time_constant() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_time_constant();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_time_constant();
  void set_allocated_time_constant(::PROTOBUF_NAMESPACE_ID::Duration* time_constant);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_time_constant() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_time_constant();
  public:
  void unsafe_arena_set_allocated_time_constant(
      ::PROTOBUF_NAMESPACE_ID::Duration* time_constant);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_time_constant();

  // .operations_research.lattle.SeparableNDFunction time = 2;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::operations_research::lattle::SeparableNDFunction& time() const;
  PROTOBUF_NODISCARD ::operations_research::lattle::SeparableNDFunction* release_time();
  ::operations_research::lattle::SeparableNDFunction* mutable_time();
  void set_allocated_time(::operations_research::lattle::SeparableNDFunction* time);
  private:
  const ::operations_research::lattle::SeparableNDFunction& _internal_time() const;
  ::operations_research::lattle::SeparableNDFunction* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::operations_research::lattle::SeparableNDFunction* time);
  ::operations_research::lattle::SeparableNDFunction* unsafe_arena_release_time();

  // @@protoc_insertion_point(class_scope:operations_research.lattle.CrossDockingTime)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Duration* time_constant_;
    ::operations_research::lattle::SeparableNDFunction* time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class DistanceMatrixEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.DistanceMatrixEntry) */ {
 public:
  inline DistanceMatrixEntry() : DistanceMatrixEntry(nullptr) {}
  ~DistanceMatrixEntry() override;
  explicit PROTOBUF_CONSTEXPR DistanceMatrixEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DistanceMatrixEntry(const DistanceMatrixEntry& from);
  DistanceMatrixEntry(DistanceMatrixEntry&& from) noexcept
    : DistanceMatrixEntry() {
    *this = ::std::move(from);
  }

  inline DistanceMatrixEntry& operator=(const DistanceMatrixEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline DistanceMatrixEntry& operator=(DistanceMatrixEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DistanceMatrixEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const DistanceMatrixEntry* internal_default_instance() {
    return reinterpret_cast<const DistanceMatrixEntry*>(
               &_DistanceMatrixEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(DistanceMatrixEntry& a, DistanceMatrixEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(DistanceMatrixEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DistanceMatrixEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DistanceMatrixEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DistanceMatrixEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DistanceMatrixEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DistanceMatrixEntry& from) {
    DistanceMatrixEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DistanceMatrixEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.DistanceMatrixEntry";
  }
  protected:
  explicit DistanceMatrixEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeightsFieldNumber = 3,
    kSourceHubFieldNumber = 1,
    kDestinationHubFieldNumber = 2,
  };
  // repeated .operations_research.lattle.ValueDimension weights = 3;
  int weights_size() const;
  private:
  int _internal_weights_size() const;
  public:
  void clear_weights();
  ::operations_research::lattle::ValueDimension* mutable_weights(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >*
      mutable_weights();
  private:
  const ::operations_research::lattle::ValueDimension& _internal_weights(int index) const;
  ::operations_research::lattle::ValueDimension* _internal_add_weights();
  public:
  const ::operations_research::lattle::ValueDimension& weights(int index) const;
  ::operations_research::lattle::ValueDimension* add_weights();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >&
      weights() const;

  // string source_hub = 1;
  void clear_source_hub();
  const std::string& source_hub() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_hub(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_hub();
  PROTOBUF_NODISCARD std::string* release_source_hub();
  void set_allocated_source_hub(std::string* source_hub);
  private:
  const std::string& _internal_source_hub() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_hub(const std::string& value);
  std::string* _internal_mutable_source_hub();
  public:

  // string destination_hub = 2;
  void clear_destination_hub();
  const std::string& destination_hub() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination_hub(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination_hub();
  PROTOBUF_NODISCARD std::string* release_destination_hub();
  void set_allocated_destination_hub(std::string* destination_hub);
  private:
  const std::string& _internal_destination_hub() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination_hub(const std::string& value);
  std::string* _internal_mutable_destination_hub();
  public:

  // @@protoc_insertion_point(class_scope:operations_research.lattle.DistanceMatrixEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension > weights_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_hub_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_hub_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class Parcel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.Parcel) */ {
 public:
  inline Parcel() : Parcel(nullptr) {}
  ~Parcel() override;
  explicit PROTOBUF_CONSTEXPR Parcel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Parcel(const Parcel& from);
  Parcel(Parcel&& from) noexcept
    : Parcel() {
    *this = ::std::move(from);
  }

  inline Parcel& operator=(const Parcel& from) {
    CopyFrom(from);
    return *this;
  }
  inline Parcel& operator=(Parcel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Parcel& default_instance() {
    return *internal_default_instance();
  }
  static inline const Parcel* internal_default_instance() {
    return reinterpret_cast<const Parcel*>(
               &_Parcel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(Parcel& a, Parcel& b) {
    a.Swap(&b);
  }
  inline void Swap(Parcel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Parcel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Parcel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Parcel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Parcel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Parcel& from) {
    Parcel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Parcel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.Parcel";
  }
  protected:
  explicit Parcel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 9,
    kParcelFieldNumber = 1,
    kSourceHubFieldNumber = 2,
    kDestinationHubFieldNumber = 3,
    kDepartureTimeFieldNumber = 4,
    kArrivalTimeFieldNumber = 5,
    kArrivalEarlinessTardinessCostFieldNumber = 6,
    kRevenueFieldNumber = 8,
    kMustBeRefrigeratedFieldNumber = 7,
  };
  // repeated .operations_research.lattle.ValueDimension size = 9;
  int size_size() const;
  private:
  int _internal_size_size() const;
  public:
  void clear_size();
  ::operations_research::lattle::ValueDimension* mutable_size(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >*
      mutable_size();
  private:
  const ::operations_research::lattle::ValueDimension& _internal_size(int index) const;
  ::operations_research::lattle::ValueDimension* _internal_add_size();
  public:
  const ::operations_research::lattle::ValueDimension& size(int index) const;
  ::operations_research::lattle::ValueDimension* add_size();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >&
      size() const;

  // string parcel = 1;
  void clear_parcel();
  const std::string& parcel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parcel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parcel();
  PROTOBUF_NODISCARD std::string* release_parcel();
  void set_allocated_parcel(std::string* parcel);
  private:
  const std::string& _internal_parcel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parcel(const std::string& value);
  std::string* _internal_mutable_parcel();
  public:

  // string source_hub = 2;
  void clear_source_hub();
  const std::string& source_hub() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_hub(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_hub();
  PROTOBUF_NODISCARD std::string* release_source_hub();
  void set_allocated_source_hub(std::string* source_hub);
  private:
  const std::string& _internal_source_hub() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_hub(const std::string& value);
  std::string* _internal_mutable_source_hub();
  public:

  // string destination_hub = 3;
  void clear_destination_hub();
  const std::string& destination_hub() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination_hub(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination_hub();
  PROTOBUF_NODISCARD std::string* release_destination_hub();
  void set_allocated_destination_hub(std::string* destination_hub);
  private:
  const std::string& _internal_destination_hub() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination_hub(const std::string& value);
  std::string* _internal_mutable_destination_hub();
  public:

  // .google.type.DateTime departure_time = 4;
  bool has_departure_time() const;
  private:
  bool _internal_has_departure_time() const;
  public:
  void clear_departure_time();
  const ::google::type::DateTime& departure_time() const;
  PROTOBUF_NODISCARD ::google::type::DateTime* release_departure_time();
  ::google::type::DateTime* mutable_departure_time();
  void set_allocated_departure_time(::google::type::DateTime* departure_time);
  private:
  const ::google::type::DateTime& _internal_departure_time() const;
  ::google::type::DateTime* _internal_mutable_departure_time();
  public:
  void unsafe_arena_set_allocated_departure_time(
      ::google::type::DateTime* departure_time);
  ::google::type::DateTime* unsafe_arena_release_departure_time();

  // .operations_research.lattle.DateTimeRange arrival_time = 5;
  bool has_arrival_time() const;
  private:
  bool _internal_has_arrival_time() const;
  public:
  void clear_arrival_time();
  const ::operations_research::lattle::DateTimeRange& arrival_time() const;
  PROTOBUF_NODISCARD ::operations_research::lattle::DateTimeRange* release_arrival_time();
  ::operations_research::lattle::DateTimeRange* mutable_arrival_time();
  void set_allocated_arrival_time(::operations_research::lattle::DateTimeRange* arrival_time);
  private:
  const ::operations_research::lattle::DateTimeRange& _internal_arrival_time() const;
  ::operations_research::lattle::DateTimeRange* _internal_mutable_arrival_time();
  public:
  void unsafe_arena_set_allocated_arrival_time(
      ::operations_research::lattle::DateTimeRange* arrival_time);
  ::operations_research::lattle::DateTimeRange* unsafe_arena_release_arrival_time();

  // .operations_research.lattle.EarlinessTardiness arrival_earliness_tardiness_cost = 6;
  bool has_arrival_earliness_tardiness_cost() const;
  private:
  bool _internal_has_arrival_earliness_tardiness_cost() const;
  public:
  void clear_arrival_earliness_tardiness_cost();
  const ::operations_research::lattle::EarlinessTardiness& arrival_earliness_tardiness_cost() const;
  PROTOBUF_NODISCARD ::operations_research::lattle::EarlinessTardiness* release_arrival_earliness_tardiness_cost();
  ::operations_research::lattle::EarlinessTardiness* mutable_arrival_earliness_tardiness_cost();
  void set_allocated_arrival_earliness_tardiness_cost(::operations_research::lattle::EarlinessTardiness* arrival_earliness_tardiness_cost);
  private:
  const ::operations_research::lattle::EarlinessTardiness& _internal_arrival_earliness_tardiness_cost() const;
  ::operations_research::lattle::EarlinessTardiness* _internal_mutable_arrival_earliness_tardiness_cost();
  public:
  void unsafe_arena_set_allocated_arrival_earliness_tardiness_cost(
      ::operations_research::lattle::EarlinessTardiness* arrival_earliness_tardiness_cost);
  ::operations_research::lattle::EarlinessTardiness* unsafe_arena_release_arrival_earliness_tardiness_cost();

  // optional double revenue = 8;
  bool has_revenue() const;
  private:
  bool _internal_has_revenue() const;
  public:
  void clear_revenue();
  double revenue() const;
  void set_revenue(double value);
  private:
  double _internal_revenue() const;
  void _internal_set_revenue(double value);
  public:

  // bool must_be_refrigerated = 7;
  void clear_must_be_refrigerated();
  bool must_be_refrigerated() const;
  void set_must_be_refrigerated(bool value);
  private:
  bool _internal_must_be_refrigerated() const;
  void _internal_set_must_be_refrigerated(bool value);
  public:

  // @@protoc_insertion_point(class_scope:operations_research.lattle.Parcel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension > size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parcel_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_hub_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_hub_;
    ::google::type::DateTime* departure_time_;
    ::operations_research::lattle::DateTimeRange* arrival_time_;
    ::operations_research::lattle::EarlinessTardiness* arrival_earliness_tardiness_cost_;
    double revenue_;
    bool must_be_refrigerated_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class ParcelRoute_CostEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ParcelRoute_CostEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ParcelRoute_CostEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  ParcelRoute_CostEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ParcelRoute_CostEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ParcelRoute_CostEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ParcelRoute_CostEntry_DoNotUse& other);
  static const ParcelRoute_CostEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ParcelRoute_CostEntry_DoNotUse*>(&_ParcelRoute_CostEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "operations_research.lattle.ParcelRoute.CostEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lattle_2eproto;
};

// -------------------------------------------------------------------

class ParcelRoute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.ParcelRoute) */ {
 public:
  inline ParcelRoute() : ParcelRoute(nullptr) {}
  ~ParcelRoute() override;
  explicit PROTOBUF_CONSTEXPR ParcelRoute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParcelRoute(const ParcelRoute& from);
  ParcelRoute(ParcelRoute&& from) noexcept
    : ParcelRoute() {
    *this = ::std::move(from);
  }

  inline ParcelRoute& operator=(const ParcelRoute& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParcelRoute& operator=(ParcelRoute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParcelRoute& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParcelRoute* internal_default_instance() {
    return reinterpret_cast<const ParcelRoute*>(
               &_ParcelRoute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ParcelRoute& a, ParcelRoute& b) {
    a.Swap(&b);
  }
  inline void Swap(ParcelRoute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParcelRoute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParcelRoute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParcelRoute>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParcelRoute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParcelRoute& from) {
    ParcelRoute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParcelRoute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.ParcelRoute";
  }
  protected:
  explicit ParcelRoute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPathSegmentsFieldNumber = 2,
    kCostFieldNumber = 7,
    kParcelFieldNumber = 1,
    kDepartureTimeFieldNumber = 3,
    kArrivalTimeFieldNumber = 4,
    kFingerprintFieldNumber = 8,
    kIncurredPenaltiesFromArrivalTimePerMinuteFieldNumber = 5,
    kCostConstantFieldNumber = 6,
  };
  // repeated .operations_research.lattle.AnnotatedPathSegment path_segments = 2;
  int path_segments_size() const;
  private:
  int _internal_path_segments_size() const;
  public:
  void clear_path_segments();
  ::operations_research::lattle::AnnotatedPathSegment* mutable_path_segments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::AnnotatedPathSegment >*
      mutable_path_segments();
  private:
  const ::operations_research::lattle::AnnotatedPathSegment& _internal_path_segments(int index) const;
  ::operations_research::lattle::AnnotatedPathSegment* _internal_add_path_segments();
  public:
  const ::operations_research::lattle::AnnotatedPathSegment& path_segments(int index) const;
  ::operations_research::lattle::AnnotatedPathSegment* add_path_segments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::AnnotatedPathSegment >&
      path_segments() const;

  // map<string, double> cost = 7;
  int cost_size() const;
  private:
  int _internal_cost_size() const;
  public:
  void clear_cost();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_cost() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_cost();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      cost() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_cost();

  // string parcel = 1;
  void clear_parcel();
  const std::string& parcel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parcel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parcel();
  PROTOBUF_NODISCARD std::string* release_parcel();
  void set_allocated_parcel(std::string* parcel);
  private:
  const std::string& _internal_parcel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parcel(const std::string& value);
  std::string* _internal_mutable_parcel();
  public:

  // .google.type.DateTime departure_time = 3;
  bool has_departure_time() const;
  private:
  bool _internal_has_departure_time() const;
  public:
  void clear_departure_time();
  const ::google::type::DateTime& departure_time() const;
  PROTOBUF_NODISCARD ::google::type::DateTime* release_departure_time();
  ::google::type::DateTime* mutable_departure_time();
  void set_allocated_departure_time(::google::type::DateTime* departure_time);
  private:
  const ::google::type::DateTime& _internal_departure_time() const;
  ::google::type::DateTime* _internal_mutable_departure_time();
  public:
  void unsafe_arena_set_allocated_departure_time(
      ::google::type::DateTime* departure_time);
  ::google::type::DateTime* unsafe_arena_release_departure_time();

  // .google.type.DateTime arrival_time = 4;
  bool has_arrival_time() const;
  private:
  bool _internal_has_arrival_time() const;
  public:
  void clear_arrival_time();
  const ::google::type::DateTime& arrival_time() const;
  PROTOBUF_NODISCARD ::google::type::DateTime* release_arrival_time();
  ::google::type::DateTime* mutable_arrival_time();
  void set_allocated_arrival_time(::google::type::DateTime* arrival_time);
  private:
  const ::google::type::DateTime& _internal_arrival_time() const;
  ::google::type::DateTime* _internal_mutable_arrival_time();
  public:
  void unsafe_arena_set_allocated_arrival_time(
      ::google::type::DateTime* arrival_time);
  ::google::type::DateTime* unsafe_arena_release_arrival_time();

  // .storage_util.Int128 fingerprint = 8 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_fingerprint() const;
  private:
  bool _internal_has_fingerprint() const;
  public:
  void clear_fingerprint();
  const ::storage_util::Int128& fingerprint() const;
  PROTOBUF_NODISCARD ::storage_util::Int128* release_fingerprint();
  ::storage_util::Int128* mutable_fingerprint();
  void set_allocated_fingerprint(::storage_util::Int128* fingerprint);
  private:
  const ::storage_util::Int128& _internal_fingerprint() const;
  ::storage_util::Int128* _internal_mutable_fingerprint();
  public:
  void unsafe_arena_set_allocated_fingerprint(
      ::storage_util::Int128* fingerprint);
  ::storage_util::Int128* unsafe_arena_release_fingerprint();

  // double incurred_penalties_from_arrival_time_per_minute = 5;
  void clear_incurred_penalties_from_arrival_time_per_minute();
  double incurred_penalties_from_arrival_time_per_minute() const;
  void set_incurred_penalties_from_arrival_time_per_minute(double value);
  private:
  double _internal_incurred_penalties_from_arrival_time_per_minute() const;
  void _internal_set_incurred_penalties_from_arrival_time_per_minute(double value);
  public:

  // double cost_constant = 6;
  void clear_cost_constant();
  double cost_constant() const;
  void set_cost_constant(double value);
  private:
  double _internal_cost_constant() const;
  void _internal_set_cost_constant(double value);
  public:

  // @@protoc_insertion_point(class_scope:operations_research.lattle.ParcelRoute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::AnnotatedPathSegment > path_segments_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ParcelRoute_CostEntry_DoNotUse,
        std::string, double,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> cost_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parcel_;
    ::google::type::DateTime* departure_time_;
    ::google::type::DateTime* arrival_time_;
    ::storage_util::Int128* fingerprint_;
    double incurred_penalties_from_arrival_time_per_minute_;
    double cost_constant_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class Path final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.Path) */ {
 public:
  inline Path() : Path(nullptr) {}
  ~Path() override;
  explicit PROTOBUF_CONSTEXPR Path(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Path(const Path& from);
  Path(Path&& from) noexcept
    : Path() {
    *this = ::std::move(from);
  }

  inline Path& operator=(const Path& from) {
    CopyFrom(from);
    return *this;
  }
  inline Path& operator=(Path&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Path& default_instance() {
    return *internal_default_instance();
  }
  static inline const Path* internal_default_instance() {
    return reinterpret_cast<const Path*>(
               &_Path_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(Path& a, Path& b) {
    a.Swap(&b);
  }
  inline void Swap(Path* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Path* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Path* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Path>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Path& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Path& from) {
    Path::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Path* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.Path";
  }
  protected:
  explicit Path(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegmentsFieldNumber = 1,
  };
  // repeated .operations_research.lattle.PathSegment segments = 1;
  int segments_size() const;
  private:
  int _internal_segments_size() const;
  public:
  void clear_segments();
  ::operations_research::lattle::PathSegment* mutable_segments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::PathSegment >*
      mutable_segments();
  private:
  const ::operations_research::lattle::PathSegment& _internal_segments(int index) const;
  ::operations_research::lattle::PathSegment* _internal_add_segments();
  public:
  const ::operations_research::lattle::PathSegment& segments(int index) const;
  ::operations_research::lattle::PathSegment* add_segments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::PathSegment >&
      segments() const;

  // @@protoc_insertion_point(class_scope:operations_research.lattle.Path)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::PathSegment > segments_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class IncompletePath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.IncompletePath) */ {
 public:
  inline IncompletePath() : IncompletePath(nullptr) {}
  ~IncompletePath() override;
  explicit PROTOBUF_CONSTEXPR IncompletePath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IncompletePath(const IncompletePath& from);
  IncompletePath(IncompletePath&& from) noexcept
    : IncompletePath() {
    *this = ::std::move(from);
  }

  inline IncompletePath& operator=(const IncompletePath& from) {
    CopyFrom(from);
    return *this;
  }
  inline IncompletePath& operator=(IncompletePath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IncompletePath& default_instance() {
    return *internal_default_instance();
  }
  static inline const IncompletePath* internal_default_instance() {
    return reinterpret_cast<const IncompletePath*>(
               &_IncompletePath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(IncompletePath& a, IncompletePath& b) {
    a.Swap(&b);
  }
  inline void Swap(IncompletePath* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IncompletePath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IncompletePath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IncompletePath>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IncompletePath& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IncompletePath& from) {
    IncompletePath::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IncompletePath* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.IncompletePath";
  }
  protected:
  explicit IncompletePath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegmentsFieldNumber = 1,
  };
  // repeated .operations_research.lattle.PathSegment segments = 1;
  int segments_size() const;
  private:
  int _internal_segments_size() const;
  public:
  void clear_segments();
  ::operations_research::lattle::PathSegment* mutable_segments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::PathSegment >*
      mutable_segments();
  private:
  const ::operations_research::lattle::PathSegment& _internal_segments(int index) const;
  ::operations_research::lattle::PathSegment* _internal_add_segments();
  public:
  const ::operations_research::lattle::PathSegment& segments(int index) const;
  ::operations_research::lattle::PathSegment* add_segments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::PathSegment >&
      segments() const;

  // @@protoc_insertion_point(class_scope:operations_research.lattle.IncompletePath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::PathSegment > segments_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class PathSegment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.PathSegment) */ {
 public:
  inline PathSegment() : PathSegment(nullptr) {}
  ~PathSegment() override;
  explicit PROTOBUF_CONSTEXPR PathSegment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PathSegment(const PathSegment& from);
  PathSegment(PathSegment&& from) noexcept
    : PathSegment() {
    *this = ::std::move(from);
  }

  inline PathSegment& operator=(const PathSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathSegment& operator=(PathSegment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PathSegment& default_instance() {
    return *internal_default_instance();
  }
  static inline const PathSegment* internal_default_instance() {
    return reinterpret_cast<const PathSegment*>(
               &_PathSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(PathSegment& a, PathSegment& b) {
    a.Swap(&b);
  }
  inline void Swap(PathSegment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathSegment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PathSegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PathSegment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PathSegment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PathSegment& from) {
    PathSegment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathSegment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.PathSegment";
  }
  protected:
  explicit PathSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceHubFieldNumber = 1,
    kDestinationHubFieldNumber = 2,
    kLineFieldNumber = 3,
    kLineRotationFieldNumber = 4,
    kVehicleFieldNumber = 5,
  };
  // string source_hub = 1;
  void clear_source_hub();
  const std::string& source_hub() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_hub(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_hub();
  PROTOBUF_NODISCARD std::string* release_source_hub();
  void set_allocated_source_hub(std::string* source_hub);
  private:
  const std::string& _internal_source_hub() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_hub(const std::string& value);
  std::string* _internal_mutable_source_hub();
  public:

  // string destination_hub = 2;
  void clear_destination_hub();
  const std::string& destination_hub() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination_hub(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination_hub();
  PROTOBUF_NODISCARD std::string* release_destination_hub();
  void set_allocated_destination_hub(std::string* destination_hub);
  private:
  const std::string& _internal_destination_hub() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination_hub(const std::string& value);
  std::string* _internal_mutable_destination_hub();
  public:

  // string line = 3;
  void clear_line();
  const std::string& line() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_line(ArgT0&& arg0, ArgT... args);
  std::string* mutable_line();
  PROTOBUF_NODISCARD std::string* release_line();
  void set_allocated_line(std::string* line);
  private:
  const std::string& _internal_line() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_line(const std::string& value);
  std::string* _internal_mutable_line();
  public:

  // string line_rotation = 4;
  void clear_line_rotation();
  const std::string& line_rotation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_line_rotation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_line_rotation();
  PROTOBUF_NODISCARD std::string* release_line_rotation();
  void set_allocated_line_rotation(std::string* line_rotation);
  private:
  const std::string& _internal_line_rotation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_line_rotation(const std::string& value);
  std::string* _internal_mutable_line_rotation();
  public:

  // string vehicle = 5;
  void clear_vehicle();
  const std::string& vehicle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vehicle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vehicle();
  PROTOBUF_NODISCARD std::string* release_vehicle();
  void set_allocated_vehicle(std::string* vehicle);
  private:
  const std::string& _internal_vehicle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vehicle(const std::string& value);
  std::string* _internal_mutable_vehicle();
  public:

  // @@protoc_insertion_point(class_scope:operations_research.lattle.PathSegment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_hub_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_hub_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr line_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr line_rotation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vehicle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class AnnotatedPathSegment_SegmentCostDueToVehicleEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AnnotatedPathSegment_SegmentCostDueToVehicleEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AnnotatedPathSegment_SegmentCostDueToVehicleEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  AnnotatedPathSegment_SegmentCostDueToVehicleEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR AnnotatedPathSegment_SegmentCostDueToVehicleEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AnnotatedPathSegment_SegmentCostDueToVehicleEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AnnotatedPathSegment_SegmentCostDueToVehicleEntry_DoNotUse& other);
  static const AnnotatedPathSegment_SegmentCostDueToVehicleEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AnnotatedPathSegment_SegmentCostDueToVehicleEntry_DoNotUse*>(&_AnnotatedPathSegment_SegmentCostDueToVehicleEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "operations_research.lattle.AnnotatedPathSegment.SegmentCostDueToVehicleEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lattle_2eproto;
};

// -------------------------------------------------------------------

class AnnotatedPathSegment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.AnnotatedPathSegment) */ {
 public:
  inline AnnotatedPathSegment() : AnnotatedPathSegment(nullptr) {}
  ~AnnotatedPathSegment() override;
  explicit PROTOBUF_CONSTEXPR AnnotatedPathSegment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnnotatedPathSegment(const AnnotatedPathSegment& from);
  AnnotatedPathSegment(AnnotatedPathSegment&& from) noexcept
    : AnnotatedPathSegment() {
    *this = ::std::move(from);
  }

  inline AnnotatedPathSegment& operator=(const AnnotatedPathSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnnotatedPathSegment& operator=(AnnotatedPathSegment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnnotatedPathSegment& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnnotatedPathSegment* internal_default_instance() {
    return reinterpret_cast<const AnnotatedPathSegment*>(
               &_AnnotatedPathSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(AnnotatedPathSegment& a, AnnotatedPathSegment& b) {
    a.Swap(&b);
  }
  inline void Swap(AnnotatedPathSegment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnnotatedPathSegment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnnotatedPathSegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnnotatedPathSegment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnnotatedPathSegment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnnotatedPathSegment& from) {
    AnnotatedPathSegment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnnotatedPathSegment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.AnnotatedPathSegment";
  }
  protected:
  explicit AnnotatedPathSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSegmentCostDueToVehicleFieldNumber = 5,
    kPathSegmentFieldNumber = 1,
    kArrivalTimeFieldNumber = 2,
    kDepartureTimeFieldNumber = 3,
    kSegmentCostConstantFieldNumber = 4,
    kSegmentCostDueToDepartureFieldNumber = 6,
    kSegmentCostDueToArrivalFieldNumber = 7,
    kIsCommittedFieldNumber = 8,
  };
  // map<string, double> segment_cost_due_to_vehicle = 5;
  int segment_cost_due_to_vehicle_size() const;
  private:
  int _internal_segment_cost_due_to_vehicle_size() const;
  public:
  void clear_segment_cost_due_to_vehicle();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_segment_cost_due_to_vehicle() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_segment_cost_due_to_vehicle();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      segment_cost_due_to_vehicle() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_segment_cost_due_to_vehicle();

  // .operations_research.lattle.PathSegment path_segment = 1;
  bool has_path_segment() const;
  private:
  bool _internal_has_path_segment() const;
  public:
  void clear_path_segment();
  const ::operations_research::lattle::PathSegment& path_segment() const;
  PROTOBUF_NODISCARD ::operations_research::lattle::PathSegment* release_path_segment();
  ::operations_research::lattle::PathSegment* mutable_path_segment();
  void set_allocated_path_segment(::operations_research::lattle::PathSegment* path_segment);
  private:
  const ::operations_research::lattle::PathSegment& _internal_path_segment() const;
  ::operations_research::lattle::PathSegment* _internal_mutable_path_segment();
  public:
  void unsafe_arena_set_allocated_path_segment(
      ::operations_research::lattle::PathSegment* path_segment);
  ::operations_research::lattle::PathSegment* unsafe_arena_release_path_segment();

  // .google.type.DateTime arrival_time = 2;
  bool has_arrival_time() const;
  private:
  bool _internal_has_arrival_time() const;
  public:
  void clear_arrival_time();
  const ::google::type::DateTime& arrival_time() const;
  PROTOBUF_NODISCARD ::google::type::DateTime* release_arrival_time();
  ::google::type::DateTime* mutable_arrival_time();
  void set_allocated_arrival_time(::google::type::DateTime* arrival_time);
  private:
  const ::google::type::DateTime& _internal_arrival_time() const;
  ::google::type::DateTime* _internal_mutable_arrival_time();
  public:
  void unsafe_arena_set_allocated_arrival_time(
      ::google::type::DateTime* arrival_time);
  ::google::type::DateTime* unsafe_arena_release_arrival_time();

  // .google.type.DateTime departure_time = 3;
  bool has_departure_time() const;
  private:
  bool _internal_has_departure_time() const;
  public:
  void clear_departure_time();
  const ::google::type::DateTime& departure_time() const;
  PROTOBUF_NODISCARD ::google::type::DateTime* release_departure_time();
  ::google::type::DateTime* mutable_departure_time();
  void set_allocated_departure_time(::google::type::DateTime* departure_time);
  private:
  const ::google::type::DateTime& _internal_departure_time() const;
  ::google::type::DateTime* _internal_mutable_departure_time();
  public:
  void unsafe_arena_set_allocated_departure_time(
      ::google::type::DateTime* departure_time);
  ::google::type::DateTime* unsafe_arena_release_departure_time();

  // double segment_cost_constant = 4;
  void clear_segment_cost_constant();
  double segment_cost_constant() const;
  void set_segment_cost_constant(double value);
  private:
  double _internal_segment_cost_constant() const;
  void _internal_set_segment_cost_constant(double value);
  public:

  // double segment_cost_due_to_departure = 6;
  void clear_segment_cost_due_to_departure();
  double segment_cost_due_to_departure() const;
  void set_segment_cost_due_to_departure(double value);
  private:
  double _internal_segment_cost_due_to_departure() const;
  void _internal_set_segment_cost_due_to_departure(double value);
  public:

  // double segment_cost_due_to_arrival = 7;
  void clear_segment_cost_due_to_arrival();
  double segment_cost_due_to_arrival() const;
  void set_segment_cost_due_to_arrival(double value);
  private:
  double _internal_segment_cost_due_to_arrival() const;
  void _internal_set_segment_cost_due_to_arrival(double value);
  public:

  // bool is_committed = 8;
  void clear_is_committed();
  bool is_committed() const;
  void set_is_committed(bool value);
  private:
  bool _internal_is_committed() const;
  void _internal_set_is_committed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:operations_research.lattle.AnnotatedPathSegment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        AnnotatedPathSegment_SegmentCostDueToVehicleEntry_DoNotUse,
        std::string, double,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> segment_cost_due_to_vehicle_;
    ::operations_research::lattle::PathSegment* path_segment_;
    ::google::type::DateTime* arrival_time_;
    ::google::type::DateTime* departure_time_;
    double segment_cost_constant_;
    double segment_cost_due_to_departure_;
    double segment_cost_due_to_arrival_;
    bool is_committed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class EarlinessTardinessCost final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.EarlinessTardinessCost) */ {
 public:
  inline EarlinessTardinessCost() : EarlinessTardinessCost(nullptr) {}
  ~EarlinessTardinessCost() override;
  explicit PROTOBUF_CONSTEXPR EarlinessTardinessCost(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EarlinessTardinessCost(const EarlinessTardinessCost& from);
  EarlinessTardinessCost(EarlinessTardinessCost&& from) noexcept
    : EarlinessTardinessCost() {
    *this = ::std::move(from);
  }

  inline EarlinessTardinessCost& operator=(const EarlinessTardinessCost& from) {
    CopyFrom(from);
    return *this;
  }
  inline EarlinessTardinessCost& operator=(EarlinessTardinessCost&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EarlinessTardinessCost& default_instance() {
    return *internal_default_instance();
  }
  static inline const EarlinessTardinessCost* internal_default_instance() {
    return reinterpret_cast<const EarlinessTardinessCost*>(
               &_EarlinessTardinessCost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(EarlinessTardinessCost& a, EarlinessTardinessCost& b) {
    a.Swap(&b);
  }
  inline void Swap(EarlinessTardinessCost* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EarlinessTardinessCost* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EarlinessTardinessCost* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EarlinessTardinessCost>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EarlinessTardinessCost& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EarlinessTardinessCost& from) {
    EarlinessTardinessCost::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EarlinessTardinessCost* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.EarlinessTardinessCost";
  }
  protected:
  explicit EarlinessTardinessCost(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEarlinessFieldNumber = 1,
    kTardinessFieldNumber = 2,
  };
  // double earliness = 1;
  void clear_earliness();
  double earliness() const;
  void set_earliness(double value);
  private:
  double _internal_earliness() const;
  void _internal_set_earliness(double value);
  public:

  // double tardiness = 2;
  void clear_tardiness();
  double tardiness() const;
  void set_tardiness(double value);
  private:
  double _internal_tardiness() const;
  void _internal_set_tardiness(double value);
  public:

  // @@protoc_insertion_point(class_scope:operations_research.lattle.EarlinessTardinessCost)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double earliness_;
    double tardiness_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class LogisticsNetworkState_UsedCapacityInVehicle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle) */ {
 public:
  inline LogisticsNetworkState_UsedCapacityInVehicle() : LogisticsNetworkState_UsedCapacityInVehicle(nullptr) {}
  ~LogisticsNetworkState_UsedCapacityInVehicle() override;
  explicit PROTOBUF_CONSTEXPR LogisticsNetworkState_UsedCapacityInVehicle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogisticsNetworkState_UsedCapacityInVehicle(const LogisticsNetworkState_UsedCapacityInVehicle& from);
  LogisticsNetworkState_UsedCapacityInVehicle(LogisticsNetworkState_UsedCapacityInVehicle&& from) noexcept
    : LogisticsNetworkState_UsedCapacityInVehicle() {
    *this = ::std::move(from);
  }

  inline LogisticsNetworkState_UsedCapacityInVehicle& operator=(const LogisticsNetworkState_UsedCapacityInVehicle& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogisticsNetworkState_UsedCapacityInVehicle& operator=(LogisticsNetworkState_UsedCapacityInVehicle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogisticsNetworkState_UsedCapacityInVehicle& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogisticsNetworkState_UsedCapacityInVehicle* internal_default_instance() {
    return reinterpret_cast<const LogisticsNetworkState_UsedCapacityInVehicle*>(
               &_LogisticsNetworkState_UsedCapacityInVehicle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(LogisticsNetworkState_UsedCapacityInVehicle& a, LogisticsNetworkState_UsedCapacityInVehicle& b) {
    a.Swap(&b);
  }
  inline void Swap(LogisticsNetworkState_UsedCapacityInVehicle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogisticsNetworkState_UsedCapacityInVehicle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogisticsNetworkState_UsedCapacityInVehicle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogisticsNetworkState_UsedCapacityInVehicle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogisticsNetworkState_UsedCapacityInVehicle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogisticsNetworkState_UsedCapacityInVehicle& from) {
    LogisticsNetworkState_UsedCapacityInVehicle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogisticsNetworkState_UsedCapacityInVehicle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle";
  }
  protected:
  explicit LogisticsNetworkState_UsedCapacityInVehicle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsedCapacityFieldNumber = 3,
    kLineFieldNumber = 1,
    kLineRotationFieldNumber = 2,
    kVehicleFieldNumber = 4,
    kSourceHubFieldNumber = 5,
    kDestinationHubFieldNumber = 6,
  };
  // repeated .operations_research.lattle.ValueDimension used_capacity = 3;
  int used_capacity_size() const;
  private:
  int _internal_used_capacity_size() const;
  public:
  void clear_used_capacity();
  ::operations_research::lattle::ValueDimension* mutable_used_capacity(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >*
      mutable_used_capacity();
  private:
  const ::operations_research::lattle::ValueDimension& _internal_used_capacity(int index) const;
  ::operations_research::lattle::ValueDimension* _internal_add_used_capacity();
  public:
  const ::operations_research::lattle::ValueDimension& used_capacity(int index) const;
  ::operations_research::lattle::ValueDimension* add_used_capacity();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >&
      used_capacity() const;

  // string line = 1;
  void clear_line();
  const std::string& line() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_line(ArgT0&& arg0, ArgT... args);
  std::string* mutable_line();
  PROTOBUF_NODISCARD std::string* release_line();
  void set_allocated_line(std::string* line);
  private:
  const std::string& _internal_line() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_line(const std::string& value);
  std::string* _internal_mutable_line();
  public:

  // string line_rotation = 2;
  void clear_line_rotation();
  const std::string& line_rotation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_line_rotation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_line_rotation();
  PROTOBUF_NODISCARD std::string* release_line_rotation();
  void set_allocated_line_rotation(std::string* line_rotation);
  private:
  const std::string& _internal_line_rotation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_line_rotation(const std::string& value);
  std::string* _internal_mutable_line_rotation();
  public:

  // string vehicle = 4;
  void clear_vehicle();
  const std::string& vehicle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vehicle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vehicle();
  PROTOBUF_NODISCARD std::string* release_vehicle();
  void set_allocated_vehicle(std::string* vehicle);
  private:
  const std::string& _internal_vehicle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vehicle(const std::string& value);
  std::string* _internal_mutable_vehicle();
  public:

  // string source_hub = 5;
  void clear_source_hub();
  const std::string& source_hub() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_hub(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_hub();
  PROTOBUF_NODISCARD std::string* release_source_hub();
  void set_allocated_source_hub(std::string* source_hub);
  private:
  const std::string& _internal_source_hub() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_hub(const std::string& value);
  std::string* _internal_mutable_source_hub();
  public:

  // string destination_hub = 6;
  void clear_destination_hub();
  const std::string& destination_hub() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination_hub(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination_hub();
  PROTOBUF_NODISCARD std::string* release_destination_hub();
  void set_allocated_destination_hub(std::string* destination_hub);
  private:
  const std::string& _internal_destination_hub() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination_hub(const std::string& value);
  std::string* _internal_mutable_destination_hub();
  public:

  // @@protoc_insertion_point(class_scope:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension > used_capacity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr line_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr line_rotation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vehicle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_hub_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_hub_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class LogisticsNetworkState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.LogisticsNetworkState) */ {
 public:
  inline LogisticsNetworkState() : LogisticsNetworkState(nullptr) {}
  ~LogisticsNetworkState() override;
  explicit PROTOBUF_CONSTEXPR LogisticsNetworkState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogisticsNetworkState(const LogisticsNetworkState& from);
  LogisticsNetworkState(LogisticsNetworkState&& from) noexcept
    : LogisticsNetworkState() {
    *this = ::std::move(from);
  }

  inline LogisticsNetworkState& operator=(const LogisticsNetworkState& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogisticsNetworkState& operator=(LogisticsNetworkState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogisticsNetworkState& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogisticsNetworkState* internal_default_instance() {
    return reinterpret_cast<const LogisticsNetworkState*>(
               &_LogisticsNetworkState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(LogisticsNetworkState& a, LogisticsNetworkState& b) {
    a.Swap(&b);
  }
  inline void Swap(LogisticsNetworkState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogisticsNetworkState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogisticsNetworkState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogisticsNetworkState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogisticsNetworkState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogisticsNetworkState& from) {
    LogisticsNetworkState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogisticsNetworkState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.LogisticsNetworkState";
  }
  protected:
  explicit LogisticsNetworkState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LogisticsNetworkState_UsedCapacityInVehicle UsedCapacityInVehicle;

  // accessors -------------------------------------------------------

  enum : int {
    kRoutedParcelsFieldNumber = 2,
    kParcelRoutesFieldNumber = 3,
    kUsedCapacityInVehicleFieldNumber = 4,
    kNetworkFieldNumber = 1,
  };
  // repeated .operations_research.lattle.Parcel routed_parcels = 2;
  int routed_parcels_size() const;
  private:
  int _internal_routed_parcels_size() const;
  public:
  void clear_routed_parcels();
  ::operations_research::lattle::Parcel* mutable_routed_parcels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::Parcel >*
      mutable_routed_parcels();
  private:
  const ::operations_research::lattle::Parcel& _internal_routed_parcels(int index) const;
  ::operations_research::lattle::Parcel* _internal_add_routed_parcels();
  public:
  const ::operations_research::lattle::Parcel& routed_parcels(int index) const;
  ::operations_research::lattle::Parcel* add_routed_parcels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::Parcel >&
      routed_parcels() const;

  // repeated .operations_research.lattle.ParcelRoute parcel_routes = 3;
  int parcel_routes_size() const;
  private:
  int _internal_parcel_routes_size() const;
  public:
  void clear_parcel_routes();
  ::operations_research::lattle::ParcelRoute* mutable_parcel_routes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ParcelRoute >*
      mutable_parcel_routes();
  private:
  const ::operations_research::lattle::ParcelRoute& _internal_parcel_routes(int index) const;
  ::operations_research::lattle::ParcelRoute* _internal_add_parcel_routes();
  public:
  const ::operations_research::lattle::ParcelRoute& parcel_routes(int index) const;
  ::operations_research::lattle::ParcelRoute* add_parcel_routes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ParcelRoute >&
      parcel_routes() const;

  // repeated .operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle used_capacity_in_vehicle = 4;
  int used_capacity_in_vehicle_size() const;
  private:
  int _internal_used_capacity_in_vehicle_size() const;
  public:
  void clear_used_capacity_in_vehicle();
  ::operations_research::lattle::LogisticsNetworkState_UsedCapacityInVehicle* mutable_used_capacity_in_vehicle(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::LogisticsNetworkState_UsedCapacityInVehicle >*
      mutable_used_capacity_in_vehicle();
  private:
  const ::operations_research::lattle::LogisticsNetworkState_UsedCapacityInVehicle& _internal_used_capacity_in_vehicle(int index) const;
  ::operations_research::lattle::LogisticsNetworkState_UsedCapacityInVehicle* _internal_add_used_capacity_in_vehicle();
  public:
  const ::operations_research::lattle::LogisticsNetworkState_UsedCapacityInVehicle& used_capacity_in_vehicle(int index) const;
  ::operations_research::lattle::LogisticsNetworkState_UsedCapacityInVehicle* add_used_capacity_in_vehicle();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::LogisticsNetworkState_UsedCapacityInVehicle >&
      used_capacity_in_vehicle() const;

  // string network = 1;
  void clear_network();
  const std::string& network() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_network(ArgT0&& arg0, ArgT... args);
  std::string* mutable_network();
  PROTOBUF_NODISCARD std::string* release_network();
  void set_allocated_network(std::string* network);
  private:
  const std::string& _internal_network() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network(const std::string& value);
  std::string* _internal_mutable_network();
  public:

  // @@protoc_insertion_point(class_scope:operations_research.lattle.LogisticsNetworkState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::Parcel > routed_parcels_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ParcelRoute > parcel_routes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::LogisticsNetworkState_UsedCapacityInVehicle > used_capacity_in_vehicle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class LattleValidationError_FieldReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.LattleValidationError.FieldReference) */ {
 public:
  inline LattleValidationError_FieldReference() : LattleValidationError_FieldReference(nullptr) {}
  ~LattleValidationError_FieldReference() override;
  explicit PROTOBUF_CONSTEXPR LattleValidationError_FieldReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LattleValidationError_FieldReference(const LattleValidationError_FieldReference& from);
  LattleValidationError_FieldReference(LattleValidationError_FieldReference&& from) noexcept
    : LattleValidationError_FieldReference() {
    *this = ::std::move(from);
  }

  inline LattleValidationError_FieldReference& operator=(const LattleValidationError_FieldReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline LattleValidationError_FieldReference& operator=(LattleValidationError_FieldReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LattleValidationError_FieldReference& default_instance() {
    return *internal_default_instance();
  }
  enum IndexOrKeyCase {
    kIndex = 2,
    kKey = 3,
    INDEX_OR_KEY_NOT_SET = 0,
  };

  static inline const LattleValidationError_FieldReference* internal_default_instance() {
    return reinterpret_cast<const LattleValidationError_FieldReference*>(
               &_LattleValidationError_FieldReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(LattleValidationError_FieldReference& a, LattleValidationError_FieldReference& b) {
    a.Swap(&b);
  }
  inline void Swap(LattleValidationError_FieldReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LattleValidationError_FieldReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LattleValidationError_FieldReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LattleValidationError_FieldReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LattleValidationError_FieldReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LattleValidationError_FieldReference& from) {
    LattleValidationError_FieldReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LattleValidationError_FieldReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.LattleValidationError.FieldReference";
  }
  protected:
  explicit LattleValidationError_FieldReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSubFieldFieldNumber = 4,
    kIndexFieldNumber = 2,
    kKeyFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .operations_research.lattle.LattleValidationError.FieldReference sub_field = 4;
  bool has_sub_field() const;
  private:
  bool _internal_has_sub_field() const;
  public:
  void clear_sub_field();
  const ::operations_research::lattle::LattleValidationError_FieldReference& sub_field() const;
  PROTOBUF_NODISCARD ::operations_research::lattle::LattleValidationError_FieldReference* release_sub_field();
  ::operations_research::lattle::LattleValidationError_FieldReference* mutable_sub_field();
  void set_allocated_sub_field(::operations_research::lattle::LattleValidationError_FieldReference* sub_field);
  private:
  const ::operations_research::lattle::LattleValidationError_FieldReference& _internal_sub_field() const;
  ::operations_research::lattle::LattleValidationError_FieldReference* _internal_mutable_sub_field();
  public:
  void unsafe_arena_set_allocated_sub_field(
      ::operations_research::lattle::LattleValidationError_FieldReference* sub_field);
  ::operations_research::lattle::LattleValidationError_FieldReference* unsafe_arena_release_sub_field();

  // int32 index = 2;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // string key = 3;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  void clear_index_or_key();
  IndexOrKeyCase index_or_key_case() const;
  // @@protoc_insertion_point(class_scope:operations_research.lattle.LattleValidationError.FieldReference)
 private:
  class _Internal;
  void set_has_index();
  void set_has_key();

  inline bool has_index_or_key() const;
  inline void clear_has_index_or_key();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::operations_research::lattle::LattleValidationError_FieldReference* sub_field_;
    union IndexOrKeyUnion {
      constexpr IndexOrKeyUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int32_t index_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    } index_or_key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// -------------------------------------------------------------------

class LattleValidationError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.lattle.LattleValidationError) */ {
 public:
  inline LattleValidationError() : LattleValidationError(nullptr) {}
  ~LattleValidationError() override;
  explicit PROTOBUF_CONSTEXPR LattleValidationError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LattleValidationError(const LattleValidationError& from);
  LattleValidationError(LattleValidationError&& from) noexcept
    : LattleValidationError() {
    *this = ::std::move(from);
  }

  inline LattleValidationError& operator=(const LattleValidationError& from) {
    CopyFrom(from);
    return *this;
  }
  inline LattleValidationError& operator=(LattleValidationError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LattleValidationError& default_instance() {
    return *internal_default_instance();
  }
  static inline const LattleValidationError* internal_default_instance() {
    return reinterpret_cast<const LattleValidationError*>(
               &_LattleValidationError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(LattleValidationError& a, LattleValidationError& b) {
    a.Swap(&b);
  }
  inline void Swap(LattleValidationError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LattleValidationError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LattleValidationError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LattleValidationError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LattleValidationError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LattleValidationError& from) {
    LattleValidationError::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LattleValidationError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.lattle.LattleValidationError";
  }
  protected:
  explicit LattleValidationError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LattleValidationError_FieldReference FieldReference;

  typedef LattleValidationError_Code Code;
  static constexpr Code ERROR_UNSPECIFIED =
    LattleValidationError_Code_ERROR_UNSPECIFIED;
  static constexpr Code VALIDATION_ERROR =
    LattleValidationError_Code_VALIDATION_ERROR;
  static constexpr Code VALIDATION_TIMEOUT_ERROR =
    LattleValidationError_Code_VALIDATION_TIMEOUT_ERROR;
  static constexpr Code VALIDATION_OBJECT_ALREADY_INITIALIZED =
    LattleValidationError_Code_VALIDATION_OBJECT_ALREADY_INITIALIZED;
  static constexpr Code LOGISTICS_NETWORK_ERROR =
    LattleValidationError_Code_LOGISTICS_NETWORK_ERROR;
  static constexpr Code LOGISTICS_NETWORK_NO_DIMENSION =
    LattleValidationError_Code_LOGISTICS_NETWORK_NO_DIMENSION;
  static constexpr Code LOGISTICS_NETWORK_STATE_ERROR =
    LattleValidationError_Code_LOGISTICS_NETWORK_STATE_ERROR;
  static constexpr Code LOGISTICS_NETWORK_STATE_INTERNAL_ERROR =
    LattleValidationError_Code_LOGISTICS_NETWORK_STATE_INTERNAL_ERROR;
  static constexpr Code VALUE_DIMENSION_ERROR =
    LattleValidationError_Code_VALUE_DIMENSION_ERROR;
  static constexpr Code VALUE_DIMENSION_UNKNOWN_DIMENSION =
    LattleValidationError_Code_VALUE_DIMENSION_UNKNOWN_DIMENSION;
  static constexpr Code LINE_ERROR =
    LattleValidationError_Code_LINE_ERROR;
  static constexpr Code LINE_NOT_IN_NETWORK =
    LattleValidationError_Code_LINE_NOT_IN_NETWORK;
  static constexpr Code LINE_ROTATION_NOT_IN_NETWORK =
    LattleValidationError_Code_LINE_ROTATION_NOT_IN_NETWORK;
  static constexpr Code LINE_HUBS_NOT_IN_NETWORK =
    LattleValidationError_Code_LINE_HUBS_NOT_IN_NETWORK;
  static constexpr Code LINE_ROTATION_WRONG_NUMBER_OF_ARRIVALS =
    LattleValidationError_Code_LINE_ROTATION_WRONG_NUMBER_OF_ARRIVALS;
  static constexpr Code LINE_ROTATION_WRONG_NUMBER_OF_DEPARTURES =
    LattleValidationError_Code_LINE_ROTATION_WRONG_NUMBER_OF_DEPARTURES;
  static constexpr Code LINE_ROTATION_HUB_NOT_IN_LINE =
    LattleValidationError_Code_LINE_ROTATION_HUB_NOT_IN_LINE;
  static constexpr Code LINE_ROTATION_WRONG_ORDER_OF_HUBS_TIME_WISE =
    LattleValidationError_Code_LINE_ROTATION_WRONG_ORDER_OF_HUBS_TIME_WISE;
  static constexpr Code VEHICLE_ERROR =
    LattleValidationError_Code_VEHICLE_ERROR;
  static constexpr Code VEHICLE_CAPACITY_DIMENSION_NOT_IN_NETWORK =
    LattleValidationError_Code_VEHICLE_CAPACITY_DIMENSION_NOT_IN_NETWORK;
  static constexpr Code DISTANCE_MATRIX_ERROR =
    LattleValidationError_Code_DISTANCE_MATRIX_ERROR;
  static constexpr Code DISTANCE_MATRIX_ENTRY_SOURCE_HUB_NOT_IN_NETWORK =
    LattleValidationError_Code_DISTANCE_MATRIX_ENTRY_SOURCE_HUB_NOT_IN_NETWORK;
  static constexpr Code DISTANCE_MATRIX_ENTRY_DESTINATION_HUB_NOT_IN_NETWORK =
    LattleValidationError_Code_DISTANCE_MATRIX_ENTRY_DESTINATION_HUB_NOT_IN_NETWORK;
  static constexpr Code DISTANCE_MATRIX_ENTRY_WEIGHT_DIMENSION_NOT_IN_NETWORK =
    LattleValidationError_Code_DISTANCE_MATRIX_ENTRY_WEIGHT_DIMENSION_NOT_IN_NETWORK;
  static inline bool Code_IsValid(int value) {
    return LattleValidationError_Code_IsValid(value);
  }
  static constexpr Code Code_MIN =
    LattleValidationError_Code_Code_MIN;
  static constexpr Code Code_MAX =
    LattleValidationError_Code_Code_MAX;
  static constexpr int Code_ARRAYSIZE =
    LattleValidationError_Code_Code_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Code_descriptor() {
    return LattleValidationError_Code_descriptor();
  }
  template<typename T>
  static inline const std::string& Code_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Code>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Code_Name.");
    return LattleValidationError_Code_Name(enum_t_value);
  }
  static inline bool Code_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Code* value) {
    return LattleValidationError_Code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 3,
    kOffendingValuesFieldNumber = 4,
    kFieldFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // optional string error_message = 3;
  bool has_error_message() const;
  private:
  bool _internal_has_error_message() const;
  public:
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // optional string offending_values = 4;
  bool has_offending_values() const;
  private:
  bool _internal_has_offending_values() const;
  public:
  void clear_offending_values();
  const std::string& offending_values() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_offending_values(ArgT0&& arg0, ArgT... args);
  std::string* mutable_offending_values();
  PROTOBUF_NODISCARD std::string* release_offending_values();
  void set_allocated_offending_values(std::string* offending_values);
  private:
  const std::string& _internal_offending_values() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_offending_values(const std::string& value);
  std::string* _internal_mutable_offending_values();
  public:

  // .operations_research.lattle.LattleValidationError.FieldReference field = 2;
  bool has_field() const;
  private:
  bool _internal_has_field() const;
  public:
  void clear_field();
  const ::operations_research::lattle::LattleValidationError_FieldReference& field() const;
  PROTOBUF_NODISCARD ::operations_research::lattle::LattleValidationError_FieldReference* release_field();
  ::operations_research::lattle::LattleValidationError_FieldReference* mutable_field();
  void set_allocated_field(::operations_research::lattle::LattleValidationError_FieldReference* field);
  private:
  const ::operations_research::lattle::LattleValidationError_FieldReference& _internal_field() const;
  ::operations_research::lattle::LattleValidationError_FieldReference* _internal_mutable_field();
  public:
  void unsafe_arena_set_allocated_field(
      ::operations_research::lattle::LattleValidationError_FieldReference* field);
  ::operations_research::lattle::LattleValidationError_FieldReference* unsafe_arena_release_field();

  // .operations_research.lattle.LattleValidationError.Code code = 1;
  void clear_code();
  ::operations_research::lattle::LattleValidationError_Code code() const;
  void set_code(::operations_research::lattle::LattleValidationError_Code value);
  private:
  ::operations_research::lattle::LattleValidationError_Code _internal_code() const;
  void _internal_set_code(::operations_research::lattle::LattleValidationError_Code value);
  public:

  // @@protoc_insertion_point(class_scope:operations_research.lattle.LattleValidationError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr offending_values_;
    ::operations_research::lattle::LattleValidationError_FieldReference* field_;
    int code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lattle_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DateTimeRange

// .google.type.DateTime first_date = 1;
inline bool DateTimeRange::_internal_has_first_date() const {
  return this != internal_default_instance() && _impl_.first_date_ != nullptr;
}
inline bool DateTimeRange::has_first_date() const {
  return _internal_has_first_date();
}
inline const ::google::type::DateTime& DateTimeRange::_internal_first_date() const {
  const ::google::type::DateTime* p = _impl_.first_date_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::type::DateTime&>(
      ::google::type::_DateTime_default_instance_);
}
inline const ::google::type::DateTime& DateTimeRange::first_date() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.DateTimeRange.first_date)
  return _internal_first_date();
}
inline void DateTimeRange::unsafe_arena_set_allocated_first_date(
    ::google::type::DateTime* first_date) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.first_date_);
  }
  _impl_.first_date_ = first_date;
  if (first_date) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.DateTimeRange.first_date)
}
inline ::google::type::DateTime* DateTimeRange::release_first_date() {
  
  ::google::type::DateTime* temp = _impl_.first_date_;
  _impl_.first_date_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::type::DateTime* DateTimeRange::unsafe_arena_release_first_date() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.DateTimeRange.first_date)
  
  ::google::type::DateTime* temp = _impl_.first_date_;
  _impl_.first_date_ = nullptr;
  return temp;
}
inline ::google::type::DateTime* DateTimeRange::_internal_mutable_first_date() {
  
  if (_impl_.first_date_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::type::DateTime>(GetArenaForAllocation());
    _impl_.first_date_ = p;
  }
  return _impl_.first_date_;
}
inline ::google::type::DateTime* DateTimeRange::mutable_first_date() {
  ::google::type::DateTime* _msg = _internal_mutable_first_date();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.DateTimeRange.first_date)
  return _msg;
}
inline void DateTimeRange::set_allocated_first_date(::google::type::DateTime* first_date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.first_date_);
  }
  if (first_date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(first_date));
    if (message_arena != submessage_arena) {
      first_date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, first_date, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.first_date_ = first_date;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.DateTimeRange.first_date)
}

// .google.type.DateTime last_date = 2;
inline bool DateTimeRange::_internal_has_last_date() const {
  return this != internal_default_instance() && _impl_.last_date_ != nullptr;
}
inline bool DateTimeRange::has_last_date() const {
  return _internal_has_last_date();
}
inline const ::google::type::DateTime& DateTimeRange::_internal_last_date() const {
  const ::google::type::DateTime* p = _impl_.last_date_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::type::DateTime&>(
      ::google::type::_DateTime_default_instance_);
}
inline const ::google::type::DateTime& DateTimeRange::last_date() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.DateTimeRange.last_date)
  return _internal_last_date();
}
inline void DateTimeRange::unsafe_arena_set_allocated_last_date(
    ::google::type::DateTime* last_date) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_date_);
  }
  _impl_.last_date_ = last_date;
  if (last_date) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.DateTimeRange.last_date)
}
inline ::google::type::DateTime* DateTimeRange::release_last_date() {
  
  ::google::type::DateTime* temp = _impl_.last_date_;
  _impl_.last_date_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::type::DateTime* DateTimeRange::unsafe_arena_release_last_date() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.DateTimeRange.last_date)
  
  ::google::type::DateTime* temp = _impl_.last_date_;
  _impl_.last_date_ = nullptr;
  return temp;
}
inline ::google::type::DateTime* DateTimeRange::_internal_mutable_last_date() {
  
  if (_impl_.last_date_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::type::DateTime>(GetArenaForAllocation());
    _impl_.last_date_ = p;
  }
  return _impl_.last_date_;
}
inline ::google::type::DateTime* DateTimeRange::mutable_last_date() {
  ::google::type::DateTime* _msg = _internal_mutable_last_date();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.DateTimeRange.last_date)
  return _msg;
}
inline void DateTimeRange::set_allocated_last_date(::google::type::DateTime* last_date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_date_);
  }
  if (last_date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_date));
    if (message_arena != submessage_arena) {
      last_date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_date, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_date_ = last_date;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.DateTimeRange.last_date)
}

// -------------------------------------------------------------------

// IntegerRange

// optional int32 start_value = 1;
inline bool IntegerRange::_internal_has_start_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IntegerRange::has_start_value() const {
  return _internal_has_start_value();
}
inline void IntegerRange::clear_start_value() {
  _impl_.start_value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t IntegerRange::_internal_start_value() const {
  return _impl_.start_value_;
}
inline int32_t IntegerRange::start_value() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.IntegerRange.start_value)
  return _internal_start_value();
}
inline void IntegerRange::_internal_set_start_value(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.start_value_ = value;
}
inline void IntegerRange::set_start_value(int32_t value) {
  _internal_set_start_value(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.IntegerRange.start_value)
}

// optional int32 end_value = 2;
inline bool IntegerRange::_internal_has_end_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IntegerRange::has_end_value() const {
  return _internal_has_end_value();
}
inline void IntegerRange::clear_end_value() {
  _impl_.end_value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t IntegerRange::_internal_end_value() const {
  return _impl_.end_value_;
}
inline int32_t IntegerRange::end_value() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.IntegerRange.end_value)
  return _internal_end_value();
}
inline void IntegerRange::_internal_set_end_value(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.end_value_ = value;
}
inline void IntegerRange::set_end_value(int32_t value) {
  _internal_set_end_value(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.IntegerRange.end_value)
}

// -------------------------------------------------------------------

// Function1D

// double constant = 1;
inline bool Function1D::_internal_has_constant() const {
  return function_case() == kConstant;
}
inline bool Function1D::has_constant() const {
  return _internal_has_constant();
}
inline void Function1D::set_has_constant() {
  _impl_._oneof_case_[0] = kConstant;
}
inline void Function1D::clear_constant() {
  if (_internal_has_constant()) {
    _impl_.function_.constant_ = 0;
    clear_has_function();
  }
}
inline double Function1D::_internal_constant() const {
  if (_internal_has_constant()) {
    return _impl_.function_.constant_;
  }
  return 0;
}
inline void Function1D::_internal_set_constant(double value) {
  if (!_internal_has_constant()) {
    clear_function();
    set_has_constant();
  }
  _impl_.function_.constant_ = value;
}
inline double Function1D::constant() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Function1D.constant)
  return _internal_constant();
}
inline void Function1D::set_constant(double value) {
  _internal_set_constant(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.Function1D.constant)
}

// .operations_research.lattle.PieceWiseAffineFunction pwl = 2;
inline bool Function1D::_internal_has_pwl() const {
  return function_case() == kPwl;
}
inline bool Function1D::has_pwl() const {
  return _internal_has_pwl();
}
inline void Function1D::set_has_pwl() {
  _impl_._oneof_case_[0] = kPwl;
}
inline void Function1D::clear_pwl() {
  if (_internal_has_pwl()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.function_.pwl_;
    }
    clear_has_function();
  }
}
inline ::operations_research::lattle::PieceWiseAffineFunction* Function1D::release_pwl() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.Function1D.pwl)
  if (_internal_has_pwl()) {
    clear_has_function();
    ::operations_research::lattle::PieceWiseAffineFunction* temp = _impl_.function_.pwl_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.function_.pwl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::lattle::PieceWiseAffineFunction& Function1D::_internal_pwl() const {
  return _internal_has_pwl()
      ? *_impl_.function_.pwl_
      : reinterpret_cast< ::operations_research::lattle::PieceWiseAffineFunction&>(::operations_research::lattle::_PieceWiseAffineFunction_default_instance_);
}
inline const ::operations_research::lattle::PieceWiseAffineFunction& Function1D::pwl() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Function1D.pwl)
  return _internal_pwl();
}
inline ::operations_research::lattle::PieceWiseAffineFunction* Function1D::unsafe_arena_release_pwl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.lattle.Function1D.pwl)
  if (_internal_has_pwl()) {
    clear_has_function();
    ::operations_research::lattle::PieceWiseAffineFunction* temp = _impl_.function_.pwl_;
    _impl_.function_.pwl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Function1D::unsafe_arena_set_allocated_pwl(::operations_research::lattle::PieceWiseAffineFunction* pwl) {
  clear_function();
  if (pwl) {
    set_has_pwl();
    _impl_.function_.pwl_ = pwl;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.Function1D.pwl)
}
inline ::operations_research::lattle::PieceWiseAffineFunction* Function1D::_internal_mutable_pwl() {
  if (!_internal_has_pwl()) {
    clear_function();
    set_has_pwl();
    _impl_.function_.pwl_ = CreateMaybeMessage< ::operations_research::lattle::PieceWiseAffineFunction >(GetArenaForAllocation());
  }
  return _impl_.function_.pwl_;
}
inline ::operations_research::lattle::PieceWiseAffineFunction* Function1D::mutable_pwl() {
  ::operations_research::lattle::PieceWiseAffineFunction* _msg = _internal_mutable_pwl();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.Function1D.pwl)
  return _msg;
}

inline bool Function1D::has_function() const {
  return function_case() != FUNCTION_NOT_SET;
}
inline void Function1D::clear_has_function() {
  _impl_._oneof_case_[0] = FUNCTION_NOT_SET;
}
inline Function1D::FunctionCase Function1D::function_case() const {
  return Function1D::FunctionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PricingStrategy

// .operations_research.lattle.SeparableNDFunction separable = 1;
inline bool PricingStrategy::_internal_has_separable() const {
  return pricing_strategy_case() == kSeparable;
}
inline bool PricingStrategy::has_separable() const {
  return _internal_has_separable();
}
inline void PricingStrategy::set_has_separable() {
  _impl_._oneof_case_[0] = kSeparable;
}
inline void PricingStrategy::clear_separable() {
  if (_internal_has_separable()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.pricing_strategy_.separable_;
    }
    clear_has_pricing_strategy();
  }
}
inline ::operations_research::lattle::SeparableNDFunction* PricingStrategy::release_separable() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.PricingStrategy.separable)
  if (_internal_has_separable()) {
    clear_has_pricing_strategy();
    ::operations_research::lattle::SeparableNDFunction* temp = _impl_.pricing_strategy_.separable_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.pricing_strategy_.separable_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::lattle::SeparableNDFunction& PricingStrategy::_internal_separable() const {
  return _internal_has_separable()
      ? *_impl_.pricing_strategy_.separable_
      : reinterpret_cast< ::operations_research::lattle::SeparableNDFunction&>(::operations_research::lattle::_SeparableNDFunction_default_instance_);
}
inline const ::operations_research::lattle::SeparableNDFunction& PricingStrategy::separable() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.PricingStrategy.separable)
  return _internal_separable();
}
inline ::operations_research::lattle::SeparableNDFunction* PricingStrategy::unsafe_arena_release_separable() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.lattle.PricingStrategy.separable)
  if (_internal_has_separable()) {
    clear_has_pricing_strategy();
    ::operations_research::lattle::SeparableNDFunction* temp = _impl_.pricing_strategy_.separable_;
    _impl_.pricing_strategy_.separable_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PricingStrategy::unsafe_arena_set_allocated_separable(::operations_research::lattle::SeparableNDFunction* separable) {
  clear_pricing_strategy();
  if (separable) {
    set_has_separable();
    _impl_.pricing_strategy_.separable_ = separable;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.PricingStrategy.separable)
}
inline ::operations_research::lattle::SeparableNDFunction* PricingStrategy::_internal_mutable_separable() {
  if (!_internal_has_separable()) {
    clear_pricing_strategy();
    set_has_separable();
    _impl_.pricing_strategy_.separable_ = CreateMaybeMessage< ::operations_research::lattle::SeparableNDFunction >(GetArenaForAllocation());
  }
  return _impl_.pricing_strategy_.separable_;
}
inline ::operations_research::lattle::SeparableNDFunction* PricingStrategy::mutable_separable() {
  ::operations_research::lattle::SeparableNDFunction* _msg = _internal_mutable_separable();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.PricingStrategy.separable)
  return _msg;
}

inline bool PricingStrategy::has_pricing_strategy() const {
  return pricing_strategy_case() != PRICING_STRATEGY_NOT_SET;
}
inline void PricingStrategy::clear_has_pricing_strategy() {
  _impl_._oneof_case_[0] = PRICING_STRATEGY_NOT_SET;
}
inline PricingStrategy::PricingStrategyCase PricingStrategy::pricing_strategy_case() const {
  return PricingStrategy::PricingStrategyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SeparableNDFunction

// map<string, .operations_research.lattle.Function1D> components = 1;
inline int SeparableNDFunction::_internal_components_size() const {
  return _impl_.components_.size();
}
inline int SeparableNDFunction::components_size() const {
  return _internal_components_size();
}
inline void SeparableNDFunction::clear_components() {
  _impl_.components_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Function1D >&
SeparableNDFunction::_internal_components() const {
  return _impl_.components_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Function1D >&
SeparableNDFunction::components() const {
  // @@protoc_insertion_point(field_map:operations_research.lattle.SeparableNDFunction.components)
  return _internal_components();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Function1D >*
SeparableNDFunction::_internal_mutable_components() {
  return _impl_.components_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Function1D >*
SeparableNDFunction::mutable_components() {
  // @@protoc_insertion_point(field_mutable_map:operations_research.lattle.SeparableNDFunction.components)
  return _internal_mutable_components();
}

// double constant_price = 2;
inline void SeparableNDFunction::clear_constant_price() {
  _impl_.constant_price_ = 0;
}
inline double SeparableNDFunction::_internal_constant_price() const {
  return _impl_.constant_price_;
}
inline double SeparableNDFunction::constant_price() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.SeparableNDFunction.constant_price)
  return _internal_constant_price();
}
inline void SeparableNDFunction::_internal_set_constant_price(double value) {
  
  _impl_.constant_price_ = value;
}
inline void SeparableNDFunction::set_constant_price(double value) {
  _internal_set_constant_price(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.SeparableNDFunction.constant_price)
}

// -------------------------------------------------------------------

// ValueDimension

// int64 value = 1;
inline void ValueDimension::clear_value() {
  _impl_.value_ = int64_t{0};
}
inline int64_t ValueDimension::_internal_value() const {
  return _impl_.value_;
}
inline int64_t ValueDimension::value() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.ValueDimension.value)
  return _internal_value();
}
inline void ValueDimension::_internal_set_value(int64_t value) {
  
  _impl_.value_ = value;
}
inline void ValueDimension::set_value(int64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.ValueDimension.value)
}

// string dimension = 2;
inline void ValueDimension::clear_dimension() {
  _impl_.dimension_.ClearToEmpty();
}
inline const std::string& ValueDimension::dimension() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.ValueDimension.dimension)
  return _internal_dimension();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValueDimension::set_dimension(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dimension_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.ValueDimension.dimension)
}
inline std::string* ValueDimension::mutable_dimension() {
  std::string* _s = _internal_mutable_dimension();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.ValueDimension.dimension)
  return _s;
}
inline const std::string& ValueDimension::_internal_dimension() const {
  return _impl_.dimension_.Get();
}
inline void ValueDimension::_internal_set_dimension(const std::string& value) {
  
  _impl_.dimension_.Set(value, GetArenaForAllocation());
}
inline std::string* ValueDimension::_internal_mutable_dimension() {
  
  return _impl_.dimension_.Mutable(GetArenaForAllocation());
}
inline std::string* ValueDimension::release_dimension() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.ValueDimension.dimension)
  return _impl_.dimension_.Release();
}
inline void ValueDimension::set_allocated_dimension(std::string* dimension) {
  if (dimension != nullptr) {
    
  } else {
    
  }
  _impl_.dimension_.SetAllocated(dimension, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dimension_.IsDefault()) {
    _impl_.dimension_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.ValueDimension.dimension)
}

// -------------------------------------------------------------------

// PieceWiseAffineFunction

// repeated .operations_research.lattle.PieceWiseAffineSegment segments = 1;
inline int PieceWiseAffineFunction::_internal_segments_size() const {
  return _impl_.segments_.size();
}
inline int PieceWiseAffineFunction::segments_size() const {
  return _internal_segments_size();
}
inline void PieceWiseAffineFunction::clear_segments() {
  _impl_.segments_.Clear();
}
inline ::operations_research::lattle::PieceWiseAffineSegment* PieceWiseAffineFunction::mutable_segments(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.PieceWiseAffineFunction.segments)
  return _impl_.segments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::PieceWiseAffineSegment >*
PieceWiseAffineFunction::mutable_segments() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.lattle.PieceWiseAffineFunction.segments)
  return &_impl_.segments_;
}
inline const ::operations_research::lattle::PieceWiseAffineSegment& PieceWiseAffineFunction::_internal_segments(int index) const {
  return _impl_.segments_.Get(index);
}
inline const ::operations_research::lattle::PieceWiseAffineSegment& PieceWiseAffineFunction::segments(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.PieceWiseAffineFunction.segments)
  return _internal_segments(index);
}
inline ::operations_research::lattle::PieceWiseAffineSegment* PieceWiseAffineFunction::_internal_add_segments() {
  return _impl_.segments_.Add();
}
inline ::operations_research::lattle::PieceWiseAffineSegment* PieceWiseAffineFunction::add_segments() {
  ::operations_research::lattle::PieceWiseAffineSegment* _add = _internal_add_segments();
  // @@protoc_insertion_point(field_add:operations_research.lattle.PieceWiseAffineFunction.segments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::PieceWiseAffineSegment >&
PieceWiseAffineFunction::segments() const {
  // @@protoc_insertion_point(field_list:operations_research.lattle.PieceWiseAffineFunction.segments)
  return _impl_.segments_;
}

// -------------------------------------------------------------------

// PieceWiseAffineSegment

// double start_x = 1;
inline void PieceWiseAffineSegment::clear_start_x() {
  _impl_.start_x_ = 0;
}
inline double PieceWiseAffineSegment::_internal_start_x() const {
  return _impl_.start_x_;
}
inline double PieceWiseAffineSegment::start_x() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.PieceWiseAffineSegment.start_x)
  return _internal_start_x();
}
inline void PieceWiseAffineSegment::_internal_set_start_x(double value) {
  
  _impl_.start_x_ = value;
}
inline void PieceWiseAffineSegment::set_start_x(double value) {
  _internal_set_start_x(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.PieceWiseAffineSegment.start_x)
}

// double start_y = 2;
inline void PieceWiseAffineSegment::clear_start_y() {
  _impl_.start_y_ = 0;
}
inline double PieceWiseAffineSegment::_internal_start_y() const {
  return _impl_.start_y_;
}
inline double PieceWiseAffineSegment::start_y() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.PieceWiseAffineSegment.start_y)
  return _internal_start_y();
}
inline void PieceWiseAffineSegment::_internal_set_start_y(double value) {
  
  _impl_.start_y_ = value;
}
inline void PieceWiseAffineSegment::set_start_y(double value) {
  _internal_set_start_y(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.PieceWiseAffineSegment.start_y)
}

// double end_x = 3;
inline void PieceWiseAffineSegment::clear_end_x() {
  _impl_.end_x_ = 0;
}
inline double PieceWiseAffineSegment::_internal_end_x() const {
  return _impl_.end_x_;
}
inline double PieceWiseAffineSegment::end_x() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.PieceWiseAffineSegment.end_x)
  return _internal_end_x();
}
inline void PieceWiseAffineSegment::_internal_set_end_x(double value) {
  
  _impl_.end_x_ = value;
}
inline void PieceWiseAffineSegment::set_end_x(double value) {
  _internal_set_end_x(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.PieceWiseAffineSegment.end_x)
}

// double end_y = 4;
inline void PieceWiseAffineSegment::clear_end_y() {
  _impl_.end_y_ = 0;
}
inline double PieceWiseAffineSegment::_internal_end_y() const {
  return _impl_.end_y_;
}
inline double PieceWiseAffineSegment::end_y() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.PieceWiseAffineSegment.end_y)
  return _internal_end_y();
}
inline void PieceWiseAffineSegment::_internal_set_end_y(double value) {
  
  _impl_.end_y_ = value;
}
inline void PieceWiseAffineSegment::set_end_y(double value) {
  _internal_set_end_y(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.PieceWiseAffineSegment.end_y)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Instance

// .operations_research.lattle.LogisticsNetwork network = 1;
inline bool Instance::_internal_has_network() const {
  return this != internal_default_instance() && _impl_.network_ != nullptr;
}
inline bool Instance::has_network() const {
  return _internal_has_network();
}
inline void Instance::clear_network() {
  if (GetArenaForAllocation() == nullptr && _impl_.network_ != nullptr) {
    delete _impl_.network_;
  }
  _impl_.network_ = nullptr;
}
inline const ::operations_research::lattle::LogisticsNetwork& Instance::_internal_network() const {
  const ::operations_research::lattle::LogisticsNetwork* p = _impl_.network_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::lattle::LogisticsNetwork&>(
      ::operations_research::lattle::_LogisticsNetwork_default_instance_);
}
inline const ::operations_research::lattle::LogisticsNetwork& Instance::network() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Instance.network)
  return _internal_network();
}
inline void Instance::unsafe_arena_set_allocated_network(
    ::operations_research::lattle::LogisticsNetwork* network) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.network_);
  }
  _impl_.network_ = network;
  if (network) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.Instance.network)
}
inline ::operations_research::lattle::LogisticsNetwork* Instance::release_network() {
  
  ::operations_research::lattle::LogisticsNetwork* temp = _impl_.network_;
  _impl_.network_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::operations_research::lattle::LogisticsNetwork* Instance::unsafe_arena_release_network() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.Instance.network)
  
  ::operations_research::lattle::LogisticsNetwork* temp = _impl_.network_;
  _impl_.network_ = nullptr;
  return temp;
}
inline ::operations_research::lattle::LogisticsNetwork* Instance::_internal_mutable_network() {
  
  if (_impl_.network_ == nullptr) {
    auto* p = CreateMaybeMessage<::operations_research::lattle::LogisticsNetwork>(GetArenaForAllocation());
    _impl_.network_ = p;
  }
  return _impl_.network_;
}
inline ::operations_research::lattle::LogisticsNetwork* Instance::mutable_network() {
  ::operations_research::lattle::LogisticsNetwork* _msg = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.Instance.network)
  return _msg;
}
inline void Instance::set_allocated_network(::operations_research::lattle::LogisticsNetwork* network) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.network_;
  }
  if (network) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(network);
    if (message_arena != submessage_arena) {
      network = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, network, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.network_ = network;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.Instance.network)
}

// map<string, .operations_research.lattle.Parcel> parcels = 2;
inline int Instance::_internal_parcels_size() const {
  return _impl_.parcels_.size();
}
inline int Instance::parcels_size() const {
  return _internal_parcels_size();
}
inline void Instance::clear_parcels() {
  _impl_.parcels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Parcel >&
Instance::_internal_parcels() const {
  return _impl_.parcels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Parcel >&
Instance::parcels() const {
  // @@protoc_insertion_point(field_map:operations_research.lattle.Instance.parcels)
  return _internal_parcels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Parcel >*
Instance::_internal_mutable_parcels() {
  return _impl_.parcels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Parcel >*
Instance::mutable_parcels() {
  // @@protoc_insertion_point(field_mutable_map:operations_research.lattle.Instance.parcels)
  return _internal_mutable_parcels();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LogisticsNetwork

// string name = 1;
inline void LogisticsNetwork::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LogisticsNetwork::name() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LogisticsNetwork.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogisticsNetwork::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.LogisticsNetwork.name)
}
inline std::string* LogisticsNetwork::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LogisticsNetwork.name)
  return _s;
}
inline const std::string& LogisticsNetwork::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LogisticsNetwork::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LogisticsNetwork::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LogisticsNetwork::release_name() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.LogisticsNetwork.name)
  return _impl_.name_.Release();
}
inline void LogisticsNetwork::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.LogisticsNetwork.name)
}

// map<string, .operations_research.lattle.Line> lines = 2;
inline int LogisticsNetwork::_internal_lines_size() const {
  return _impl_.lines_.size();
}
inline int LogisticsNetwork::lines_size() const {
  return _internal_lines_size();
}
inline void LogisticsNetwork::clear_lines() {
  _impl_.lines_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Line >&
LogisticsNetwork::_internal_lines() const {
  return _impl_.lines_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Line >&
LogisticsNetwork::lines() const {
  // @@protoc_insertion_point(field_map:operations_research.lattle.LogisticsNetwork.lines)
  return _internal_lines();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Line >*
LogisticsNetwork::_internal_mutable_lines() {
  return _impl_.lines_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Line >*
LogisticsNetwork::mutable_lines() {
  // @@protoc_insertion_point(field_mutable_map:operations_research.lattle.LogisticsNetwork.lines)
  return _internal_mutable_lines();
}

// map<string, .operations_research.lattle.Vehicle> vehicles = 3;
inline int LogisticsNetwork::_internal_vehicles_size() const {
  return _impl_.vehicles_.size();
}
inline int LogisticsNetwork::vehicles_size() const {
  return _internal_vehicles_size();
}
inline void LogisticsNetwork::clear_vehicles() {
  _impl_.vehicles_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Vehicle >&
LogisticsNetwork::_internal_vehicles() const {
  return _impl_.vehicles_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Vehicle >&
LogisticsNetwork::vehicles() const {
  // @@protoc_insertion_point(field_map:operations_research.lattle.LogisticsNetwork.vehicles)
  return _internal_vehicles();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Vehicle >*
LogisticsNetwork::_internal_mutable_vehicles() {
  return _impl_.vehicles_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Vehicle >*
LogisticsNetwork::mutable_vehicles() {
  // @@protoc_insertion_point(field_mutable_map:operations_research.lattle.LogisticsNetwork.vehicles)
  return _internal_mutable_vehicles();
}

// map<string, .operations_research.lattle.Hub> hubs = 4;
inline int LogisticsNetwork::_internal_hubs_size() const {
  return _impl_.hubs_.size();
}
inline int LogisticsNetwork::hubs_size() const {
  return _internal_hubs_size();
}
inline void LogisticsNetwork::clear_hubs() {
  _impl_.hubs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Hub >&
LogisticsNetwork::_internal_hubs() const {
  return _impl_.hubs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Hub >&
LogisticsNetwork::hubs() const {
  // @@protoc_insertion_point(field_map:operations_research.lattle.LogisticsNetwork.hubs)
  return _internal_hubs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Hub >*
LogisticsNetwork::_internal_mutable_hubs() {
  return _impl_.hubs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::Hub >*
LogisticsNetwork::mutable_hubs() {
  // @@protoc_insertion_point(field_mutable_map:operations_research.lattle.LogisticsNetwork.hubs)
  return _internal_mutable_hubs();
}

// repeated .operations_research.lattle.ValueDimension dimensions = 5;
inline int LogisticsNetwork::_internal_dimensions_size() const {
  return _impl_.dimensions_.size();
}
inline int LogisticsNetwork::dimensions_size() const {
  return _internal_dimensions_size();
}
inline void LogisticsNetwork::clear_dimensions() {
  _impl_.dimensions_.Clear();
}
inline ::operations_research::lattle::ValueDimension* LogisticsNetwork::mutable_dimensions(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LogisticsNetwork.dimensions)
  return _impl_.dimensions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >*
LogisticsNetwork::mutable_dimensions() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.lattle.LogisticsNetwork.dimensions)
  return &_impl_.dimensions_;
}
inline const ::operations_research::lattle::ValueDimension& LogisticsNetwork::_internal_dimensions(int index) const {
  return _impl_.dimensions_.Get(index);
}
inline const ::operations_research::lattle::ValueDimension& LogisticsNetwork::dimensions(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LogisticsNetwork.dimensions)
  return _internal_dimensions(index);
}
inline ::operations_research::lattle::ValueDimension* LogisticsNetwork::_internal_add_dimensions() {
  return _impl_.dimensions_.Add();
}
inline ::operations_research::lattle::ValueDimension* LogisticsNetwork::add_dimensions() {
  ::operations_research::lattle::ValueDimension* _add = _internal_add_dimensions();
  // @@protoc_insertion_point(field_add:operations_research.lattle.LogisticsNetwork.dimensions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >&
LogisticsNetwork::dimensions() const {
  // @@protoc_insertion_point(field_list:operations_research.lattle.LogisticsNetwork.dimensions)
  return _impl_.dimensions_;
}

// .operations_research.lattle.PricingStrategy pricing = 6;
inline bool LogisticsNetwork::_internal_has_pricing() const {
  return this != internal_default_instance() && _impl_.pricing_ != nullptr;
}
inline bool LogisticsNetwork::has_pricing() const {
  return _internal_has_pricing();
}
inline void LogisticsNetwork::clear_pricing() {
  if (GetArenaForAllocation() == nullptr && _impl_.pricing_ != nullptr) {
    delete _impl_.pricing_;
  }
  _impl_.pricing_ = nullptr;
}
inline const ::operations_research::lattle::PricingStrategy& LogisticsNetwork::_internal_pricing() const {
  const ::operations_research::lattle::PricingStrategy* p = _impl_.pricing_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::lattle::PricingStrategy&>(
      ::operations_research::lattle::_PricingStrategy_default_instance_);
}
inline const ::operations_research::lattle::PricingStrategy& LogisticsNetwork::pricing() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LogisticsNetwork.pricing)
  return _internal_pricing();
}
inline void LogisticsNetwork::unsafe_arena_set_allocated_pricing(
    ::operations_research::lattle::PricingStrategy* pricing) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pricing_);
  }
  _impl_.pricing_ = pricing;
  if (pricing) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.LogisticsNetwork.pricing)
}
inline ::operations_research::lattle::PricingStrategy* LogisticsNetwork::release_pricing() {
  
  ::operations_research::lattle::PricingStrategy* temp = _impl_.pricing_;
  _impl_.pricing_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::operations_research::lattle::PricingStrategy* LogisticsNetwork::unsafe_arena_release_pricing() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.LogisticsNetwork.pricing)
  
  ::operations_research::lattle::PricingStrategy* temp = _impl_.pricing_;
  _impl_.pricing_ = nullptr;
  return temp;
}
inline ::operations_research::lattle::PricingStrategy* LogisticsNetwork::_internal_mutable_pricing() {
  
  if (_impl_.pricing_ == nullptr) {
    auto* p = CreateMaybeMessage<::operations_research::lattle::PricingStrategy>(GetArenaForAllocation());
    _impl_.pricing_ = p;
  }
  return _impl_.pricing_;
}
inline ::operations_research::lattle::PricingStrategy* LogisticsNetwork::mutable_pricing() {
  ::operations_research::lattle::PricingStrategy* _msg = _internal_mutable_pricing();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LogisticsNetwork.pricing)
  return _msg;
}
inline void LogisticsNetwork::set_allocated_pricing(::operations_research::lattle::PricingStrategy* pricing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pricing_;
  }
  if (pricing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pricing);
    if (message_arena != submessage_arena) {
      pricing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pricing, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pricing_ = pricing;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.LogisticsNetwork.pricing)
}

// string currency_code = 7;
inline void LogisticsNetwork::clear_currency_code() {
  _impl_.currency_code_.ClearToEmpty();
}
inline const std::string& LogisticsNetwork::currency_code() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LogisticsNetwork.currency_code)
  return _internal_currency_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogisticsNetwork::set_currency_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.currency_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.LogisticsNetwork.currency_code)
}
inline std::string* LogisticsNetwork::mutable_currency_code() {
  std::string* _s = _internal_mutable_currency_code();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LogisticsNetwork.currency_code)
  return _s;
}
inline const std::string& LogisticsNetwork::_internal_currency_code() const {
  return _impl_.currency_code_.Get();
}
inline void LogisticsNetwork::_internal_set_currency_code(const std::string& value) {
  
  _impl_.currency_code_.Set(value, GetArenaForAllocation());
}
inline std::string* LogisticsNetwork::_internal_mutable_currency_code() {
  
  return _impl_.currency_code_.Mutable(GetArenaForAllocation());
}
inline std::string* LogisticsNetwork::release_currency_code() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.LogisticsNetwork.currency_code)
  return _impl_.currency_code_.Release();
}
inline void LogisticsNetwork::set_allocated_currency_code(std::string* currency_code) {
  if (currency_code != nullptr) {
    
  } else {
    
  }
  _impl_.currency_code_.SetAllocated(currency_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currency_code_.IsDefault()) {
    _impl_.currency_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.LogisticsNetwork.currency_code)
}

// .google.protobuf.Duration time_step = 8;
inline bool LogisticsNetwork::_internal_has_time_step() const {
  return this != internal_default_instance() && _impl_.time_step_ != nullptr;
}
inline bool LogisticsNetwork::has_time_step() const {
  return _internal_has_time_step();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& LogisticsNetwork::_internal_time_step() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.time_step_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& LogisticsNetwork::time_step() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LogisticsNetwork.time_step)
  return _internal_time_step();
}
inline void LogisticsNetwork::unsafe_arena_set_allocated_time_step(
    ::PROTOBUF_NAMESPACE_ID::Duration* time_step) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_step_);
  }
  _impl_.time_step_ = time_step;
  if (time_step) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.LogisticsNetwork.time_step)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* LogisticsNetwork::release_time_step() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.time_step_;
  _impl_.time_step_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* LogisticsNetwork::unsafe_arena_release_time_step() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.LogisticsNetwork.time_step)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.time_step_;
  _impl_.time_step_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* LogisticsNetwork::_internal_mutable_time_step() {
  
  if (_impl_.time_step_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.time_step_ = p;
  }
  return _impl_.time_step_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* LogisticsNetwork::mutable_time_step() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_time_step();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LogisticsNetwork.time_step)
  return _msg;
}
inline void LogisticsNetwork::set_allocated_time_step(::PROTOBUF_NAMESPACE_ID::Duration* time_step) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_step_);
  }
  if (time_step) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_step));
    if (message_arena != submessage_arena) {
      time_step = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_step, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_step_ = time_step;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.LogisticsNetwork.time_step)
}

// repeated .operations_research.lattle.DistanceMatrixEntry distance_matrix = 9;
inline int LogisticsNetwork::_internal_distance_matrix_size() const {
  return _impl_.distance_matrix_.size();
}
inline int LogisticsNetwork::distance_matrix_size() const {
  return _internal_distance_matrix_size();
}
inline void LogisticsNetwork::clear_distance_matrix() {
  _impl_.distance_matrix_.Clear();
}
inline ::operations_research::lattle::DistanceMatrixEntry* LogisticsNetwork::mutable_distance_matrix(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LogisticsNetwork.distance_matrix)
  return _impl_.distance_matrix_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::DistanceMatrixEntry >*
LogisticsNetwork::mutable_distance_matrix() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.lattle.LogisticsNetwork.distance_matrix)
  return &_impl_.distance_matrix_;
}
inline const ::operations_research::lattle::DistanceMatrixEntry& LogisticsNetwork::_internal_distance_matrix(int index) const {
  return _impl_.distance_matrix_.Get(index);
}
inline const ::operations_research::lattle::DistanceMatrixEntry& LogisticsNetwork::distance_matrix(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LogisticsNetwork.distance_matrix)
  return _internal_distance_matrix(index);
}
inline ::operations_research::lattle::DistanceMatrixEntry* LogisticsNetwork::_internal_add_distance_matrix() {
  return _impl_.distance_matrix_.Add();
}
inline ::operations_research::lattle::DistanceMatrixEntry* LogisticsNetwork::add_distance_matrix() {
  ::operations_research::lattle::DistanceMatrixEntry* _add = _internal_add_distance_matrix();
  // @@protoc_insertion_point(field_add:operations_research.lattle.LogisticsNetwork.distance_matrix)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::DistanceMatrixEntry >&
LogisticsNetwork::distance_matrix() const {
  // @@protoc_insertion_point(field_list:operations_research.lattle.LogisticsNetwork.distance_matrix)
  return _impl_.distance_matrix_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Line

// repeated string hub_ids = 1;
inline int Line::_internal_hub_ids_size() const {
  return _impl_.hub_ids_.size();
}
inline int Line::hub_ids_size() const {
  return _internal_hub_ids_size();
}
inline void Line::clear_hub_ids() {
  _impl_.hub_ids_.Clear();
}
inline std::string* Line::add_hub_ids() {
  std::string* _s = _internal_add_hub_ids();
  // @@protoc_insertion_point(field_add_mutable:operations_research.lattle.Line.hub_ids)
  return _s;
}
inline const std::string& Line::_internal_hub_ids(int index) const {
  return _impl_.hub_ids_.Get(index);
}
inline const std::string& Line::hub_ids(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Line.hub_ids)
  return _internal_hub_ids(index);
}
inline std::string* Line::mutable_hub_ids(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.Line.hub_ids)
  return _impl_.hub_ids_.Mutable(index);
}
inline void Line::set_hub_ids(int index, const std::string& value) {
  _impl_.hub_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.Line.hub_ids)
}
inline void Line::set_hub_ids(int index, std::string&& value) {
  _impl_.hub_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:operations_research.lattle.Line.hub_ids)
}
inline void Line::set_hub_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.hub_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:operations_research.lattle.Line.hub_ids)
}
inline void Line::set_hub_ids(int index, const char* value, size_t size) {
  _impl_.hub_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:operations_research.lattle.Line.hub_ids)
}
inline std::string* Line::_internal_add_hub_ids() {
  return _impl_.hub_ids_.Add();
}
inline void Line::add_hub_ids(const std::string& value) {
  _impl_.hub_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:operations_research.lattle.Line.hub_ids)
}
inline void Line::add_hub_ids(std::string&& value) {
  _impl_.hub_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:operations_research.lattle.Line.hub_ids)
}
inline void Line::add_hub_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.hub_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:operations_research.lattle.Line.hub_ids)
}
inline void Line::add_hub_ids(const char* value, size_t size) {
  _impl_.hub_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:operations_research.lattle.Line.hub_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Line::hub_ids() const {
  // @@protoc_insertion_point(field_list:operations_research.lattle.Line.hub_ids)
  return _impl_.hub_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Line::mutable_hub_ids() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.lattle.Line.hub_ids)
  return &_impl_.hub_ids_;
}

// map<string, .operations_research.lattle.LineRotation> next_rotations = 2;
inline int Line::_internal_next_rotations_size() const {
  return _impl_.next_rotations_.size();
}
inline int Line::next_rotations_size() const {
  return _internal_next_rotations_size();
}
inline void Line::clear_next_rotations() {
  _impl_.next_rotations_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::LineRotation >&
Line::_internal_next_rotations() const {
  return _impl_.next_rotations_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::LineRotation >&
Line::next_rotations() const {
  // @@protoc_insertion_point(field_map:operations_research.lattle.Line.next_rotations)
  return _internal_next_rotations();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::LineRotation >*
Line::_internal_mutable_next_rotations() {
  return _impl_.next_rotations_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::LineRotation >*
Line::mutable_next_rotations() {
  // @@protoc_insertion_point(field_mutable_map:operations_research.lattle.Line.next_rotations)
  return _internal_mutable_next_rotations();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GeneratedLineAndRotation

// map<string, .google.type.DateTime> arrival_times = 1;
inline int GeneratedLineAndRotation::_internal_arrival_times_size() const {
  return _impl_.arrival_times_.size();
}
inline int GeneratedLineAndRotation::arrival_times_size() const {
  return _internal_arrival_times_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::type::DateTime >&
GeneratedLineAndRotation::_internal_arrival_times() const {
  return _impl_.arrival_times_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::type::DateTime >&
GeneratedLineAndRotation::arrival_times() const {
  // @@protoc_insertion_point(field_map:operations_research.lattle.GeneratedLineAndRotation.arrival_times)
  return _internal_arrival_times();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::type::DateTime >*
GeneratedLineAndRotation::_internal_mutable_arrival_times() {
  return _impl_.arrival_times_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::type::DateTime >*
GeneratedLineAndRotation::mutable_arrival_times() {
  // @@protoc_insertion_point(field_mutable_map:operations_research.lattle.GeneratedLineAndRotation.arrival_times)
  return _internal_mutable_arrival_times();
}

// map<string, .google.type.DateTime> departure_times = 2;
inline int GeneratedLineAndRotation::_internal_departure_times_size() const {
  return _impl_.departure_times_.size();
}
inline int GeneratedLineAndRotation::departure_times_size() const {
  return _internal_departure_times_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::type::DateTime >&
GeneratedLineAndRotation::_internal_departure_times() const {
  return _impl_.departure_times_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::type::DateTime >&
GeneratedLineAndRotation::departure_times() const {
  // @@protoc_insertion_point(field_map:operations_research.lattle.GeneratedLineAndRotation.departure_times)
  return _internal_departure_times();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::type::DateTime >*
GeneratedLineAndRotation::_internal_mutable_departure_times() {
  return _impl_.departure_times_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::type::DateTime >*
GeneratedLineAndRotation::mutable_departure_times() {
  // @@protoc_insertion_point(field_mutable_map:operations_research.lattle.GeneratedLineAndRotation.departure_times)
  return _internal_mutable_departure_times();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LineRotation

// map<string, .operations_research.lattle.DateTimeRange> arrival_times = 1;
inline int LineRotation::_internal_arrival_times_size() const {
  return _impl_.arrival_times_.size();
}
inline int LineRotation::arrival_times_size() const {
  return _internal_arrival_times_size();
}
inline void LineRotation::clear_arrival_times() {
  _impl_.arrival_times_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::DateTimeRange >&
LineRotation::_internal_arrival_times() const {
  return _impl_.arrival_times_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::DateTimeRange >&
LineRotation::arrival_times() const {
  // @@protoc_insertion_point(field_map:operations_research.lattle.LineRotation.arrival_times)
  return _internal_arrival_times();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::DateTimeRange >*
LineRotation::_internal_mutable_arrival_times() {
  return _impl_.arrival_times_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::DateTimeRange >*
LineRotation::mutable_arrival_times() {
  // @@protoc_insertion_point(field_mutable_map:operations_research.lattle.LineRotation.arrival_times)
  return _internal_mutable_arrival_times();
}

// map<string, .operations_research.lattle.DateTimeRange> departure_times = 2;
inline int LineRotation::_internal_departure_times_size() const {
  return _impl_.departure_times_.size();
}
inline int LineRotation::departure_times_size() const {
  return _internal_departure_times_size();
}
inline void LineRotation::clear_departure_times() {
  _impl_.departure_times_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::DateTimeRange >&
LineRotation::_internal_departure_times() const {
  return _impl_.departure_times_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::DateTimeRange >&
LineRotation::departure_times() const {
  // @@protoc_insertion_point(field_map:operations_research.lattle.LineRotation.departure_times)
  return _internal_departure_times();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::DateTimeRange >*
LineRotation::_internal_mutable_departure_times() {
  return _impl_.departure_times_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::DateTimeRange >*
LineRotation::mutable_departure_times() {
  // @@protoc_insertion_point(field_mutable_map:operations_research.lattle.LineRotation.departure_times)
  return _internal_mutable_departure_times();
}

// map<string, .operations_research.lattle.EarlinessTardiness> starting_earliness_tardiness_costs = 3;
inline int LineRotation::_internal_starting_earliness_tardiness_costs_size() const {
  return _impl_.starting_earliness_tardiness_costs_.size();
}
inline int LineRotation::starting_earliness_tardiness_costs_size() const {
  return _internal_starting_earliness_tardiness_costs_size();
}
inline void LineRotation::clear_starting_earliness_tardiness_costs() {
  _impl_.starting_earliness_tardiness_costs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::EarlinessTardiness >&
LineRotation::_internal_starting_earliness_tardiness_costs() const {
  return _impl_.starting_earliness_tardiness_costs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::EarlinessTardiness >&
LineRotation::starting_earliness_tardiness_costs() const {
  // @@protoc_insertion_point(field_map:operations_research.lattle.LineRotation.starting_earliness_tardiness_costs)
  return _internal_starting_earliness_tardiness_costs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::EarlinessTardiness >*
LineRotation::_internal_mutable_starting_earliness_tardiness_costs() {
  return _impl_.starting_earliness_tardiness_costs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::EarlinessTardiness >*
LineRotation::mutable_starting_earliness_tardiness_costs() {
  // @@protoc_insertion_point(field_mutable_map:operations_research.lattle.LineRotation.starting_earliness_tardiness_costs)
  return _internal_mutable_starting_earliness_tardiness_costs();
}

// map<string, .operations_research.lattle.EarlinessTardiness> arrival_earliness_tardiness_costs = 4;
inline int LineRotation::_internal_arrival_earliness_tardiness_costs_size() const {
  return _impl_.arrival_earliness_tardiness_costs_.size();
}
inline int LineRotation::arrival_earliness_tardiness_costs_size() const {
  return _internal_arrival_earliness_tardiness_costs_size();
}
inline void LineRotation::clear_arrival_earliness_tardiness_costs() {
  _impl_.arrival_earliness_tardiness_costs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::EarlinessTardiness >&
LineRotation::_internal_arrival_earliness_tardiness_costs() const {
  return _impl_.arrival_earliness_tardiness_costs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::EarlinessTardiness >&
LineRotation::arrival_earliness_tardiness_costs() const {
  // @@protoc_insertion_point(field_map:operations_research.lattle.LineRotation.arrival_earliness_tardiness_costs)
  return _internal_arrival_earliness_tardiness_costs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::EarlinessTardiness >*
LineRotation::_internal_mutable_arrival_earliness_tardiness_costs() {
  return _impl_.arrival_earliness_tardiness_costs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::operations_research::lattle::EarlinessTardiness >*
LineRotation::mutable_arrival_earliness_tardiness_costs() {
  // @@protoc_insertion_point(field_mutable_map:operations_research.lattle.LineRotation.arrival_earliness_tardiness_costs)
  return _internal_mutable_arrival_earliness_tardiness_costs();
}

// optional .operations_research.lattle.IntegerRange maximum_number_vehicles = 5;
inline bool LineRotation::_internal_has_maximum_number_vehicles() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.maximum_number_vehicles_ != nullptr);
  return value;
}
inline bool LineRotation::has_maximum_number_vehicles() const {
  return _internal_has_maximum_number_vehicles();
}
inline void LineRotation::clear_maximum_number_vehicles() {
  if (_impl_.maximum_number_vehicles_ != nullptr) _impl_.maximum_number_vehicles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::operations_research::lattle::IntegerRange& LineRotation::_internal_maximum_number_vehicles() const {
  const ::operations_research::lattle::IntegerRange* p = _impl_.maximum_number_vehicles_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::lattle::IntegerRange&>(
      ::operations_research::lattle::_IntegerRange_default_instance_);
}
inline const ::operations_research::lattle::IntegerRange& LineRotation::maximum_number_vehicles() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LineRotation.maximum_number_vehicles)
  return _internal_maximum_number_vehicles();
}
inline void LineRotation::unsafe_arena_set_allocated_maximum_number_vehicles(
    ::operations_research::lattle::IntegerRange* maximum_number_vehicles) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.maximum_number_vehicles_);
  }
  _impl_.maximum_number_vehicles_ = maximum_number_vehicles;
  if (maximum_number_vehicles) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.LineRotation.maximum_number_vehicles)
}
inline ::operations_research::lattle::IntegerRange* LineRotation::release_maximum_number_vehicles() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::operations_research::lattle::IntegerRange* temp = _impl_.maximum_number_vehicles_;
  _impl_.maximum_number_vehicles_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::operations_research::lattle::IntegerRange* LineRotation::unsafe_arena_release_maximum_number_vehicles() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.LineRotation.maximum_number_vehicles)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::operations_research::lattle::IntegerRange* temp = _impl_.maximum_number_vehicles_;
  _impl_.maximum_number_vehicles_ = nullptr;
  return temp;
}
inline ::operations_research::lattle::IntegerRange* LineRotation::_internal_mutable_maximum_number_vehicles() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.maximum_number_vehicles_ == nullptr) {
    auto* p = CreateMaybeMessage<::operations_research::lattle::IntegerRange>(GetArenaForAllocation());
    _impl_.maximum_number_vehicles_ = p;
  }
  return _impl_.maximum_number_vehicles_;
}
inline ::operations_research::lattle::IntegerRange* LineRotation::mutable_maximum_number_vehicles() {
  ::operations_research::lattle::IntegerRange* _msg = _internal_mutable_maximum_number_vehicles();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LineRotation.maximum_number_vehicles)
  return _msg;
}
inline void LineRotation::set_allocated_maximum_number_vehicles(::operations_research::lattle::IntegerRange* maximum_number_vehicles) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.maximum_number_vehicles_;
  }
  if (maximum_number_vehicles) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(maximum_number_vehicles);
    if (message_arena != submessage_arena) {
      maximum_number_vehicles = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maximum_number_vehicles, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.maximum_number_vehicles_ = maximum_number_vehicles;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.LineRotation.maximum_number_vehicles)
}

// repeated string vehicles = 6;
inline int LineRotation::_internal_vehicles_size() const {
  return _impl_.vehicles_.size();
}
inline int LineRotation::vehicles_size() const {
  return _internal_vehicles_size();
}
inline void LineRotation::clear_vehicles() {
  _impl_.vehicles_.Clear();
}
inline std::string* LineRotation::add_vehicles() {
  std::string* _s = _internal_add_vehicles();
  // @@protoc_insertion_point(field_add_mutable:operations_research.lattle.LineRotation.vehicles)
  return _s;
}
inline const std::string& LineRotation::_internal_vehicles(int index) const {
  return _impl_.vehicles_.Get(index);
}
inline const std::string& LineRotation::vehicles(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LineRotation.vehicles)
  return _internal_vehicles(index);
}
inline std::string* LineRotation::mutable_vehicles(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LineRotation.vehicles)
  return _impl_.vehicles_.Mutable(index);
}
inline void LineRotation::set_vehicles(int index, const std::string& value) {
  _impl_.vehicles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.LineRotation.vehicles)
}
inline void LineRotation::set_vehicles(int index, std::string&& value) {
  _impl_.vehicles_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:operations_research.lattle.LineRotation.vehicles)
}
inline void LineRotation::set_vehicles(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.vehicles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:operations_research.lattle.LineRotation.vehicles)
}
inline void LineRotation::set_vehicles(int index, const char* value, size_t size) {
  _impl_.vehicles_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:operations_research.lattle.LineRotation.vehicles)
}
inline std::string* LineRotation::_internal_add_vehicles() {
  return _impl_.vehicles_.Add();
}
inline void LineRotation::add_vehicles(const std::string& value) {
  _impl_.vehicles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:operations_research.lattle.LineRotation.vehicles)
}
inline void LineRotation::add_vehicles(std::string&& value) {
  _impl_.vehicles_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:operations_research.lattle.LineRotation.vehicles)
}
inline void LineRotation::add_vehicles(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.vehicles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:operations_research.lattle.LineRotation.vehicles)
}
inline void LineRotation::add_vehicles(const char* value, size_t size) {
  _impl_.vehicles_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:operations_research.lattle.LineRotation.vehicles)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LineRotation::vehicles() const {
  // @@protoc_insertion_point(field_list:operations_research.lattle.LineRotation.vehicles)
  return _impl_.vehicles_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LineRotation::mutable_vehicles() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.lattle.LineRotation.vehicles)
  return &_impl_.vehicles_;
}

// .operations_research.lattle.PricingStrategy fixed_price = 7;
inline bool LineRotation::_internal_has_fixed_price() const {
  return this != internal_default_instance() && _impl_.fixed_price_ != nullptr;
}
inline bool LineRotation::has_fixed_price() const {
  return _internal_has_fixed_price();
}
inline void LineRotation::clear_fixed_price() {
  if (GetArenaForAllocation() == nullptr && _impl_.fixed_price_ != nullptr) {
    delete _impl_.fixed_price_;
  }
  _impl_.fixed_price_ = nullptr;
}
inline const ::operations_research::lattle::PricingStrategy& LineRotation::_internal_fixed_price() const {
  const ::operations_research::lattle::PricingStrategy* p = _impl_.fixed_price_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::lattle::PricingStrategy&>(
      ::operations_research::lattle::_PricingStrategy_default_instance_);
}
inline const ::operations_research::lattle::PricingStrategy& LineRotation::fixed_price() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LineRotation.fixed_price)
  return _internal_fixed_price();
}
inline void LineRotation::unsafe_arena_set_allocated_fixed_price(
    ::operations_research::lattle::PricingStrategy* fixed_price) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fixed_price_);
  }
  _impl_.fixed_price_ = fixed_price;
  if (fixed_price) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.LineRotation.fixed_price)
}
inline ::operations_research::lattle::PricingStrategy* LineRotation::release_fixed_price() {
  
  ::operations_research::lattle::PricingStrategy* temp = _impl_.fixed_price_;
  _impl_.fixed_price_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::operations_research::lattle::PricingStrategy* LineRotation::unsafe_arena_release_fixed_price() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.LineRotation.fixed_price)
  
  ::operations_research::lattle::PricingStrategy* temp = _impl_.fixed_price_;
  _impl_.fixed_price_ = nullptr;
  return temp;
}
inline ::operations_research::lattle::PricingStrategy* LineRotation::_internal_mutable_fixed_price() {
  
  if (_impl_.fixed_price_ == nullptr) {
    auto* p = CreateMaybeMessage<::operations_research::lattle::PricingStrategy>(GetArenaForAllocation());
    _impl_.fixed_price_ = p;
  }
  return _impl_.fixed_price_;
}
inline ::operations_research::lattle::PricingStrategy* LineRotation::mutable_fixed_price() {
  ::operations_research::lattle::PricingStrategy* _msg = _internal_mutable_fixed_price();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LineRotation.fixed_price)
  return _msg;
}
inline void LineRotation::set_allocated_fixed_price(::operations_research::lattle::PricingStrategy* fixed_price) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fixed_price_;
  }
  if (fixed_price) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fixed_price);
    if (message_arena != submessage_arena) {
      fixed_price = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fixed_price, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fixed_price_ = fixed_price;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.LineRotation.fixed_price)
}

// -------------------------------------------------------------------

// EarlinessTardiness

// optional .google.protobuf.Duration maximum_earliness = 1;
inline bool EarlinessTardiness::_internal_has_maximum_earliness() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.maximum_earliness_ != nullptr);
  return value;
}
inline bool EarlinessTardiness::has_maximum_earliness() const {
  return _internal_has_maximum_earliness();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& EarlinessTardiness::_internal_maximum_earliness() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.maximum_earliness_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& EarlinessTardiness::maximum_earliness() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.EarlinessTardiness.maximum_earliness)
  return _internal_maximum_earliness();
}
inline void EarlinessTardiness::unsafe_arena_set_allocated_maximum_earliness(
    ::PROTOBUF_NAMESPACE_ID::Duration* maximum_earliness) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.maximum_earliness_);
  }
  _impl_.maximum_earliness_ = maximum_earliness;
  if (maximum_earliness) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.EarlinessTardiness.maximum_earliness)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* EarlinessTardiness::release_maximum_earliness() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.maximum_earliness_;
  _impl_.maximum_earliness_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* EarlinessTardiness::unsafe_arena_release_maximum_earliness() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.EarlinessTardiness.maximum_earliness)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.maximum_earliness_;
  _impl_.maximum_earliness_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* EarlinessTardiness::_internal_mutable_maximum_earliness() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.maximum_earliness_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.maximum_earliness_ = p;
  }
  return _impl_.maximum_earliness_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* EarlinessTardiness::mutable_maximum_earliness() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_maximum_earliness();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.EarlinessTardiness.maximum_earliness)
  return _msg;
}
inline void EarlinessTardiness::set_allocated_maximum_earliness(::PROTOBUF_NAMESPACE_ID::Duration* maximum_earliness) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.maximum_earliness_);
  }
  if (maximum_earliness) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(maximum_earliness));
    if (message_arena != submessage_arena) {
      maximum_earliness = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maximum_earliness, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.maximum_earliness_ = maximum_earliness;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.EarlinessTardiness.maximum_earliness)
}

// optional .google.protobuf.Duration maximum_tardiness = 2;
inline bool EarlinessTardiness::_internal_has_maximum_tardiness() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.maximum_tardiness_ != nullptr);
  return value;
}
inline bool EarlinessTardiness::has_maximum_tardiness() const {
  return _internal_has_maximum_tardiness();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& EarlinessTardiness::_internal_maximum_tardiness() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.maximum_tardiness_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& EarlinessTardiness::maximum_tardiness() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.EarlinessTardiness.maximum_tardiness)
  return _internal_maximum_tardiness();
}
inline void EarlinessTardiness::unsafe_arena_set_allocated_maximum_tardiness(
    ::PROTOBUF_NAMESPACE_ID::Duration* maximum_tardiness) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.maximum_tardiness_);
  }
  _impl_.maximum_tardiness_ = maximum_tardiness;
  if (maximum_tardiness) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.EarlinessTardiness.maximum_tardiness)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* EarlinessTardiness::release_maximum_tardiness() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.maximum_tardiness_;
  _impl_.maximum_tardiness_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* EarlinessTardiness::unsafe_arena_release_maximum_tardiness() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.EarlinessTardiness.maximum_tardiness)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.maximum_tardiness_;
  _impl_.maximum_tardiness_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* EarlinessTardiness::_internal_mutable_maximum_tardiness() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.maximum_tardiness_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.maximum_tardiness_ = p;
  }
  return _impl_.maximum_tardiness_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* EarlinessTardiness::mutable_maximum_tardiness() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_maximum_tardiness();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.EarlinessTardiness.maximum_tardiness)
  return _msg;
}
inline void EarlinessTardiness::set_allocated_maximum_tardiness(::PROTOBUF_NAMESPACE_ID::Duration* maximum_tardiness) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.maximum_tardiness_);
  }
  if (maximum_tardiness) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(maximum_tardiness));
    if (message_arena != submessage_arena) {
      maximum_tardiness = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maximum_tardiness, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.maximum_tardiness_ = maximum_tardiness;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.EarlinessTardiness.maximum_tardiness)
}

// optional .operations_research.lattle.Function1D earliness_cost = 3;
inline bool EarlinessTardiness::_internal_has_earliness_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.earliness_cost_ != nullptr);
  return value;
}
inline bool EarlinessTardiness::has_earliness_cost() const {
  return _internal_has_earliness_cost();
}
inline void EarlinessTardiness::clear_earliness_cost() {
  if (_impl_.earliness_cost_ != nullptr) _impl_.earliness_cost_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::operations_research::lattle::Function1D& EarlinessTardiness::_internal_earliness_cost() const {
  const ::operations_research::lattle::Function1D* p = _impl_.earliness_cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::lattle::Function1D&>(
      ::operations_research::lattle::_Function1D_default_instance_);
}
inline const ::operations_research::lattle::Function1D& EarlinessTardiness::earliness_cost() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.EarlinessTardiness.earliness_cost)
  return _internal_earliness_cost();
}
inline void EarlinessTardiness::unsafe_arena_set_allocated_earliness_cost(
    ::operations_research::lattle::Function1D* earliness_cost) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.earliness_cost_);
  }
  _impl_.earliness_cost_ = earliness_cost;
  if (earliness_cost) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.EarlinessTardiness.earliness_cost)
}
inline ::operations_research::lattle::Function1D* EarlinessTardiness::release_earliness_cost() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::operations_research::lattle::Function1D* temp = _impl_.earliness_cost_;
  _impl_.earliness_cost_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::operations_research::lattle::Function1D* EarlinessTardiness::unsafe_arena_release_earliness_cost() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.EarlinessTardiness.earliness_cost)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::operations_research::lattle::Function1D* temp = _impl_.earliness_cost_;
  _impl_.earliness_cost_ = nullptr;
  return temp;
}
inline ::operations_research::lattle::Function1D* EarlinessTardiness::_internal_mutable_earliness_cost() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.earliness_cost_ == nullptr) {
    auto* p = CreateMaybeMessage<::operations_research::lattle::Function1D>(GetArenaForAllocation());
    _impl_.earliness_cost_ = p;
  }
  return _impl_.earliness_cost_;
}
inline ::operations_research::lattle::Function1D* EarlinessTardiness::mutable_earliness_cost() {
  ::operations_research::lattle::Function1D* _msg = _internal_mutable_earliness_cost();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.EarlinessTardiness.earliness_cost)
  return _msg;
}
inline void EarlinessTardiness::set_allocated_earliness_cost(::operations_research::lattle::Function1D* earliness_cost) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.earliness_cost_;
  }
  if (earliness_cost) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(earliness_cost);
    if (message_arena != submessage_arena) {
      earliness_cost = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, earliness_cost, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.earliness_cost_ = earliness_cost;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.EarlinessTardiness.earliness_cost)
}

// optional .operations_research.lattle.Function1D tardiness_cost = 4;
inline bool EarlinessTardiness::_internal_has_tardiness_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tardiness_cost_ != nullptr);
  return value;
}
inline bool EarlinessTardiness::has_tardiness_cost() const {
  return _internal_has_tardiness_cost();
}
inline void EarlinessTardiness::clear_tardiness_cost() {
  if (_impl_.tardiness_cost_ != nullptr) _impl_.tardiness_cost_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::operations_research::lattle::Function1D& EarlinessTardiness::_internal_tardiness_cost() const {
  const ::operations_research::lattle::Function1D* p = _impl_.tardiness_cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::lattle::Function1D&>(
      ::operations_research::lattle::_Function1D_default_instance_);
}
inline const ::operations_research::lattle::Function1D& EarlinessTardiness::tardiness_cost() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.EarlinessTardiness.tardiness_cost)
  return _internal_tardiness_cost();
}
inline void EarlinessTardiness::unsafe_arena_set_allocated_tardiness_cost(
    ::operations_research::lattle::Function1D* tardiness_cost) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tardiness_cost_);
  }
  _impl_.tardiness_cost_ = tardiness_cost;
  if (tardiness_cost) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.EarlinessTardiness.tardiness_cost)
}
inline ::operations_research::lattle::Function1D* EarlinessTardiness::release_tardiness_cost() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::operations_research::lattle::Function1D* temp = _impl_.tardiness_cost_;
  _impl_.tardiness_cost_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::operations_research::lattle::Function1D* EarlinessTardiness::unsafe_arena_release_tardiness_cost() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.EarlinessTardiness.tardiness_cost)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::operations_research::lattle::Function1D* temp = _impl_.tardiness_cost_;
  _impl_.tardiness_cost_ = nullptr;
  return temp;
}
inline ::operations_research::lattle::Function1D* EarlinessTardiness::_internal_mutable_tardiness_cost() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.tardiness_cost_ == nullptr) {
    auto* p = CreateMaybeMessage<::operations_research::lattle::Function1D>(GetArenaForAllocation());
    _impl_.tardiness_cost_ = p;
  }
  return _impl_.tardiness_cost_;
}
inline ::operations_research::lattle::Function1D* EarlinessTardiness::mutable_tardiness_cost() {
  ::operations_research::lattle::Function1D* _msg = _internal_mutable_tardiness_cost();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.EarlinessTardiness.tardiness_cost)
  return _msg;
}
inline void EarlinessTardiness::set_allocated_tardiness_cost(::operations_research::lattle::Function1D* tardiness_cost) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tardiness_cost_;
  }
  if (tardiness_cost) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tardiness_cost);
    if (message_arena != submessage_arena) {
      tardiness_cost = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tardiness_cost, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.tardiness_cost_ = tardiness_cost;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.EarlinessTardiness.tardiness_cost)
}

// -------------------------------------------------------------------

// Vehicle

// optional string current_position_hub = 1;
inline bool Vehicle::_internal_has_current_position_hub() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Vehicle::has_current_position_hub() const {
  return _internal_has_current_position_hub();
}
inline void Vehicle::clear_current_position_hub() {
  _impl_.current_position_hub_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Vehicle::current_position_hub() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Vehicle.current_position_hub)
  return _internal_current_position_hub();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Vehicle::set_current_position_hub(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.current_position_hub_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.Vehicle.current_position_hub)
}
inline std::string* Vehicle::mutable_current_position_hub() {
  std::string* _s = _internal_mutable_current_position_hub();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.Vehicle.current_position_hub)
  return _s;
}
inline const std::string& Vehicle::_internal_current_position_hub() const {
  return _impl_.current_position_hub_.Get();
}
inline void Vehicle::_internal_set_current_position_hub(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.current_position_hub_.Set(value, GetArenaForAllocation());
}
inline std::string* Vehicle::_internal_mutable_current_position_hub() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.current_position_hub_.Mutable(GetArenaForAllocation());
}
inline std::string* Vehicle::release_current_position_hub() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.Vehicle.current_position_hub)
  if (!_internal_has_current_position_hub()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.current_position_hub_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.current_position_hub_.IsDefault()) {
    _impl_.current_position_hub_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Vehicle::set_allocated_current_position_hub(std::string* current_position_hub) {
  if (current_position_hub != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.current_position_hub_.SetAllocated(current_position_hub, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.current_position_hub_.IsDefault()) {
    _impl_.current_position_hub_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.Vehicle.current_position_hub)
}

// bool refrigerated = 2;
inline void Vehicle::clear_refrigerated() {
  _impl_.refrigerated_ = false;
}
inline bool Vehicle::_internal_refrigerated() const {
  return _impl_.refrigerated_;
}
inline bool Vehicle::refrigerated() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Vehicle.refrigerated)
  return _internal_refrigerated();
}
inline void Vehicle::_internal_set_refrigerated(bool value) {
  
  _impl_.refrigerated_ = value;
}
inline void Vehicle::set_refrigerated(bool value) {
  _internal_set_refrigerated(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.Vehicle.refrigerated)
}

// repeated .operations_research.lattle.ValueDimension capacities = 3;
inline int Vehicle::_internal_capacities_size() const {
  return _impl_.capacities_.size();
}
inline int Vehicle::capacities_size() const {
  return _internal_capacities_size();
}
inline void Vehicle::clear_capacities() {
  _impl_.capacities_.Clear();
}
inline ::operations_research::lattle::ValueDimension* Vehicle::mutable_capacities(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.Vehicle.capacities)
  return _impl_.capacities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >*
Vehicle::mutable_capacities() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.lattle.Vehicle.capacities)
  return &_impl_.capacities_;
}
inline const ::operations_research::lattle::ValueDimension& Vehicle::_internal_capacities(int index) const {
  return _impl_.capacities_.Get(index);
}
inline const ::operations_research::lattle::ValueDimension& Vehicle::capacities(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Vehicle.capacities)
  return _internal_capacities(index);
}
inline ::operations_research::lattle::ValueDimension* Vehicle::_internal_add_capacities() {
  return _impl_.capacities_.Add();
}
inline ::operations_research::lattle::ValueDimension* Vehicle::add_capacities() {
  ::operations_research::lattle::ValueDimension* _add = _internal_add_capacities();
  // @@protoc_insertion_point(field_add:operations_research.lattle.Vehicle.capacities)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >&
Vehicle::capacities() const {
  // @@protoc_insertion_point(field_list:operations_research.lattle.Vehicle.capacities)
  return _impl_.capacities_;
}

// .operations_research.lattle.PricingStrategy cost = 4;
inline bool Vehicle::_internal_has_cost() const {
  return this != internal_default_instance() && _impl_.cost_ != nullptr;
}
inline bool Vehicle::has_cost() const {
  return _internal_has_cost();
}
inline void Vehicle::clear_cost() {
  if (GetArenaForAllocation() == nullptr && _impl_.cost_ != nullptr) {
    delete _impl_.cost_;
  }
  _impl_.cost_ = nullptr;
}
inline const ::operations_research::lattle::PricingStrategy& Vehicle::_internal_cost() const {
  const ::operations_research::lattle::PricingStrategy* p = _impl_.cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::lattle::PricingStrategy&>(
      ::operations_research::lattle::_PricingStrategy_default_instance_);
}
inline const ::operations_research::lattle::PricingStrategy& Vehicle::cost() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Vehicle.cost)
  return _internal_cost();
}
inline void Vehicle::unsafe_arena_set_allocated_cost(
    ::operations_research::lattle::PricingStrategy* cost) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cost_);
  }
  _impl_.cost_ = cost;
  if (cost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.Vehicle.cost)
}
inline ::operations_research::lattle::PricingStrategy* Vehicle::release_cost() {
  
  ::operations_research::lattle::PricingStrategy* temp = _impl_.cost_;
  _impl_.cost_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::operations_research::lattle::PricingStrategy* Vehicle::unsafe_arena_release_cost() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.Vehicle.cost)
  
  ::operations_research::lattle::PricingStrategy* temp = _impl_.cost_;
  _impl_.cost_ = nullptr;
  return temp;
}
inline ::operations_research::lattle::PricingStrategy* Vehicle::_internal_mutable_cost() {
  
  if (_impl_.cost_ == nullptr) {
    auto* p = CreateMaybeMessage<::operations_research::lattle::PricingStrategy>(GetArenaForAllocation());
    _impl_.cost_ = p;
  }
  return _impl_.cost_;
}
inline ::operations_research::lattle::PricingStrategy* Vehicle::mutable_cost() {
  ::operations_research::lattle::PricingStrategy* _msg = _internal_mutable_cost();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.Vehicle.cost)
  return _msg;
}
inline void Vehicle::set_allocated_cost(::operations_research::lattle::PricingStrategy* cost) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cost_;
  }
  if (cost) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cost);
    if (message_arena != submessage_arena) {
      cost = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cost, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cost_ = cost;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.Vehicle.cost)
}

// .operations_research.lattle.PricingStrategy pricing = 6;
inline bool Vehicle::_internal_has_pricing() const {
  return this != internal_default_instance() && _impl_.pricing_ != nullptr;
}
inline bool Vehicle::has_pricing() const {
  return _internal_has_pricing();
}
inline void Vehicle::clear_pricing() {
  if (GetArenaForAllocation() == nullptr && _impl_.pricing_ != nullptr) {
    delete _impl_.pricing_;
  }
  _impl_.pricing_ = nullptr;
}
inline const ::operations_research::lattle::PricingStrategy& Vehicle::_internal_pricing() const {
  const ::operations_research::lattle::PricingStrategy* p = _impl_.pricing_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::lattle::PricingStrategy&>(
      ::operations_research::lattle::_PricingStrategy_default_instance_);
}
inline const ::operations_research::lattle::PricingStrategy& Vehicle::pricing() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Vehicle.pricing)
  return _internal_pricing();
}
inline void Vehicle::unsafe_arena_set_allocated_pricing(
    ::operations_research::lattle::PricingStrategy* pricing) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pricing_);
  }
  _impl_.pricing_ = pricing;
  if (pricing) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.Vehicle.pricing)
}
inline ::operations_research::lattle::PricingStrategy* Vehicle::release_pricing() {
  
  ::operations_research::lattle::PricingStrategy* temp = _impl_.pricing_;
  _impl_.pricing_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::operations_research::lattle::PricingStrategy* Vehicle::unsafe_arena_release_pricing() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.Vehicle.pricing)
  
  ::operations_research::lattle::PricingStrategy* temp = _impl_.pricing_;
  _impl_.pricing_ = nullptr;
  return temp;
}
inline ::operations_research::lattle::PricingStrategy* Vehicle::_internal_mutable_pricing() {
  
  if (_impl_.pricing_ == nullptr) {
    auto* p = CreateMaybeMessage<::operations_research::lattle::PricingStrategy>(GetArenaForAllocation());
    _impl_.pricing_ = p;
  }
  return _impl_.pricing_;
}
inline ::operations_research::lattle::PricingStrategy* Vehicle::mutable_pricing() {
  ::operations_research::lattle::PricingStrategy* _msg = _internal_mutable_pricing();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.Vehicle.pricing)
  return _msg;
}
inline void Vehicle::set_allocated_pricing(::operations_research::lattle::PricingStrategy* pricing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pricing_;
  }
  if (pricing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pricing);
    if (message_arena != submessage_arena) {
      pricing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pricing, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pricing_ = pricing;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.Vehicle.pricing)
}

// bool allowed_for_generated_routes = 7;
inline void Vehicle::clear_allowed_for_generated_routes() {
  _impl_.allowed_for_generated_routes_ = false;
}
inline bool Vehicle::_internal_allowed_for_generated_routes() const {
  return _impl_.allowed_for_generated_routes_;
}
inline bool Vehicle::allowed_for_generated_routes() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Vehicle.allowed_for_generated_routes)
  return _internal_allowed_for_generated_routes();
}
inline void Vehicle::_internal_set_allowed_for_generated_routes(bool value) {
  
  _impl_.allowed_for_generated_routes_ = value;
}
inline void Vehicle::set_allowed_for_generated_routes(bool value) {
  _internal_set_allowed_for_generated_routes(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.Vehicle.allowed_for_generated_routes)
}

// -------------------------------------------------------------------

// Hub

// .google.type.LatLng position = 1;
inline bool Hub::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool Hub::has_position() const {
  return _internal_has_position();
}
inline const ::google::type::LatLng& Hub::_internal_position() const {
  const ::google::type::LatLng* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::type::LatLng&>(
      ::google::type::_LatLng_default_instance_);
}
inline const ::google::type::LatLng& Hub::position() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Hub.position)
  return _internal_position();
}
inline void Hub::unsafe_arena_set_allocated_position(
    ::google::type::LatLng* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.Hub.position)
}
inline ::google::type::LatLng* Hub::release_position() {
  
  ::google::type::LatLng* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::type::LatLng* Hub::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.Hub.position)
  
  ::google::type::LatLng* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::google::type::LatLng* Hub::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::type::LatLng>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::google::type::LatLng* Hub::mutable_position() {
  ::google::type::LatLng* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.Hub.position)
  return _msg;
}
inline void Hub::set_allocated_position(::google::type::LatLng* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.Hub.position)
}

// repeated .operations_research.lattle.DateTimeRange opening_times = 2;
inline int Hub::_internal_opening_times_size() const {
  return _impl_.opening_times_.size();
}
inline int Hub::opening_times_size() const {
  return _internal_opening_times_size();
}
inline void Hub::clear_opening_times() {
  _impl_.opening_times_.Clear();
}
inline ::operations_research::lattle::DateTimeRange* Hub::mutable_opening_times(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.Hub.opening_times)
  return _impl_.opening_times_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::DateTimeRange >*
Hub::mutable_opening_times() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.lattle.Hub.opening_times)
  return &_impl_.opening_times_;
}
inline const ::operations_research::lattle::DateTimeRange& Hub::_internal_opening_times(int index) const {
  return _impl_.opening_times_.Get(index);
}
inline const ::operations_research::lattle::DateTimeRange& Hub::opening_times(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Hub.opening_times)
  return _internal_opening_times(index);
}
inline ::operations_research::lattle::DateTimeRange* Hub::_internal_add_opening_times() {
  return _impl_.opening_times_.Add();
}
inline ::operations_research::lattle::DateTimeRange* Hub::add_opening_times() {
  ::operations_research::lattle::DateTimeRange* _add = _internal_add_opening_times();
  // @@protoc_insertion_point(field_add:operations_research.lattle.Hub.opening_times)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::DateTimeRange >&
Hub::opening_times() const {
  // @@protoc_insertion_point(field_list:operations_research.lattle.Hub.opening_times)
  return _impl_.opening_times_;
}

// .operations_research.lattle.CrossDockingCapacity cross_docking_capacity = 3;
inline bool Hub::_internal_has_cross_docking_capacity() const {
  return this != internal_default_instance() && _impl_.cross_docking_capacity_ != nullptr;
}
inline bool Hub::has_cross_docking_capacity() const {
  return _internal_has_cross_docking_capacity();
}
inline void Hub::clear_cross_docking_capacity() {
  if (GetArenaForAllocation() == nullptr && _impl_.cross_docking_capacity_ != nullptr) {
    delete _impl_.cross_docking_capacity_;
  }
  _impl_.cross_docking_capacity_ = nullptr;
}
inline const ::operations_research::lattle::CrossDockingCapacity& Hub::_internal_cross_docking_capacity() const {
  const ::operations_research::lattle::CrossDockingCapacity* p = _impl_.cross_docking_capacity_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::lattle::CrossDockingCapacity&>(
      ::operations_research::lattle::_CrossDockingCapacity_default_instance_);
}
inline const ::operations_research::lattle::CrossDockingCapacity& Hub::cross_docking_capacity() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Hub.cross_docking_capacity)
  return _internal_cross_docking_capacity();
}
inline void Hub::unsafe_arena_set_allocated_cross_docking_capacity(
    ::operations_research::lattle::CrossDockingCapacity* cross_docking_capacity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cross_docking_capacity_);
  }
  _impl_.cross_docking_capacity_ = cross_docking_capacity;
  if (cross_docking_capacity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.Hub.cross_docking_capacity)
}
inline ::operations_research::lattle::CrossDockingCapacity* Hub::release_cross_docking_capacity() {
  
  ::operations_research::lattle::CrossDockingCapacity* temp = _impl_.cross_docking_capacity_;
  _impl_.cross_docking_capacity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::operations_research::lattle::CrossDockingCapacity* Hub::unsafe_arena_release_cross_docking_capacity() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.Hub.cross_docking_capacity)
  
  ::operations_research::lattle::CrossDockingCapacity* temp = _impl_.cross_docking_capacity_;
  _impl_.cross_docking_capacity_ = nullptr;
  return temp;
}
inline ::operations_research::lattle::CrossDockingCapacity* Hub::_internal_mutable_cross_docking_capacity() {
  
  if (_impl_.cross_docking_capacity_ == nullptr) {
    auto* p = CreateMaybeMessage<::operations_research::lattle::CrossDockingCapacity>(GetArenaForAllocation());
    _impl_.cross_docking_capacity_ = p;
  }
  return _impl_.cross_docking_capacity_;
}
inline ::operations_research::lattle::CrossDockingCapacity* Hub::mutable_cross_docking_capacity() {
  ::operations_research::lattle::CrossDockingCapacity* _msg = _internal_mutable_cross_docking_capacity();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.Hub.cross_docking_capacity)
  return _msg;
}
inline void Hub::set_allocated_cross_docking_capacity(::operations_research::lattle::CrossDockingCapacity* cross_docking_capacity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cross_docking_capacity_;
  }
  if (cross_docking_capacity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cross_docking_capacity);
    if (message_arena != submessage_arena) {
      cross_docking_capacity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cross_docking_capacity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cross_docking_capacity_ = cross_docking_capacity;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.Hub.cross_docking_capacity)
}

// .operations_research.lattle.CrossDockingTime cross_docking_time = 4;
inline bool Hub::_internal_has_cross_docking_time() const {
  return this != internal_default_instance() && _impl_.cross_docking_time_ != nullptr;
}
inline bool Hub::has_cross_docking_time() const {
  return _internal_has_cross_docking_time();
}
inline void Hub::clear_cross_docking_time() {
  if (GetArenaForAllocation() == nullptr && _impl_.cross_docking_time_ != nullptr) {
    delete _impl_.cross_docking_time_;
  }
  _impl_.cross_docking_time_ = nullptr;
}
inline const ::operations_research::lattle::CrossDockingTime& Hub::_internal_cross_docking_time() const {
  const ::operations_research::lattle::CrossDockingTime* p = _impl_.cross_docking_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::lattle::CrossDockingTime&>(
      ::operations_research::lattle::_CrossDockingTime_default_instance_);
}
inline const ::operations_research::lattle::CrossDockingTime& Hub::cross_docking_time() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Hub.cross_docking_time)
  return _internal_cross_docking_time();
}
inline void Hub::unsafe_arena_set_allocated_cross_docking_time(
    ::operations_research::lattle::CrossDockingTime* cross_docking_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cross_docking_time_);
  }
  _impl_.cross_docking_time_ = cross_docking_time;
  if (cross_docking_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.Hub.cross_docking_time)
}
inline ::operations_research::lattle::CrossDockingTime* Hub::release_cross_docking_time() {
  
  ::operations_research::lattle::CrossDockingTime* temp = _impl_.cross_docking_time_;
  _impl_.cross_docking_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::operations_research::lattle::CrossDockingTime* Hub::unsafe_arena_release_cross_docking_time() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.Hub.cross_docking_time)
  
  ::operations_research::lattle::CrossDockingTime* temp = _impl_.cross_docking_time_;
  _impl_.cross_docking_time_ = nullptr;
  return temp;
}
inline ::operations_research::lattle::CrossDockingTime* Hub::_internal_mutable_cross_docking_time() {
  
  if (_impl_.cross_docking_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::operations_research::lattle::CrossDockingTime>(GetArenaForAllocation());
    _impl_.cross_docking_time_ = p;
  }
  return _impl_.cross_docking_time_;
}
inline ::operations_research::lattle::CrossDockingTime* Hub::mutable_cross_docking_time() {
  ::operations_research::lattle::CrossDockingTime* _msg = _internal_mutable_cross_docking_time();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.Hub.cross_docking_time)
  return _msg;
}
inline void Hub::set_allocated_cross_docking_time(::operations_research::lattle::CrossDockingTime* cross_docking_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cross_docking_time_;
  }
  if (cross_docking_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cross_docking_time);
    if (message_arena != submessage_arena) {
      cross_docking_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cross_docking_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cross_docking_time_ = cross_docking_time;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.Hub.cross_docking_time)
}

// -------------------------------------------------------------------

// CrossDockingCapacity

// repeated .operations_research.lattle.ValueDimension capacity_per_hour = 1;
inline int CrossDockingCapacity::_internal_capacity_per_hour_size() const {
  return _impl_.capacity_per_hour_.size();
}
inline int CrossDockingCapacity::capacity_per_hour_size() const {
  return _internal_capacity_per_hour_size();
}
inline void CrossDockingCapacity::clear_capacity_per_hour() {
  _impl_.capacity_per_hour_.Clear();
}
inline ::operations_research::lattle::ValueDimension* CrossDockingCapacity::mutable_capacity_per_hour(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.CrossDockingCapacity.capacity_per_hour)
  return _impl_.capacity_per_hour_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >*
CrossDockingCapacity::mutable_capacity_per_hour() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.lattle.CrossDockingCapacity.capacity_per_hour)
  return &_impl_.capacity_per_hour_;
}
inline const ::operations_research::lattle::ValueDimension& CrossDockingCapacity::_internal_capacity_per_hour(int index) const {
  return _impl_.capacity_per_hour_.Get(index);
}
inline const ::operations_research::lattle::ValueDimension& CrossDockingCapacity::capacity_per_hour(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.CrossDockingCapacity.capacity_per_hour)
  return _internal_capacity_per_hour(index);
}
inline ::operations_research::lattle::ValueDimension* CrossDockingCapacity::_internal_add_capacity_per_hour() {
  return _impl_.capacity_per_hour_.Add();
}
inline ::operations_research::lattle::ValueDimension* CrossDockingCapacity::add_capacity_per_hour() {
  ::operations_research::lattle::ValueDimension* _add = _internal_add_capacity_per_hour();
  // @@protoc_insertion_point(field_add:operations_research.lattle.CrossDockingCapacity.capacity_per_hour)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >&
CrossDockingCapacity::capacity_per_hour() const {
  // @@protoc_insertion_point(field_list:operations_research.lattle.CrossDockingCapacity.capacity_per_hour)
  return _impl_.capacity_per_hour_;
}

// -------------------------------------------------------------------

// CrossDockingTime

// .google.protobuf.Duration time_constant = 1;
inline bool CrossDockingTime::_internal_has_time_constant() const {
  return this != internal_default_instance() && _impl_.time_constant_ != nullptr;
}
inline bool CrossDockingTime::has_time_constant() const {
  return _internal_has_time_constant();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& CrossDockingTime::_internal_time_constant() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.time_constant_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& CrossDockingTime::time_constant() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.CrossDockingTime.time_constant)
  return _internal_time_constant();
}
inline void CrossDockingTime::unsafe_arena_set_allocated_time_constant(
    ::PROTOBUF_NAMESPACE_ID::Duration* time_constant) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_constant_);
  }
  _impl_.time_constant_ = time_constant;
  if (time_constant) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.CrossDockingTime.time_constant)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* CrossDockingTime::release_time_constant() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.time_constant_;
  _impl_.time_constant_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* CrossDockingTime::unsafe_arena_release_time_constant() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.CrossDockingTime.time_constant)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.time_constant_;
  _impl_.time_constant_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* CrossDockingTime::_internal_mutable_time_constant() {
  
  if (_impl_.time_constant_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.time_constant_ = p;
  }
  return _impl_.time_constant_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* CrossDockingTime::mutable_time_constant() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_time_constant();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.CrossDockingTime.time_constant)
  return _msg;
}
inline void CrossDockingTime::set_allocated_time_constant(::PROTOBUF_NAMESPACE_ID::Duration* time_constant) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_constant_);
  }
  if (time_constant) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_constant));
    if (message_arena != submessage_arena) {
      time_constant = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_constant, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_constant_ = time_constant;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.CrossDockingTime.time_constant)
}

// .operations_research.lattle.SeparableNDFunction time = 2;
inline bool CrossDockingTime::_internal_has_time() const {
  return this != internal_default_instance() && _impl_.time_ != nullptr;
}
inline bool CrossDockingTime::has_time() const {
  return _internal_has_time();
}
inline void CrossDockingTime::clear_time() {
  if (GetArenaForAllocation() == nullptr && _impl_.time_ != nullptr) {
    delete _impl_.time_;
  }
  _impl_.time_ = nullptr;
}
inline const ::operations_research::lattle::SeparableNDFunction& CrossDockingTime::_internal_time() const {
  const ::operations_research::lattle::SeparableNDFunction* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::lattle::SeparableNDFunction&>(
      ::operations_research::lattle::_SeparableNDFunction_default_instance_);
}
inline const ::operations_research::lattle::SeparableNDFunction& CrossDockingTime::time() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.CrossDockingTime.time)
  return _internal_time();
}
inline void CrossDockingTime::unsafe_arena_set_allocated_time(
    ::operations_research::lattle::SeparableNDFunction* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = time;
  if (time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.CrossDockingTime.time)
}
inline ::operations_research::lattle::SeparableNDFunction* CrossDockingTime::release_time() {
  
  ::operations_research::lattle::SeparableNDFunction* temp = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::operations_research::lattle::SeparableNDFunction* CrossDockingTime::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.CrossDockingTime.time)
  
  ::operations_research::lattle::SeparableNDFunction* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::operations_research::lattle::SeparableNDFunction* CrossDockingTime::_internal_mutable_time() {
  
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::operations_research::lattle::SeparableNDFunction>(GetArenaForAllocation());
    _impl_.time_ = p;
  }
  return _impl_.time_;
}
inline ::operations_research::lattle::SeparableNDFunction* CrossDockingTime::mutable_time() {
  ::operations_research::lattle::SeparableNDFunction* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.CrossDockingTime.time)
  return _msg;
}
inline void CrossDockingTime::set_allocated_time(::operations_research::lattle::SeparableNDFunction* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.time_;
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(time);
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_ = time;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.CrossDockingTime.time)
}

// -------------------------------------------------------------------

// DistanceMatrixEntry

// string source_hub = 1;
inline void DistanceMatrixEntry::clear_source_hub() {
  _impl_.source_hub_.ClearToEmpty();
}
inline const std::string& DistanceMatrixEntry::source_hub() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.DistanceMatrixEntry.source_hub)
  return _internal_source_hub();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DistanceMatrixEntry::set_source_hub(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_hub_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.DistanceMatrixEntry.source_hub)
}
inline std::string* DistanceMatrixEntry::mutable_source_hub() {
  std::string* _s = _internal_mutable_source_hub();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.DistanceMatrixEntry.source_hub)
  return _s;
}
inline const std::string& DistanceMatrixEntry::_internal_source_hub() const {
  return _impl_.source_hub_.Get();
}
inline void DistanceMatrixEntry::_internal_set_source_hub(const std::string& value) {
  
  _impl_.source_hub_.Set(value, GetArenaForAllocation());
}
inline std::string* DistanceMatrixEntry::_internal_mutable_source_hub() {
  
  return _impl_.source_hub_.Mutable(GetArenaForAllocation());
}
inline std::string* DistanceMatrixEntry::release_source_hub() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.DistanceMatrixEntry.source_hub)
  return _impl_.source_hub_.Release();
}
inline void DistanceMatrixEntry::set_allocated_source_hub(std::string* source_hub) {
  if (source_hub != nullptr) {
    
  } else {
    
  }
  _impl_.source_hub_.SetAllocated(source_hub, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_hub_.IsDefault()) {
    _impl_.source_hub_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.DistanceMatrixEntry.source_hub)
}

// string destination_hub = 2;
inline void DistanceMatrixEntry::clear_destination_hub() {
  _impl_.destination_hub_.ClearToEmpty();
}
inline const std::string& DistanceMatrixEntry::destination_hub() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.DistanceMatrixEntry.destination_hub)
  return _internal_destination_hub();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DistanceMatrixEntry::set_destination_hub(ArgT0&& arg0, ArgT... args) {
 
 _impl_.destination_hub_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.DistanceMatrixEntry.destination_hub)
}
inline std::string* DistanceMatrixEntry::mutable_destination_hub() {
  std::string* _s = _internal_mutable_destination_hub();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.DistanceMatrixEntry.destination_hub)
  return _s;
}
inline const std::string& DistanceMatrixEntry::_internal_destination_hub() const {
  return _impl_.destination_hub_.Get();
}
inline void DistanceMatrixEntry::_internal_set_destination_hub(const std::string& value) {
  
  _impl_.destination_hub_.Set(value, GetArenaForAllocation());
}
inline std::string* DistanceMatrixEntry::_internal_mutable_destination_hub() {
  
  return _impl_.destination_hub_.Mutable(GetArenaForAllocation());
}
inline std::string* DistanceMatrixEntry::release_destination_hub() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.DistanceMatrixEntry.destination_hub)
  return _impl_.destination_hub_.Release();
}
inline void DistanceMatrixEntry::set_allocated_destination_hub(std::string* destination_hub) {
  if (destination_hub != nullptr) {
    
  } else {
    
  }
  _impl_.destination_hub_.SetAllocated(destination_hub, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.destination_hub_.IsDefault()) {
    _impl_.destination_hub_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.DistanceMatrixEntry.destination_hub)
}

// repeated .operations_research.lattle.ValueDimension weights = 3;
inline int DistanceMatrixEntry::_internal_weights_size() const {
  return _impl_.weights_.size();
}
inline int DistanceMatrixEntry::weights_size() const {
  return _internal_weights_size();
}
inline void DistanceMatrixEntry::clear_weights() {
  _impl_.weights_.Clear();
}
inline ::operations_research::lattle::ValueDimension* DistanceMatrixEntry::mutable_weights(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.DistanceMatrixEntry.weights)
  return _impl_.weights_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >*
DistanceMatrixEntry::mutable_weights() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.lattle.DistanceMatrixEntry.weights)
  return &_impl_.weights_;
}
inline const ::operations_research::lattle::ValueDimension& DistanceMatrixEntry::_internal_weights(int index) const {
  return _impl_.weights_.Get(index);
}
inline const ::operations_research::lattle::ValueDimension& DistanceMatrixEntry::weights(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.DistanceMatrixEntry.weights)
  return _internal_weights(index);
}
inline ::operations_research::lattle::ValueDimension* DistanceMatrixEntry::_internal_add_weights() {
  return _impl_.weights_.Add();
}
inline ::operations_research::lattle::ValueDimension* DistanceMatrixEntry::add_weights() {
  ::operations_research::lattle::ValueDimension* _add = _internal_add_weights();
  // @@protoc_insertion_point(field_add:operations_research.lattle.DistanceMatrixEntry.weights)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >&
DistanceMatrixEntry::weights() const {
  // @@protoc_insertion_point(field_list:operations_research.lattle.DistanceMatrixEntry.weights)
  return _impl_.weights_;
}

// -------------------------------------------------------------------

// Parcel

// string parcel = 1;
inline void Parcel::clear_parcel() {
  _impl_.parcel_.ClearToEmpty();
}
inline const std::string& Parcel::parcel() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Parcel.parcel)
  return _internal_parcel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Parcel::set_parcel(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parcel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.Parcel.parcel)
}
inline std::string* Parcel::mutable_parcel() {
  std::string* _s = _internal_mutable_parcel();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.Parcel.parcel)
  return _s;
}
inline const std::string& Parcel::_internal_parcel() const {
  return _impl_.parcel_.Get();
}
inline void Parcel::_internal_set_parcel(const std::string& value) {
  
  _impl_.parcel_.Set(value, GetArenaForAllocation());
}
inline std::string* Parcel::_internal_mutable_parcel() {
  
  return _impl_.parcel_.Mutable(GetArenaForAllocation());
}
inline std::string* Parcel::release_parcel() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.Parcel.parcel)
  return _impl_.parcel_.Release();
}
inline void Parcel::set_allocated_parcel(std::string* parcel) {
  if (parcel != nullptr) {
    
  } else {
    
  }
  _impl_.parcel_.SetAllocated(parcel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parcel_.IsDefault()) {
    _impl_.parcel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.Parcel.parcel)
}

// string source_hub = 2;
inline void Parcel::clear_source_hub() {
  _impl_.source_hub_.ClearToEmpty();
}
inline const std::string& Parcel::source_hub() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Parcel.source_hub)
  return _internal_source_hub();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Parcel::set_source_hub(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_hub_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.Parcel.source_hub)
}
inline std::string* Parcel::mutable_source_hub() {
  std::string* _s = _internal_mutable_source_hub();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.Parcel.source_hub)
  return _s;
}
inline const std::string& Parcel::_internal_source_hub() const {
  return _impl_.source_hub_.Get();
}
inline void Parcel::_internal_set_source_hub(const std::string& value) {
  
  _impl_.source_hub_.Set(value, GetArenaForAllocation());
}
inline std::string* Parcel::_internal_mutable_source_hub() {
  
  return _impl_.source_hub_.Mutable(GetArenaForAllocation());
}
inline std::string* Parcel::release_source_hub() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.Parcel.source_hub)
  return _impl_.source_hub_.Release();
}
inline void Parcel::set_allocated_source_hub(std::string* source_hub) {
  if (source_hub != nullptr) {
    
  } else {
    
  }
  _impl_.source_hub_.SetAllocated(source_hub, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_hub_.IsDefault()) {
    _impl_.source_hub_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.Parcel.source_hub)
}

// string destination_hub = 3;
inline void Parcel::clear_destination_hub() {
  _impl_.destination_hub_.ClearToEmpty();
}
inline const std::string& Parcel::destination_hub() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Parcel.destination_hub)
  return _internal_destination_hub();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Parcel::set_destination_hub(ArgT0&& arg0, ArgT... args) {
 
 _impl_.destination_hub_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.Parcel.destination_hub)
}
inline std::string* Parcel::mutable_destination_hub() {
  std::string* _s = _internal_mutable_destination_hub();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.Parcel.destination_hub)
  return _s;
}
inline const std::string& Parcel::_internal_destination_hub() const {
  return _impl_.destination_hub_.Get();
}
inline void Parcel::_internal_set_destination_hub(const std::string& value) {
  
  _impl_.destination_hub_.Set(value, GetArenaForAllocation());
}
inline std::string* Parcel::_internal_mutable_destination_hub() {
  
  return _impl_.destination_hub_.Mutable(GetArenaForAllocation());
}
inline std::string* Parcel::release_destination_hub() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.Parcel.destination_hub)
  return _impl_.destination_hub_.Release();
}
inline void Parcel::set_allocated_destination_hub(std::string* destination_hub) {
  if (destination_hub != nullptr) {
    
  } else {
    
  }
  _impl_.destination_hub_.SetAllocated(destination_hub, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.destination_hub_.IsDefault()) {
    _impl_.destination_hub_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.Parcel.destination_hub)
}

// .google.type.DateTime departure_time = 4;
inline bool Parcel::_internal_has_departure_time() const {
  return this != internal_default_instance() && _impl_.departure_time_ != nullptr;
}
inline bool Parcel::has_departure_time() const {
  return _internal_has_departure_time();
}
inline const ::google::type::DateTime& Parcel::_internal_departure_time() const {
  const ::google::type::DateTime* p = _impl_.departure_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::type::DateTime&>(
      ::google::type::_DateTime_default_instance_);
}
inline const ::google::type::DateTime& Parcel::departure_time() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Parcel.departure_time)
  return _internal_departure_time();
}
inline void Parcel::unsafe_arena_set_allocated_departure_time(
    ::google::type::DateTime* departure_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.departure_time_);
  }
  _impl_.departure_time_ = departure_time;
  if (departure_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.Parcel.departure_time)
}
inline ::google::type::DateTime* Parcel::release_departure_time() {
  
  ::google::type::DateTime* temp = _impl_.departure_time_;
  _impl_.departure_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::type::DateTime* Parcel::unsafe_arena_release_departure_time() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.Parcel.departure_time)
  
  ::google::type::DateTime* temp = _impl_.departure_time_;
  _impl_.departure_time_ = nullptr;
  return temp;
}
inline ::google::type::DateTime* Parcel::_internal_mutable_departure_time() {
  
  if (_impl_.departure_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::type::DateTime>(GetArenaForAllocation());
    _impl_.departure_time_ = p;
  }
  return _impl_.departure_time_;
}
inline ::google::type::DateTime* Parcel::mutable_departure_time() {
  ::google::type::DateTime* _msg = _internal_mutable_departure_time();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.Parcel.departure_time)
  return _msg;
}
inline void Parcel::set_allocated_departure_time(::google::type::DateTime* departure_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.departure_time_);
  }
  if (departure_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(departure_time));
    if (message_arena != submessage_arena) {
      departure_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, departure_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.departure_time_ = departure_time;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.Parcel.departure_time)
}

// .operations_research.lattle.DateTimeRange arrival_time = 5;
inline bool Parcel::_internal_has_arrival_time() const {
  return this != internal_default_instance() && _impl_.arrival_time_ != nullptr;
}
inline bool Parcel::has_arrival_time() const {
  return _internal_has_arrival_time();
}
inline void Parcel::clear_arrival_time() {
  if (GetArenaForAllocation() == nullptr && _impl_.arrival_time_ != nullptr) {
    delete _impl_.arrival_time_;
  }
  _impl_.arrival_time_ = nullptr;
}
inline const ::operations_research::lattle::DateTimeRange& Parcel::_internal_arrival_time() const {
  const ::operations_research::lattle::DateTimeRange* p = _impl_.arrival_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::lattle::DateTimeRange&>(
      ::operations_research::lattle::_DateTimeRange_default_instance_);
}
inline const ::operations_research::lattle::DateTimeRange& Parcel::arrival_time() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Parcel.arrival_time)
  return _internal_arrival_time();
}
inline void Parcel::unsafe_arena_set_allocated_arrival_time(
    ::operations_research::lattle::DateTimeRange* arrival_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.arrival_time_);
  }
  _impl_.arrival_time_ = arrival_time;
  if (arrival_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.Parcel.arrival_time)
}
inline ::operations_research::lattle::DateTimeRange* Parcel::release_arrival_time() {
  
  ::operations_research::lattle::DateTimeRange* temp = _impl_.arrival_time_;
  _impl_.arrival_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::operations_research::lattle::DateTimeRange* Parcel::unsafe_arena_release_arrival_time() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.Parcel.arrival_time)
  
  ::operations_research::lattle::DateTimeRange* temp = _impl_.arrival_time_;
  _impl_.arrival_time_ = nullptr;
  return temp;
}
inline ::operations_research::lattle::DateTimeRange* Parcel::_internal_mutable_arrival_time() {
  
  if (_impl_.arrival_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::operations_research::lattle::DateTimeRange>(GetArenaForAllocation());
    _impl_.arrival_time_ = p;
  }
  return _impl_.arrival_time_;
}
inline ::operations_research::lattle::DateTimeRange* Parcel::mutable_arrival_time() {
  ::operations_research::lattle::DateTimeRange* _msg = _internal_mutable_arrival_time();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.Parcel.arrival_time)
  return _msg;
}
inline void Parcel::set_allocated_arrival_time(::operations_research::lattle::DateTimeRange* arrival_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.arrival_time_;
  }
  if (arrival_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(arrival_time);
    if (message_arena != submessage_arena) {
      arrival_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arrival_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.arrival_time_ = arrival_time;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.Parcel.arrival_time)
}

// .operations_research.lattle.EarlinessTardiness arrival_earliness_tardiness_cost = 6;
inline bool Parcel::_internal_has_arrival_earliness_tardiness_cost() const {
  return this != internal_default_instance() && _impl_.arrival_earliness_tardiness_cost_ != nullptr;
}
inline bool Parcel::has_arrival_earliness_tardiness_cost() const {
  return _internal_has_arrival_earliness_tardiness_cost();
}
inline void Parcel::clear_arrival_earliness_tardiness_cost() {
  if (GetArenaForAllocation() == nullptr && _impl_.arrival_earliness_tardiness_cost_ != nullptr) {
    delete _impl_.arrival_earliness_tardiness_cost_;
  }
  _impl_.arrival_earliness_tardiness_cost_ = nullptr;
}
inline const ::operations_research::lattle::EarlinessTardiness& Parcel::_internal_arrival_earliness_tardiness_cost() const {
  const ::operations_research::lattle::EarlinessTardiness* p = _impl_.arrival_earliness_tardiness_cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::lattle::EarlinessTardiness&>(
      ::operations_research::lattle::_EarlinessTardiness_default_instance_);
}
inline const ::operations_research::lattle::EarlinessTardiness& Parcel::arrival_earliness_tardiness_cost() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Parcel.arrival_earliness_tardiness_cost)
  return _internal_arrival_earliness_tardiness_cost();
}
inline void Parcel::unsafe_arena_set_allocated_arrival_earliness_tardiness_cost(
    ::operations_research::lattle::EarlinessTardiness* arrival_earliness_tardiness_cost) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.arrival_earliness_tardiness_cost_);
  }
  _impl_.arrival_earliness_tardiness_cost_ = arrival_earliness_tardiness_cost;
  if (arrival_earliness_tardiness_cost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.Parcel.arrival_earliness_tardiness_cost)
}
inline ::operations_research::lattle::EarlinessTardiness* Parcel::release_arrival_earliness_tardiness_cost() {
  
  ::operations_research::lattle::EarlinessTardiness* temp = _impl_.arrival_earliness_tardiness_cost_;
  _impl_.arrival_earliness_tardiness_cost_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::operations_research::lattle::EarlinessTardiness* Parcel::unsafe_arena_release_arrival_earliness_tardiness_cost() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.Parcel.arrival_earliness_tardiness_cost)
  
  ::operations_research::lattle::EarlinessTardiness* temp = _impl_.arrival_earliness_tardiness_cost_;
  _impl_.arrival_earliness_tardiness_cost_ = nullptr;
  return temp;
}
inline ::operations_research::lattle::EarlinessTardiness* Parcel::_internal_mutable_arrival_earliness_tardiness_cost() {
  
  if (_impl_.arrival_earliness_tardiness_cost_ == nullptr) {
    auto* p = CreateMaybeMessage<::operations_research::lattle::EarlinessTardiness>(GetArenaForAllocation());
    _impl_.arrival_earliness_tardiness_cost_ = p;
  }
  return _impl_.arrival_earliness_tardiness_cost_;
}
inline ::operations_research::lattle::EarlinessTardiness* Parcel::mutable_arrival_earliness_tardiness_cost() {
  ::operations_research::lattle::EarlinessTardiness* _msg = _internal_mutable_arrival_earliness_tardiness_cost();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.Parcel.arrival_earliness_tardiness_cost)
  return _msg;
}
inline void Parcel::set_allocated_arrival_earliness_tardiness_cost(::operations_research::lattle::EarlinessTardiness* arrival_earliness_tardiness_cost) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.arrival_earliness_tardiness_cost_;
  }
  if (arrival_earliness_tardiness_cost) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(arrival_earliness_tardiness_cost);
    if (message_arena != submessage_arena) {
      arrival_earliness_tardiness_cost = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arrival_earliness_tardiness_cost, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.arrival_earliness_tardiness_cost_ = arrival_earliness_tardiness_cost;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.Parcel.arrival_earliness_tardiness_cost)
}

// bool must_be_refrigerated = 7;
inline void Parcel::clear_must_be_refrigerated() {
  _impl_.must_be_refrigerated_ = false;
}
inline bool Parcel::_internal_must_be_refrigerated() const {
  return _impl_.must_be_refrigerated_;
}
inline bool Parcel::must_be_refrigerated() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Parcel.must_be_refrigerated)
  return _internal_must_be_refrigerated();
}
inline void Parcel::_internal_set_must_be_refrigerated(bool value) {
  
  _impl_.must_be_refrigerated_ = value;
}
inline void Parcel::set_must_be_refrigerated(bool value) {
  _internal_set_must_be_refrigerated(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.Parcel.must_be_refrigerated)
}

// optional double revenue = 8;
inline bool Parcel::_internal_has_revenue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Parcel::has_revenue() const {
  return _internal_has_revenue();
}
inline void Parcel::clear_revenue() {
  _impl_.revenue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Parcel::_internal_revenue() const {
  return _impl_.revenue_;
}
inline double Parcel::revenue() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Parcel.revenue)
  return _internal_revenue();
}
inline void Parcel::_internal_set_revenue(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.revenue_ = value;
}
inline void Parcel::set_revenue(double value) {
  _internal_set_revenue(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.Parcel.revenue)
}

// repeated .operations_research.lattle.ValueDimension size = 9;
inline int Parcel::_internal_size_size() const {
  return _impl_.size_.size();
}
inline int Parcel::size_size() const {
  return _internal_size_size();
}
inline void Parcel::clear_size() {
  _impl_.size_.Clear();
}
inline ::operations_research::lattle::ValueDimension* Parcel::mutable_size(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.Parcel.size)
  return _impl_.size_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >*
Parcel::mutable_size() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.lattle.Parcel.size)
  return &_impl_.size_;
}
inline const ::operations_research::lattle::ValueDimension& Parcel::_internal_size(int index) const {
  return _impl_.size_.Get(index);
}
inline const ::operations_research::lattle::ValueDimension& Parcel::size(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Parcel.size)
  return _internal_size(index);
}
inline ::operations_research::lattle::ValueDimension* Parcel::_internal_add_size() {
  return _impl_.size_.Add();
}
inline ::operations_research::lattle::ValueDimension* Parcel::add_size() {
  ::operations_research::lattle::ValueDimension* _add = _internal_add_size();
  // @@protoc_insertion_point(field_add:operations_research.lattle.Parcel.size)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >&
Parcel::size() const {
  // @@protoc_insertion_point(field_list:operations_research.lattle.Parcel.size)
  return _impl_.size_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ParcelRoute

// string parcel = 1;
inline void ParcelRoute::clear_parcel() {
  _impl_.parcel_.ClearToEmpty();
}
inline const std::string& ParcelRoute::parcel() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.ParcelRoute.parcel)
  return _internal_parcel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParcelRoute::set_parcel(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parcel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.ParcelRoute.parcel)
}
inline std::string* ParcelRoute::mutable_parcel() {
  std::string* _s = _internal_mutable_parcel();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.ParcelRoute.parcel)
  return _s;
}
inline const std::string& ParcelRoute::_internal_parcel() const {
  return _impl_.parcel_.Get();
}
inline void ParcelRoute::_internal_set_parcel(const std::string& value) {
  
  _impl_.parcel_.Set(value, GetArenaForAllocation());
}
inline std::string* ParcelRoute::_internal_mutable_parcel() {
  
  return _impl_.parcel_.Mutable(GetArenaForAllocation());
}
inline std::string* ParcelRoute::release_parcel() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.ParcelRoute.parcel)
  return _impl_.parcel_.Release();
}
inline void ParcelRoute::set_allocated_parcel(std::string* parcel) {
  if (parcel != nullptr) {
    
  } else {
    
  }
  _impl_.parcel_.SetAllocated(parcel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parcel_.IsDefault()) {
    _impl_.parcel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.ParcelRoute.parcel)
}

// repeated .operations_research.lattle.AnnotatedPathSegment path_segments = 2;
inline int ParcelRoute::_internal_path_segments_size() const {
  return _impl_.path_segments_.size();
}
inline int ParcelRoute::path_segments_size() const {
  return _internal_path_segments_size();
}
inline void ParcelRoute::clear_path_segments() {
  _impl_.path_segments_.Clear();
}
inline ::operations_research::lattle::AnnotatedPathSegment* ParcelRoute::mutable_path_segments(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.ParcelRoute.path_segments)
  return _impl_.path_segments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::AnnotatedPathSegment >*
ParcelRoute::mutable_path_segments() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.lattle.ParcelRoute.path_segments)
  return &_impl_.path_segments_;
}
inline const ::operations_research::lattle::AnnotatedPathSegment& ParcelRoute::_internal_path_segments(int index) const {
  return _impl_.path_segments_.Get(index);
}
inline const ::operations_research::lattle::AnnotatedPathSegment& ParcelRoute::path_segments(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.ParcelRoute.path_segments)
  return _internal_path_segments(index);
}
inline ::operations_research::lattle::AnnotatedPathSegment* ParcelRoute::_internal_add_path_segments() {
  return _impl_.path_segments_.Add();
}
inline ::operations_research::lattle::AnnotatedPathSegment* ParcelRoute::add_path_segments() {
  ::operations_research::lattle::AnnotatedPathSegment* _add = _internal_add_path_segments();
  // @@protoc_insertion_point(field_add:operations_research.lattle.ParcelRoute.path_segments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::AnnotatedPathSegment >&
ParcelRoute::path_segments() const {
  // @@protoc_insertion_point(field_list:operations_research.lattle.ParcelRoute.path_segments)
  return _impl_.path_segments_;
}

// .google.type.DateTime departure_time = 3;
inline bool ParcelRoute::_internal_has_departure_time() const {
  return this != internal_default_instance() && _impl_.departure_time_ != nullptr;
}
inline bool ParcelRoute::has_departure_time() const {
  return _internal_has_departure_time();
}
inline const ::google::type::DateTime& ParcelRoute::_internal_departure_time() const {
  const ::google::type::DateTime* p = _impl_.departure_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::type::DateTime&>(
      ::google::type::_DateTime_default_instance_);
}
inline const ::google::type::DateTime& ParcelRoute::departure_time() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.ParcelRoute.departure_time)
  return _internal_departure_time();
}
inline void ParcelRoute::unsafe_arena_set_allocated_departure_time(
    ::google::type::DateTime* departure_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.departure_time_);
  }
  _impl_.departure_time_ = departure_time;
  if (departure_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.ParcelRoute.departure_time)
}
inline ::google::type::DateTime* ParcelRoute::release_departure_time() {
  
  ::google::type::DateTime* temp = _impl_.departure_time_;
  _impl_.departure_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::type::DateTime* ParcelRoute::unsafe_arena_release_departure_time() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.ParcelRoute.departure_time)
  
  ::google::type::DateTime* temp = _impl_.departure_time_;
  _impl_.departure_time_ = nullptr;
  return temp;
}
inline ::google::type::DateTime* ParcelRoute::_internal_mutable_departure_time() {
  
  if (_impl_.departure_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::type::DateTime>(GetArenaForAllocation());
    _impl_.departure_time_ = p;
  }
  return _impl_.departure_time_;
}
inline ::google::type::DateTime* ParcelRoute::mutable_departure_time() {
  ::google::type::DateTime* _msg = _internal_mutable_departure_time();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.ParcelRoute.departure_time)
  return _msg;
}
inline void ParcelRoute::set_allocated_departure_time(::google::type::DateTime* departure_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.departure_time_);
  }
  if (departure_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(departure_time));
    if (message_arena != submessage_arena) {
      departure_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, departure_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.departure_time_ = departure_time;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.ParcelRoute.departure_time)
}

// .google.type.DateTime arrival_time = 4;
inline bool ParcelRoute::_internal_has_arrival_time() const {
  return this != internal_default_instance() && _impl_.arrival_time_ != nullptr;
}
inline bool ParcelRoute::has_arrival_time() const {
  return _internal_has_arrival_time();
}
inline const ::google::type::DateTime& ParcelRoute::_internal_arrival_time() const {
  const ::google::type::DateTime* p = _impl_.arrival_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::type::DateTime&>(
      ::google::type::_DateTime_default_instance_);
}
inline const ::google::type::DateTime& ParcelRoute::arrival_time() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.ParcelRoute.arrival_time)
  return _internal_arrival_time();
}
inline void ParcelRoute::unsafe_arena_set_allocated_arrival_time(
    ::google::type::DateTime* arrival_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.arrival_time_);
  }
  _impl_.arrival_time_ = arrival_time;
  if (arrival_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.ParcelRoute.arrival_time)
}
inline ::google::type::DateTime* ParcelRoute::release_arrival_time() {
  
  ::google::type::DateTime* temp = _impl_.arrival_time_;
  _impl_.arrival_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::type::DateTime* ParcelRoute::unsafe_arena_release_arrival_time() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.ParcelRoute.arrival_time)
  
  ::google::type::DateTime* temp = _impl_.arrival_time_;
  _impl_.arrival_time_ = nullptr;
  return temp;
}
inline ::google::type::DateTime* ParcelRoute::_internal_mutable_arrival_time() {
  
  if (_impl_.arrival_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::type::DateTime>(GetArenaForAllocation());
    _impl_.arrival_time_ = p;
  }
  return _impl_.arrival_time_;
}
inline ::google::type::DateTime* ParcelRoute::mutable_arrival_time() {
  ::google::type::DateTime* _msg = _internal_mutable_arrival_time();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.ParcelRoute.arrival_time)
  return _msg;
}
inline void ParcelRoute::set_allocated_arrival_time(::google::type::DateTime* arrival_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.arrival_time_);
  }
  if (arrival_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(arrival_time));
    if (message_arena != submessage_arena) {
      arrival_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arrival_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.arrival_time_ = arrival_time;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.ParcelRoute.arrival_time)
}

// double incurred_penalties_from_arrival_time_per_minute = 5;
inline void ParcelRoute::clear_incurred_penalties_from_arrival_time_per_minute() {
  _impl_.incurred_penalties_from_arrival_time_per_minute_ = 0;
}
inline double ParcelRoute::_internal_incurred_penalties_from_arrival_time_per_minute() const {
  return _impl_.incurred_penalties_from_arrival_time_per_minute_;
}
inline double ParcelRoute::incurred_penalties_from_arrival_time_per_minute() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.ParcelRoute.incurred_penalties_from_arrival_time_per_minute)
  return _internal_incurred_penalties_from_arrival_time_per_minute();
}
inline void ParcelRoute::_internal_set_incurred_penalties_from_arrival_time_per_minute(double value) {
  
  _impl_.incurred_penalties_from_arrival_time_per_minute_ = value;
}
inline void ParcelRoute::set_incurred_penalties_from_arrival_time_per_minute(double value) {
  _internal_set_incurred_penalties_from_arrival_time_per_minute(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.ParcelRoute.incurred_penalties_from_arrival_time_per_minute)
}

// double cost_constant = 6;
inline void ParcelRoute::clear_cost_constant() {
  _impl_.cost_constant_ = 0;
}
inline double ParcelRoute::_internal_cost_constant() const {
  return _impl_.cost_constant_;
}
inline double ParcelRoute::cost_constant() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.ParcelRoute.cost_constant)
  return _internal_cost_constant();
}
inline void ParcelRoute::_internal_set_cost_constant(double value) {
  
  _impl_.cost_constant_ = value;
}
inline void ParcelRoute::set_cost_constant(double value) {
  _internal_set_cost_constant(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.ParcelRoute.cost_constant)
}

// map<string, double> cost = 7;
inline int ParcelRoute::_internal_cost_size() const {
  return _impl_.cost_.size();
}
inline int ParcelRoute::cost_size() const {
  return _internal_cost_size();
}
inline void ParcelRoute::clear_cost() {
  _impl_.cost_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
ParcelRoute::_internal_cost() const {
  return _impl_.cost_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
ParcelRoute::cost() const {
  // @@protoc_insertion_point(field_map:operations_research.lattle.ParcelRoute.cost)
  return _internal_cost();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
ParcelRoute::_internal_mutable_cost() {
  return _impl_.cost_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
ParcelRoute::mutable_cost() {
  // @@protoc_insertion_point(field_mutable_map:operations_research.lattle.ParcelRoute.cost)
  return _internal_mutable_cost();
}

// .storage_util.Int128 fingerprint = 8 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool ParcelRoute::_internal_has_fingerprint() const {
  return this != internal_default_instance() && _impl_.fingerprint_ != nullptr;
}
inline bool ParcelRoute::has_fingerprint() const {
  return _internal_has_fingerprint();
}
inline const ::storage_util::Int128& ParcelRoute::_internal_fingerprint() const {
  const ::storage_util::Int128* p = _impl_.fingerprint_;
  return p != nullptr ? *p : reinterpret_cast<const ::storage_util::Int128&>(
      ::storage_util::_Int128_default_instance_);
}
inline const ::storage_util::Int128& ParcelRoute::fingerprint() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.ParcelRoute.fingerprint)
  return _internal_fingerprint();
}
inline void ParcelRoute::unsafe_arena_set_allocated_fingerprint(
    ::storage_util::Int128* fingerprint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fingerprint_);
  }
  _impl_.fingerprint_ = fingerprint;
  if (fingerprint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.ParcelRoute.fingerprint)
}
inline ::storage_util::Int128* ParcelRoute::release_fingerprint() {
  
  ::storage_util::Int128* temp = _impl_.fingerprint_;
  _impl_.fingerprint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::storage_util::Int128* ParcelRoute::unsafe_arena_release_fingerprint() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.ParcelRoute.fingerprint)
  
  ::storage_util::Int128* temp = _impl_.fingerprint_;
  _impl_.fingerprint_ = nullptr;
  return temp;
}
inline ::storage_util::Int128* ParcelRoute::_internal_mutable_fingerprint() {
  
  if (_impl_.fingerprint_ == nullptr) {
    auto* p = CreateMaybeMessage<::storage_util::Int128>(GetArenaForAllocation());
    _impl_.fingerprint_ = p;
  }
  return _impl_.fingerprint_;
}
inline ::storage_util::Int128* ParcelRoute::mutable_fingerprint() {
  ::storage_util::Int128* _msg = _internal_mutable_fingerprint();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.ParcelRoute.fingerprint)
  return _msg;
}
inline void ParcelRoute::set_allocated_fingerprint(::storage_util::Int128* fingerprint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fingerprint_);
  }
  if (fingerprint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fingerprint));
    if (message_arena != submessage_arena) {
      fingerprint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fingerprint, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fingerprint_ = fingerprint;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.ParcelRoute.fingerprint)
}

// -------------------------------------------------------------------

// Path

// repeated .operations_research.lattle.PathSegment segments = 1;
inline int Path::_internal_segments_size() const {
  return _impl_.segments_.size();
}
inline int Path::segments_size() const {
  return _internal_segments_size();
}
inline void Path::clear_segments() {
  _impl_.segments_.Clear();
}
inline ::operations_research::lattle::PathSegment* Path::mutable_segments(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.Path.segments)
  return _impl_.segments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::PathSegment >*
Path::mutable_segments() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.lattle.Path.segments)
  return &_impl_.segments_;
}
inline const ::operations_research::lattle::PathSegment& Path::_internal_segments(int index) const {
  return _impl_.segments_.Get(index);
}
inline const ::operations_research::lattle::PathSegment& Path::segments(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.Path.segments)
  return _internal_segments(index);
}
inline ::operations_research::lattle::PathSegment* Path::_internal_add_segments() {
  return _impl_.segments_.Add();
}
inline ::operations_research::lattle::PathSegment* Path::add_segments() {
  ::operations_research::lattle::PathSegment* _add = _internal_add_segments();
  // @@protoc_insertion_point(field_add:operations_research.lattle.Path.segments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::PathSegment >&
Path::segments() const {
  // @@protoc_insertion_point(field_list:operations_research.lattle.Path.segments)
  return _impl_.segments_;
}

// -------------------------------------------------------------------

// IncompletePath

// repeated .operations_research.lattle.PathSegment segments = 1;
inline int IncompletePath::_internal_segments_size() const {
  return _impl_.segments_.size();
}
inline int IncompletePath::segments_size() const {
  return _internal_segments_size();
}
inline void IncompletePath::clear_segments() {
  _impl_.segments_.Clear();
}
inline ::operations_research::lattle::PathSegment* IncompletePath::mutable_segments(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.IncompletePath.segments)
  return _impl_.segments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::PathSegment >*
IncompletePath::mutable_segments() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.lattle.IncompletePath.segments)
  return &_impl_.segments_;
}
inline const ::operations_research::lattle::PathSegment& IncompletePath::_internal_segments(int index) const {
  return _impl_.segments_.Get(index);
}
inline const ::operations_research::lattle::PathSegment& IncompletePath::segments(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.IncompletePath.segments)
  return _internal_segments(index);
}
inline ::operations_research::lattle::PathSegment* IncompletePath::_internal_add_segments() {
  return _impl_.segments_.Add();
}
inline ::operations_research::lattle::PathSegment* IncompletePath::add_segments() {
  ::operations_research::lattle::PathSegment* _add = _internal_add_segments();
  // @@protoc_insertion_point(field_add:operations_research.lattle.IncompletePath.segments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::PathSegment >&
IncompletePath::segments() const {
  // @@protoc_insertion_point(field_list:operations_research.lattle.IncompletePath.segments)
  return _impl_.segments_;
}

// -------------------------------------------------------------------

// PathSegment

// string source_hub = 1;
inline void PathSegment::clear_source_hub() {
  _impl_.source_hub_.ClearToEmpty();
}
inline const std::string& PathSegment::source_hub() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.PathSegment.source_hub)
  return _internal_source_hub();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PathSegment::set_source_hub(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_hub_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.PathSegment.source_hub)
}
inline std::string* PathSegment::mutable_source_hub() {
  std::string* _s = _internal_mutable_source_hub();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.PathSegment.source_hub)
  return _s;
}
inline const std::string& PathSegment::_internal_source_hub() const {
  return _impl_.source_hub_.Get();
}
inline void PathSegment::_internal_set_source_hub(const std::string& value) {
  
  _impl_.source_hub_.Set(value, GetArenaForAllocation());
}
inline std::string* PathSegment::_internal_mutable_source_hub() {
  
  return _impl_.source_hub_.Mutable(GetArenaForAllocation());
}
inline std::string* PathSegment::release_source_hub() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.PathSegment.source_hub)
  return _impl_.source_hub_.Release();
}
inline void PathSegment::set_allocated_source_hub(std::string* source_hub) {
  if (source_hub != nullptr) {
    
  } else {
    
  }
  _impl_.source_hub_.SetAllocated(source_hub, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_hub_.IsDefault()) {
    _impl_.source_hub_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.PathSegment.source_hub)
}

// string destination_hub = 2;
inline void PathSegment::clear_destination_hub() {
  _impl_.destination_hub_.ClearToEmpty();
}
inline const std::string& PathSegment::destination_hub() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.PathSegment.destination_hub)
  return _internal_destination_hub();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PathSegment::set_destination_hub(ArgT0&& arg0, ArgT... args) {
 
 _impl_.destination_hub_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.PathSegment.destination_hub)
}
inline std::string* PathSegment::mutable_destination_hub() {
  std::string* _s = _internal_mutable_destination_hub();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.PathSegment.destination_hub)
  return _s;
}
inline const std::string& PathSegment::_internal_destination_hub() const {
  return _impl_.destination_hub_.Get();
}
inline void PathSegment::_internal_set_destination_hub(const std::string& value) {
  
  _impl_.destination_hub_.Set(value, GetArenaForAllocation());
}
inline std::string* PathSegment::_internal_mutable_destination_hub() {
  
  return _impl_.destination_hub_.Mutable(GetArenaForAllocation());
}
inline std::string* PathSegment::release_destination_hub() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.PathSegment.destination_hub)
  return _impl_.destination_hub_.Release();
}
inline void PathSegment::set_allocated_destination_hub(std::string* destination_hub) {
  if (destination_hub != nullptr) {
    
  } else {
    
  }
  _impl_.destination_hub_.SetAllocated(destination_hub, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.destination_hub_.IsDefault()) {
    _impl_.destination_hub_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.PathSegment.destination_hub)
}

// string line = 3;
inline void PathSegment::clear_line() {
  _impl_.line_.ClearToEmpty();
}
inline const std::string& PathSegment::line() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.PathSegment.line)
  return _internal_line();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PathSegment::set_line(ArgT0&& arg0, ArgT... args) {
 
 _impl_.line_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.PathSegment.line)
}
inline std::string* PathSegment::mutable_line() {
  std::string* _s = _internal_mutable_line();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.PathSegment.line)
  return _s;
}
inline const std::string& PathSegment::_internal_line() const {
  return _impl_.line_.Get();
}
inline void PathSegment::_internal_set_line(const std::string& value) {
  
  _impl_.line_.Set(value, GetArenaForAllocation());
}
inline std::string* PathSegment::_internal_mutable_line() {
  
  return _impl_.line_.Mutable(GetArenaForAllocation());
}
inline std::string* PathSegment::release_line() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.PathSegment.line)
  return _impl_.line_.Release();
}
inline void PathSegment::set_allocated_line(std::string* line) {
  if (line != nullptr) {
    
  } else {
    
  }
  _impl_.line_.SetAllocated(line, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.line_.IsDefault()) {
    _impl_.line_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.PathSegment.line)
}

// string line_rotation = 4;
inline void PathSegment::clear_line_rotation() {
  _impl_.line_rotation_.ClearToEmpty();
}
inline const std::string& PathSegment::line_rotation() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.PathSegment.line_rotation)
  return _internal_line_rotation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PathSegment::set_line_rotation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.line_rotation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.PathSegment.line_rotation)
}
inline std::string* PathSegment::mutable_line_rotation() {
  std::string* _s = _internal_mutable_line_rotation();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.PathSegment.line_rotation)
  return _s;
}
inline const std::string& PathSegment::_internal_line_rotation() const {
  return _impl_.line_rotation_.Get();
}
inline void PathSegment::_internal_set_line_rotation(const std::string& value) {
  
  _impl_.line_rotation_.Set(value, GetArenaForAllocation());
}
inline std::string* PathSegment::_internal_mutable_line_rotation() {
  
  return _impl_.line_rotation_.Mutable(GetArenaForAllocation());
}
inline std::string* PathSegment::release_line_rotation() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.PathSegment.line_rotation)
  return _impl_.line_rotation_.Release();
}
inline void PathSegment::set_allocated_line_rotation(std::string* line_rotation) {
  if (line_rotation != nullptr) {
    
  } else {
    
  }
  _impl_.line_rotation_.SetAllocated(line_rotation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.line_rotation_.IsDefault()) {
    _impl_.line_rotation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.PathSegment.line_rotation)
}

// string vehicle = 5;
inline void PathSegment::clear_vehicle() {
  _impl_.vehicle_.ClearToEmpty();
}
inline const std::string& PathSegment::vehicle() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.PathSegment.vehicle)
  return _internal_vehicle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PathSegment::set_vehicle(ArgT0&& arg0, ArgT... args) {
 
 _impl_.vehicle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.PathSegment.vehicle)
}
inline std::string* PathSegment::mutable_vehicle() {
  std::string* _s = _internal_mutable_vehicle();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.PathSegment.vehicle)
  return _s;
}
inline const std::string& PathSegment::_internal_vehicle() const {
  return _impl_.vehicle_.Get();
}
inline void PathSegment::_internal_set_vehicle(const std::string& value) {
  
  _impl_.vehicle_.Set(value, GetArenaForAllocation());
}
inline std::string* PathSegment::_internal_mutable_vehicle() {
  
  return _impl_.vehicle_.Mutable(GetArenaForAllocation());
}
inline std::string* PathSegment::release_vehicle() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.PathSegment.vehicle)
  return _impl_.vehicle_.Release();
}
inline void PathSegment::set_allocated_vehicle(std::string* vehicle) {
  if (vehicle != nullptr) {
    
  } else {
    
  }
  _impl_.vehicle_.SetAllocated(vehicle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vehicle_.IsDefault()) {
    _impl_.vehicle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.PathSegment.vehicle)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AnnotatedPathSegment

// .operations_research.lattle.PathSegment path_segment = 1;
inline bool AnnotatedPathSegment::_internal_has_path_segment() const {
  return this != internal_default_instance() && _impl_.path_segment_ != nullptr;
}
inline bool AnnotatedPathSegment::has_path_segment() const {
  return _internal_has_path_segment();
}
inline void AnnotatedPathSegment::clear_path_segment() {
  if (GetArenaForAllocation() == nullptr && _impl_.path_segment_ != nullptr) {
    delete _impl_.path_segment_;
  }
  _impl_.path_segment_ = nullptr;
}
inline const ::operations_research::lattle::PathSegment& AnnotatedPathSegment::_internal_path_segment() const {
  const ::operations_research::lattle::PathSegment* p = _impl_.path_segment_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::lattle::PathSegment&>(
      ::operations_research::lattle::_PathSegment_default_instance_);
}
inline const ::operations_research::lattle::PathSegment& AnnotatedPathSegment::path_segment() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.AnnotatedPathSegment.path_segment)
  return _internal_path_segment();
}
inline void AnnotatedPathSegment::unsafe_arena_set_allocated_path_segment(
    ::operations_research::lattle::PathSegment* path_segment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.path_segment_);
  }
  _impl_.path_segment_ = path_segment;
  if (path_segment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.AnnotatedPathSegment.path_segment)
}
inline ::operations_research::lattle::PathSegment* AnnotatedPathSegment::release_path_segment() {
  
  ::operations_research::lattle::PathSegment* temp = _impl_.path_segment_;
  _impl_.path_segment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::operations_research::lattle::PathSegment* AnnotatedPathSegment::unsafe_arena_release_path_segment() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.AnnotatedPathSegment.path_segment)
  
  ::operations_research::lattle::PathSegment* temp = _impl_.path_segment_;
  _impl_.path_segment_ = nullptr;
  return temp;
}
inline ::operations_research::lattle::PathSegment* AnnotatedPathSegment::_internal_mutable_path_segment() {
  
  if (_impl_.path_segment_ == nullptr) {
    auto* p = CreateMaybeMessage<::operations_research::lattle::PathSegment>(GetArenaForAllocation());
    _impl_.path_segment_ = p;
  }
  return _impl_.path_segment_;
}
inline ::operations_research::lattle::PathSegment* AnnotatedPathSegment::mutable_path_segment() {
  ::operations_research::lattle::PathSegment* _msg = _internal_mutable_path_segment();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.AnnotatedPathSegment.path_segment)
  return _msg;
}
inline void AnnotatedPathSegment::set_allocated_path_segment(::operations_research::lattle::PathSegment* path_segment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.path_segment_;
  }
  if (path_segment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(path_segment);
    if (message_arena != submessage_arena) {
      path_segment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, path_segment, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.path_segment_ = path_segment;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.AnnotatedPathSegment.path_segment)
}

// .google.type.DateTime arrival_time = 2;
inline bool AnnotatedPathSegment::_internal_has_arrival_time() const {
  return this != internal_default_instance() && _impl_.arrival_time_ != nullptr;
}
inline bool AnnotatedPathSegment::has_arrival_time() const {
  return _internal_has_arrival_time();
}
inline const ::google::type::DateTime& AnnotatedPathSegment::_internal_arrival_time() const {
  const ::google::type::DateTime* p = _impl_.arrival_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::type::DateTime&>(
      ::google::type::_DateTime_default_instance_);
}
inline const ::google::type::DateTime& AnnotatedPathSegment::arrival_time() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.AnnotatedPathSegment.arrival_time)
  return _internal_arrival_time();
}
inline void AnnotatedPathSegment::unsafe_arena_set_allocated_arrival_time(
    ::google::type::DateTime* arrival_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.arrival_time_);
  }
  _impl_.arrival_time_ = arrival_time;
  if (arrival_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.AnnotatedPathSegment.arrival_time)
}
inline ::google::type::DateTime* AnnotatedPathSegment::release_arrival_time() {
  
  ::google::type::DateTime* temp = _impl_.arrival_time_;
  _impl_.arrival_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::type::DateTime* AnnotatedPathSegment::unsafe_arena_release_arrival_time() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.AnnotatedPathSegment.arrival_time)
  
  ::google::type::DateTime* temp = _impl_.arrival_time_;
  _impl_.arrival_time_ = nullptr;
  return temp;
}
inline ::google::type::DateTime* AnnotatedPathSegment::_internal_mutable_arrival_time() {
  
  if (_impl_.arrival_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::type::DateTime>(GetArenaForAllocation());
    _impl_.arrival_time_ = p;
  }
  return _impl_.arrival_time_;
}
inline ::google::type::DateTime* AnnotatedPathSegment::mutable_arrival_time() {
  ::google::type::DateTime* _msg = _internal_mutable_arrival_time();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.AnnotatedPathSegment.arrival_time)
  return _msg;
}
inline void AnnotatedPathSegment::set_allocated_arrival_time(::google::type::DateTime* arrival_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.arrival_time_);
  }
  if (arrival_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(arrival_time));
    if (message_arena != submessage_arena) {
      arrival_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arrival_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.arrival_time_ = arrival_time;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.AnnotatedPathSegment.arrival_time)
}

// .google.type.DateTime departure_time = 3;
inline bool AnnotatedPathSegment::_internal_has_departure_time() const {
  return this != internal_default_instance() && _impl_.departure_time_ != nullptr;
}
inline bool AnnotatedPathSegment::has_departure_time() const {
  return _internal_has_departure_time();
}
inline const ::google::type::DateTime& AnnotatedPathSegment::_internal_departure_time() const {
  const ::google::type::DateTime* p = _impl_.departure_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::type::DateTime&>(
      ::google::type::_DateTime_default_instance_);
}
inline const ::google::type::DateTime& AnnotatedPathSegment::departure_time() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.AnnotatedPathSegment.departure_time)
  return _internal_departure_time();
}
inline void AnnotatedPathSegment::unsafe_arena_set_allocated_departure_time(
    ::google::type::DateTime* departure_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.departure_time_);
  }
  _impl_.departure_time_ = departure_time;
  if (departure_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.AnnotatedPathSegment.departure_time)
}
inline ::google::type::DateTime* AnnotatedPathSegment::release_departure_time() {
  
  ::google::type::DateTime* temp = _impl_.departure_time_;
  _impl_.departure_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::type::DateTime* AnnotatedPathSegment::unsafe_arena_release_departure_time() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.AnnotatedPathSegment.departure_time)
  
  ::google::type::DateTime* temp = _impl_.departure_time_;
  _impl_.departure_time_ = nullptr;
  return temp;
}
inline ::google::type::DateTime* AnnotatedPathSegment::_internal_mutable_departure_time() {
  
  if (_impl_.departure_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::type::DateTime>(GetArenaForAllocation());
    _impl_.departure_time_ = p;
  }
  return _impl_.departure_time_;
}
inline ::google::type::DateTime* AnnotatedPathSegment::mutable_departure_time() {
  ::google::type::DateTime* _msg = _internal_mutable_departure_time();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.AnnotatedPathSegment.departure_time)
  return _msg;
}
inline void AnnotatedPathSegment::set_allocated_departure_time(::google::type::DateTime* departure_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.departure_time_);
  }
  if (departure_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(departure_time));
    if (message_arena != submessage_arena) {
      departure_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, departure_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.departure_time_ = departure_time;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.AnnotatedPathSegment.departure_time)
}

// double segment_cost_constant = 4;
inline void AnnotatedPathSegment::clear_segment_cost_constant() {
  _impl_.segment_cost_constant_ = 0;
}
inline double AnnotatedPathSegment::_internal_segment_cost_constant() const {
  return _impl_.segment_cost_constant_;
}
inline double AnnotatedPathSegment::segment_cost_constant() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.AnnotatedPathSegment.segment_cost_constant)
  return _internal_segment_cost_constant();
}
inline void AnnotatedPathSegment::_internal_set_segment_cost_constant(double value) {
  
  _impl_.segment_cost_constant_ = value;
}
inline void AnnotatedPathSegment::set_segment_cost_constant(double value) {
  _internal_set_segment_cost_constant(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.AnnotatedPathSegment.segment_cost_constant)
}

// map<string, double> segment_cost_due_to_vehicle = 5;
inline int AnnotatedPathSegment::_internal_segment_cost_due_to_vehicle_size() const {
  return _impl_.segment_cost_due_to_vehicle_.size();
}
inline int AnnotatedPathSegment::segment_cost_due_to_vehicle_size() const {
  return _internal_segment_cost_due_to_vehicle_size();
}
inline void AnnotatedPathSegment::clear_segment_cost_due_to_vehicle() {
  _impl_.segment_cost_due_to_vehicle_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
AnnotatedPathSegment::_internal_segment_cost_due_to_vehicle() const {
  return _impl_.segment_cost_due_to_vehicle_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
AnnotatedPathSegment::segment_cost_due_to_vehicle() const {
  // @@protoc_insertion_point(field_map:operations_research.lattle.AnnotatedPathSegment.segment_cost_due_to_vehicle)
  return _internal_segment_cost_due_to_vehicle();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
AnnotatedPathSegment::_internal_mutable_segment_cost_due_to_vehicle() {
  return _impl_.segment_cost_due_to_vehicle_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
AnnotatedPathSegment::mutable_segment_cost_due_to_vehicle() {
  // @@protoc_insertion_point(field_mutable_map:operations_research.lattle.AnnotatedPathSegment.segment_cost_due_to_vehicle)
  return _internal_mutable_segment_cost_due_to_vehicle();
}

// double segment_cost_due_to_departure = 6;
inline void AnnotatedPathSegment::clear_segment_cost_due_to_departure() {
  _impl_.segment_cost_due_to_departure_ = 0;
}
inline double AnnotatedPathSegment::_internal_segment_cost_due_to_departure() const {
  return _impl_.segment_cost_due_to_departure_;
}
inline double AnnotatedPathSegment::segment_cost_due_to_departure() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.AnnotatedPathSegment.segment_cost_due_to_departure)
  return _internal_segment_cost_due_to_departure();
}
inline void AnnotatedPathSegment::_internal_set_segment_cost_due_to_departure(double value) {
  
  _impl_.segment_cost_due_to_departure_ = value;
}
inline void AnnotatedPathSegment::set_segment_cost_due_to_departure(double value) {
  _internal_set_segment_cost_due_to_departure(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.AnnotatedPathSegment.segment_cost_due_to_departure)
}

// double segment_cost_due_to_arrival = 7;
inline void AnnotatedPathSegment::clear_segment_cost_due_to_arrival() {
  _impl_.segment_cost_due_to_arrival_ = 0;
}
inline double AnnotatedPathSegment::_internal_segment_cost_due_to_arrival() const {
  return _impl_.segment_cost_due_to_arrival_;
}
inline double AnnotatedPathSegment::segment_cost_due_to_arrival() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.AnnotatedPathSegment.segment_cost_due_to_arrival)
  return _internal_segment_cost_due_to_arrival();
}
inline void AnnotatedPathSegment::_internal_set_segment_cost_due_to_arrival(double value) {
  
  _impl_.segment_cost_due_to_arrival_ = value;
}
inline void AnnotatedPathSegment::set_segment_cost_due_to_arrival(double value) {
  _internal_set_segment_cost_due_to_arrival(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.AnnotatedPathSegment.segment_cost_due_to_arrival)
}

// bool is_committed = 8;
inline void AnnotatedPathSegment::clear_is_committed() {
  _impl_.is_committed_ = false;
}
inline bool AnnotatedPathSegment::_internal_is_committed() const {
  return _impl_.is_committed_;
}
inline bool AnnotatedPathSegment::is_committed() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.AnnotatedPathSegment.is_committed)
  return _internal_is_committed();
}
inline void AnnotatedPathSegment::_internal_set_is_committed(bool value) {
  
  _impl_.is_committed_ = value;
}
inline void AnnotatedPathSegment::set_is_committed(bool value) {
  _internal_set_is_committed(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.AnnotatedPathSegment.is_committed)
}

// -------------------------------------------------------------------

// EarlinessTardinessCost

// double earliness = 1;
inline void EarlinessTardinessCost::clear_earliness() {
  _impl_.earliness_ = 0;
}
inline double EarlinessTardinessCost::_internal_earliness() const {
  return _impl_.earliness_;
}
inline double EarlinessTardinessCost::earliness() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.EarlinessTardinessCost.earliness)
  return _internal_earliness();
}
inline void EarlinessTardinessCost::_internal_set_earliness(double value) {
  
  _impl_.earliness_ = value;
}
inline void EarlinessTardinessCost::set_earliness(double value) {
  _internal_set_earliness(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.EarlinessTardinessCost.earliness)
}

// double tardiness = 2;
inline void EarlinessTardinessCost::clear_tardiness() {
  _impl_.tardiness_ = 0;
}
inline double EarlinessTardinessCost::_internal_tardiness() const {
  return _impl_.tardiness_;
}
inline double EarlinessTardinessCost::tardiness() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.EarlinessTardinessCost.tardiness)
  return _internal_tardiness();
}
inline void EarlinessTardinessCost::_internal_set_tardiness(double value) {
  
  _impl_.tardiness_ = value;
}
inline void EarlinessTardinessCost::set_tardiness(double value) {
  _internal_set_tardiness(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.EarlinessTardinessCost.tardiness)
}

// -------------------------------------------------------------------

// LogisticsNetworkState_UsedCapacityInVehicle

// string line = 1;
inline void LogisticsNetworkState_UsedCapacityInVehicle::clear_line() {
  _impl_.line_.ClearToEmpty();
}
inline const std::string& LogisticsNetworkState_UsedCapacityInVehicle::line() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.line)
  return _internal_line();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogisticsNetworkState_UsedCapacityInVehicle::set_line(ArgT0&& arg0, ArgT... args) {
 
 _impl_.line_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.line)
}
inline std::string* LogisticsNetworkState_UsedCapacityInVehicle::mutable_line() {
  std::string* _s = _internal_mutable_line();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.line)
  return _s;
}
inline const std::string& LogisticsNetworkState_UsedCapacityInVehicle::_internal_line() const {
  return _impl_.line_.Get();
}
inline void LogisticsNetworkState_UsedCapacityInVehicle::_internal_set_line(const std::string& value) {
  
  _impl_.line_.Set(value, GetArenaForAllocation());
}
inline std::string* LogisticsNetworkState_UsedCapacityInVehicle::_internal_mutable_line() {
  
  return _impl_.line_.Mutable(GetArenaForAllocation());
}
inline std::string* LogisticsNetworkState_UsedCapacityInVehicle::release_line() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.line)
  return _impl_.line_.Release();
}
inline void LogisticsNetworkState_UsedCapacityInVehicle::set_allocated_line(std::string* line) {
  if (line != nullptr) {
    
  } else {
    
  }
  _impl_.line_.SetAllocated(line, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.line_.IsDefault()) {
    _impl_.line_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.line)
}

// string line_rotation = 2;
inline void LogisticsNetworkState_UsedCapacityInVehicle::clear_line_rotation() {
  _impl_.line_rotation_.ClearToEmpty();
}
inline const std::string& LogisticsNetworkState_UsedCapacityInVehicle::line_rotation() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.line_rotation)
  return _internal_line_rotation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogisticsNetworkState_UsedCapacityInVehicle::set_line_rotation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.line_rotation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.line_rotation)
}
inline std::string* LogisticsNetworkState_UsedCapacityInVehicle::mutable_line_rotation() {
  std::string* _s = _internal_mutable_line_rotation();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.line_rotation)
  return _s;
}
inline const std::string& LogisticsNetworkState_UsedCapacityInVehicle::_internal_line_rotation() const {
  return _impl_.line_rotation_.Get();
}
inline void LogisticsNetworkState_UsedCapacityInVehicle::_internal_set_line_rotation(const std::string& value) {
  
  _impl_.line_rotation_.Set(value, GetArenaForAllocation());
}
inline std::string* LogisticsNetworkState_UsedCapacityInVehicle::_internal_mutable_line_rotation() {
  
  return _impl_.line_rotation_.Mutable(GetArenaForAllocation());
}
inline std::string* LogisticsNetworkState_UsedCapacityInVehicle::release_line_rotation() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.line_rotation)
  return _impl_.line_rotation_.Release();
}
inline void LogisticsNetworkState_UsedCapacityInVehicle::set_allocated_line_rotation(std::string* line_rotation) {
  if (line_rotation != nullptr) {
    
  } else {
    
  }
  _impl_.line_rotation_.SetAllocated(line_rotation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.line_rotation_.IsDefault()) {
    _impl_.line_rotation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.line_rotation)
}

// repeated .operations_research.lattle.ValueDimension used_capacity = 3;
inline int LogisticsNetworkState_UsedCapacityInVehicle::_internal_used_capacity_size() const {
  return _impl_.used_capacity_.size();
}
inline int LogisticsNetworkState_UsedCapacityInVehicle::used_capacity_size() const {
  return _internal_used_capacity_size();
}
inline void LogisticsNetworkState_UsedCapacityInVehicle::clear_used_capacity() {
  _impl_.used_capacity_.Clear();
}
inline ::operations_research::lattle::ValueDimension* LogisticsNetworkState_UsedCapacityInVehicle::mutable_used_capacity(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.used_capacity)
  return _impl_.used_capacity_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >*
LogisticsNetworkState_UsedCapacityInVehicle::mutable_used_capacity() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.used_capacity)
  return &_impl_.used_capacity_;
}
inline const ::operations_research::lattle::ValueDimension& LogisticsNetworkState_UsedCapacityInVehicle::_internal_used_capacity(int index) const {
  return _impl_.used_capacity_.Get(index);
}
inline const ::operations_research::lattle::ValueDimension& LogisticsNetworkState_UsedCapacityInVehicle::used_capacity(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.used_capacity)
  return _internal_used_capacity(index);
}
inline ::operations_research::lattle::ValueDimension* LogisticsNetworkState_UsedCapacityInVehicle::_internal_add_used_capacity() {
  return _impl_.used_capacity_.Add();
}
inline ::operations_research::lattle::ValueDimension* LogisticsNetworkState_UsedCapacityInVehicle::add_used_capacity() {
  ::operations_research::lattle::ValueDimension* _add = _internal_add_used_capacity();
  // @@protoc_insertion_point(field_add:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.used_capacity)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ValueDimension >&
LogisticsNetworkState_UsedCapacityInVehicle::used_capacity() const {
  // @@protoc_insertion_point(field_list:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.used_capacity)
  return _impl_.used_capacity_;
}

// string vehicle = 4;
inline void LogisticsNetworkState_UsedCapacityInVehicle::clear_vehicle() {
  _impl_.vehicle_.ClearToEmpty();
}
inline const std::string& LogisticsNetworkState_UsedCapacityInVehicle::vehicle() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.vehicle)
  return _internal_vehicle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogisticsNetworkState_UsedCapacityInVehicle::set_vehicle(ArgT0&& arg0, ArgT... args) {
 
 _impl_.vehicle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.vehicle)
}
inline std::string* LogisticsNetworkState_UsedCapacityInVehicle::mutable_vehicle() {
  std::string* _s = _internal_mutable_vehicle();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.vehicle)
  return _s;
}
inline const std::string& LogisticsNetworkState_UsedCapacityInVehicle::_internal_vehicle() const {
  return _impl_.vehicle_.Get();
}
inline void LogisticsNetworkState_UsedCapacityInVehicle::_internal_set_vehicle(const std::string& value) {
  
  _impl_.vehicle_.Set(value, GetArenaForAllocation());
}
inline std::string* LogisticsNetworkState_UsedCapacityInVehicle::_internal_mutable_vehicle() {
  
  return _impl_.vehicle_.Mutable(GetArenaForAllocation());
}
inline std::string* LogisticsNetworkState_UsedCapacityInVehicle::release_vehicle() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.vehicle)
  return _impl_.vehicle_.Release();
}
inline void LogisticsNetworkState_UsedCapacityInVehicle::set_allocated_vehicle(std::string* vehicle) {
  if (vehicle != nullptr) {
    
  } else {
    
  }
  _impl_.vehicle_.SetAllocated(vehicle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vehicle_.IsDefault()) {
    _impl_.vehicle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.vehicle)
}

// string source_hub = 5;
inline void LogisticsNetworkState_UsedCapacityInVehicle::clear_source_hub() {
  _impl_.source_hub_.ClearToEmpty();
}
inline const std::string& LogisticsNetworkState_UsedCapacityInVehicle::source_hub() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.source_hub)
  return _internal_source_hub();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogisticsNetworkState_UsedCapacityInVehicle::set_source_hub(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_hub_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.source_hub)
}
inline std::string* LogisticsNetworkState_UsedCapacityInVehicle::mutable_source_hub() {
  std::string* _s = _internal_mutable_source_hub();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.source_hub)
  return _s;
}
inline const std::string& LogisticsNetworkState_UsedCapacityInVehicle::_internal_source_hub() const {
  return _impl_.source_hub_.Get();
}
inline void LogisticsNetworkState_UsedCapacityInVehicle::_internal_set_source_hub(const std::string& value) {
  
  _impl_.source_hub_.Set(value, GetArenaForAllocation());
}
inline std::string* LogisticsNetworkState_UsedCapacityInVehicle::_internal_mutable_source_hub() {
  
  return _impl_.source_hub_.Mutable(GetArenaForAllocation());
}
inline std::string* LogisticsNetworkState_UsedCapacityInVehicle::release_source_hub() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.source_hub)
  return _impl_.source_hub_.Release();
}
inline void LogisticsNetworkState_UsedCapacityInVehicle::set_allocated_source_hub(std::string* source_hub) {
  if (source_hub != nullptr) {
    
  } else {
    
  }
  _impl_.source_hub_.SetAllocated(source_hub, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_hub_.IsDefault()) {
    _impl_.source_hub_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.source_hub)
}

// string destination_hub = 6;
inline void LogisticsNetworkState_UsedCapacityInVehicle::clear_destination_hub() {
  _impl_.destination_hub_.ClearToEmpty();
}
inline const std::string& LogisticsNetworkState_UsedCapacityInVehicle::destination_hub() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.destination_hub)
  return _internal_destination_hub();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogisticsNetworkState_UsedCapacityInVehicle::set_destination_hub(ArgT0&& arg0, ArgT... args) {
 
 _impl_.destination_hub_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.destination_hub)
}
inline std::string* LogisticsNetworkState_UsedCapacityInVehicle::mutable_destination_hub() {
  std::string* _s = _internal_mutable_destination_hub();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.destination_hub)
  return _s;
}
inline const std::string& LogisticsNetworkState_UsedCapacityInVehicle::_internal_destination_hub() const {
  return _impl_.destination_hub_.Get();
}
inline void LogisticsNetworkState_UsedCapacityInVehicle::_internal_set_destination_hub(const std::string& value) {
  
  _impl_.destination_hub_.Set(value, GetArenaForAllocation());
}
inline std::string* LogisticsNetworkState_UsedCapacityInVehicle::_internal_mutable_destination_hub() {
  
  return _impl_.destination_hub_.Mutable(GetArenaForAllocation());
}
inline std::string* LogisticsNetworkState_UsedCapacityInVehicle::release_destination_hub() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.destination_hub)
  return _impl_.destination_hub_.Release();
}
inline void LogisticsNetworkState_UsedCapacityInVehicle::set_allocated_destination_hub(std::string* destination_hub) {
  if (destination_hub != nullptr) {
    
  } else {
    
  }
  _impl_.destination_hub_.SetAllocated(destination_hub, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.destination_hub_.IsDefault()) {
    _impl_.destination_hub_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle.destination_hub)
}

// -------------------------------------------------------------------

// LogisticsNetworkState

// string network = 1;
inline void LogisticsNetworkState::clear_network() {
  _impl_.network_.ClearToEmpty();
}
inline const std::string& LogisticsNetworkState::network() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LogisticsNetworkState.network)
  return _internal_network();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogisticsNetworkState::set_network(ArgT0&& arg0, ArgT... args) {
 
 _impl_.network_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.LogisticsNetworkState.network)
}
inline std::string* LogisticsNetworkState::mutable_network() {
  std::string* _s = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LogisticsNetworkState.network)
  return _s;
}
inline const std::string& LogisticsNetworkState::_internal_network() const {
  return _impl_.network_.Get();
}
inline void LogisticsNetworkState::_internal_set_network(const std::string& value) {
  
  _impl_.network_.Set(value, GetArenaForAllocation());
}
inline std::string* LogisticsNetworkState::_internal_mutable_network() {
  
  return _impl_.network_.Mutable(GetArenaForAllocation());
}
inline std::string* LogisticsNetworkState::release_network() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.LogisticsNetworkState.network)
  return _impl_.network_.Release();
}
inline void LogisticsNetworkState::set_allocated_network(std::string* network) {
  if (network != nullptr) {
    
  } else {
    
  }
  _impl_.network_.SetAllocated(network, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.network_.IsDefault()) {
    _impl_.network_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.LogisticsNetworkState.network)
}

// repeated .operations_research.lattle.Parcel routed_parcels = 2;
inline int LogisticsNetworkState::_internal_routed_parcels_size() const {
  return _impl_.routed_parcels_.size();
}
inline int LogisticsNetworkState::routed_parcels_size() const {
  return _internal_routed_parcels_size();
}
inline void LogisticsNetworkState::clear_routed_parcels() {
  _impl_.routed_parcels_.Clear();
}
inline ::operations_research::lattle::Parcel* LogisticsNetworkState::mutable_routed_parcels(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LogisticsNetworkState.routed_parcels)
  return _impl_.routed_parcels_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::Parcel >*
LogisticsNetworkState::mutable_routed_parcels() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.lattle.LogisticsNetworkState.routed_parcels)
  return &_impl_.routed_parcels_;
}
inline const ::operations_research::lattle::Parcel& LogisticsNetworkState::_internal_routed_parcels(int index) const {
  return _impl_.routed_parcels_.Get(index);
}
inline const ::operations_research::lattle::Parcel& LogisticsNetworkState::routed_parcels(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LogisticsNetworkState.routed_parcels)
  return _internal_routed_parcels(index);
}
inline ::operations_research::lattle::Parcel* LogisticsNetworkState::_internal_add_routed_parcels() {
  return _impl_.routed_parcels_.Add();
}
inline ::operations_research::lattle::Parcel* LogisticsNetworkState::add_routed_parcels() {
  ::operations_research::lattle::Parcel* _add = _internal_add_routed_parcels();
  // @@protoc_insertion_point(field_add:operations_research.lattle.LogisticsNetworkState.routed_parcels)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::Parcel >&
LogisticsNetworkState::routed_parcels() const {
  // @@protoc_insertion_point(field_list:operations_research.lattle.LogisticsNetworkState.routed_parcels)
  return _impl_.routed_parcels_;
}

// repeated .operations_research.lattle.ParcelRoute parcel_routes = 3;
inline int LogisticsNetworkState::_internal_parcel_routes_size() const {
  return _impl_.parcel_routes_.size();
}
inline int LogisticsNetworkState::parcel_routes_size() const {
  return _internal_parcel_routes_size();
}
inline void LogisticsNetworkState::clear_parcel_routes() {
  _impl_.parcel_routes_.Clear();
}
inline ::operations_research::lattle::ParcelRoute* LogisticsNetworkState::mutable_parcel_routes(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LogisticsNetworkState.parcel_routes)
  return _impl_.parcel_routes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ParcelRoute >*
LogisticsNetworkState::mutable_parcel_routes() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.lattle.LogisticsNetworkState.parcel_routes)
  return &_impl_.parcel_routes_;
}
inline const ::operations_research::lattle::ParcelRoute& LogisticsNetworkState::_internal_parcel_routes(int index) const {
  return _impl_.parcel_routes_.Get(index);
}
inline const ::operations_research::lattle::ParcelRoute& LogisticsNetworkState::parcel_routes(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LogisticsNetworkState.parcel_routes)
  return _internal_parcel_routes(index);
}
inline ::operations_research::lattle::ParcelRoute* LogisticsNetworkState::_internal_add_parcel_routes() {
  return _impl_.parcel_routes_.Add();
}
inline ::operations_research::lattle::ParcelRoute* LogisticsNetworkState::add_parcel_routes() {
  ::operations_research::lattle::ParcelRoute* _add = _internal_add_parcel_routes();
  // @@protoc_insertion_point(field_add:operations_research.lattle.LogisticsNetworkState.parcel_routes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::ParcelRoute >&
LogisticsNetworkState::parcel_routes() const {
  // @@protoc_insertion_point(field_list:operations_research.lattle.LogisticsNetworkState.parcel_routes)
  return _impl_.parcel_routes_;
}

// repeated .operations_research.lattle.LogisticsNetworkState.UsedCapacityInVehicle used_capacity_in_vehicle = 4;
inline int LogisticsNetworkState::_internal_used_capacity_in_vehicle_size() const {
  return _impl_.used_capacity_in_vehicle_.size();
}
inline int LogisticsNetworkState::used_capacity_in_vehicle_size() const {
  return _internal_used_capacity_in_vehicle_size();
}
inline void LogisticsNetworkState::clear_used_capacity_in_vehicle() {
  _impl_.used_capacity_in_vehicle_.Clear();
}
inline ::operations_research::lattle::LogisticsNetworkState_UsedCapacityInVehicle* LogisticsNetworkState::mutable_used_capacity_in_vehicle(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LogisticsNetworkState.used_capacity_in_vehicle)
  return _impl_.used_capacity_in_vehicle_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::LogisticsNetworkState_UsedCapacityInVehicle >*
LogisticsNetworkState::mutable_used_capacity_in_vehicle() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.lattle.LogisticsNetworkState.used_capacity_in_vehicle)
  return &_impl_.used_capacity_in_vehicle_;
}
inline const ::operations_research::lattle::LogisticsNetworkState_UsedCapacityInVehicle& LogisticsNetworkState::_internal_used_capacity_in_vehicle(int index) const {
  return _impl_.used_capacity_in_vehicle_.Get(index);
}
inline const ::operations_research::lattle::LogisticsNetworkState_UsedCapacityInVehicle& LogisticsNetworkState::used_capacity_in_vehicle(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LogisticsNetworkState.used_capacity_in_vehicle)
  return _internal_used_capacity_in_vehicle(index);
}
inline ::operations_research::lattle::LogisticsNetworkState_UsedCapacityInVehicle* LogisticsNetworkState::_internal_add_used_capacity_in_vehicle() {
  return _impl_.used_capacity_in_vehicle_.Add();
}
inline ::operations_research::lattle::LogisticsNetworkState_UsedCapacityInVehicle* LogisticsNetworkState::add_used_capacity_in_vehicle() {
  ::operations_research::lattle::LogisticsNetworkState_UsedCapacityInVehicle* _add = _internal_add_used_capacity_in_vehicle();
  // @@protoc_insertion_point(field_add:operations_research.lattle.LogisticsNetworkState.used_capacity_in_vehicle)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::lattle::LogisticsNetworkState_UsedCapacityInVehicle >&
LogisticsNetworkState::used_capacity_in_vehicle() const {
  // @@protoc_insertion_point(field_list:operations_research.lattle.LogisticsNetworkState.used_capacity_in_vehicle)
  return _impl_.used_capacity_in_vehicle_;
}

// -------------------------------------------------------------------

// LattleValidationError_FieldReference

// string name = 1;
inline void LattleValidationError_FieldReference::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LattleValidationError_FieldReference::name() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LattleValidationError.FieldReference.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LattleValidationError_FieldReference::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.LattleValidationError.FieldReference.name)
}
inline std::string* LattleValidationError_FieldReference::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LattleValidationError.FieldReference.name)
  return _s;
}
inline const std::string& LattleValidationError_FieldReference::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LattleValidationError_FieldReference::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LattleValidationError_FieldReference::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LattleValidationError_FieldReference::release_name() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.LattleValidationError.FieldReference.name)
  return _impl_.name_.Release();
}
inline void LattleValidationError_FieldReference::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.LattleValidationError.FieldReference.name)
}

// int32 index = 2;
inline bool LattleValidationError_FieldReference::_internal_has_index() const {
  return index_or_key_case() == kIndex;
}
inline bool LattleValidationError_FieldReference::has_index() const {
  return _internal_has_index();
}
inline void LattleValidationError_FieldReference::set_has_index() {
  _impl_._oneof_case_[0] = kIndex;
}
inline void LattleValidationError_FieldReference::clear_index() {
  if (_internal_has_index()) {
    _impl_.index_or_key_.index_ = 0;
    clear_has_index_or_key();
  }
}
inline int32_t LattleValidationError_FieldReference::_internal_index() const {
  if (_internal_has_index()) {
    return _impl_.index_or_key_.index_;
  }
  return 0;
}
inline void LattleValidationError_FieldReference::_internal_set_index(int32_t value) {
  if (!_internal_has_index()) {
    clear_index_or_key();
    set_has_index();
  }
  _impl_.index_or_key_.index_ = value;
}
inline int32_t LattleValidationError_FieldReference::index() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LattleValidationError.FieldReference.index)
  return _internal_index();
}
inline void LattleValidationError_FieldReference::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.LattleValidationError.FieldReference.index)
}

// string key = 3;
inline bool LattleValidationError_FieldReference::_internal_has_key() const {
  return index_or_key_case() == kKey;
}
inline bool LattleValidationError_FieldReference::has_key() const {
  return _internal_has_key();
}
inline void LattleValidationError_FieldReference::set_has_key() {
  _impl_._oneof_case_[0] = kKey;
}
inline void LattleValidationError_FieldReference::clear_key() {
  if (_internal_has_key()) {
    _impl_.index_or_key_.key_.Destroy();
    clear_has_index_or_key();
  }
}
inline const std::string& LattleValidationError_FieldReference::key() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LattleValidationError.FieldReference.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline void LattleValidationError_FieldReference::set_key(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_key()) {
    clear_index_or_key();
    set_has_key();
    _impl_.index_or_key_.key_.InitDefault();
  }
  _impl_.index_or_key_.key_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.LattleValidationError.FieldReference.key)
}
inline std::string* LattleValidationError_FieldReference::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LattleValidationError.FieldReference.key)
  return _s;
}
inline const std::string& LattleValidationError_FieldReference::_internal_key() const {
  if (_internal_has_key()) {
    return _impl_.index_or_key_.key_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void LattleValidationError_FieldReference::_internal_set_key(const std::string& value) {
  if (!_internal_has_key()) {
    clear_index_or_key();
    set_has_key();
    _impl_.index_or_key_.key_.InitDefault();
  }
  _impl_.index_or_key_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* LattleValidationError_FieldReference::_internal_mutable_key() {
  if (!_internal_has_key()) {
    clear_index_or_key();
    set_has_key();
    _impl_.index_or_key_.key_.InitDefault();
  }
  return _impl_.index_or_key_.key_.Mutable(      GetArenaForAllocation());
}
inline std::string* LattleValidationError_FieldReference::release_key() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.LattleValidationError.FieldReference.key)
  if (_internal_has_key()) {
    clear_has_index_or_key();
    return _impl_.index_or_key_.key_.Release();
  } else {
    return nullptr;
  }
}
inline void LattleValidationError_FieldReference::set_allocated_key(std::string* key) {
  if (has_index_or_key()) {
    clear_index_or_key();
  }
  if (key != nullptr) {
    set_has_key();
    _impl_.index_or_key_.key_.InitAllocated(key, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.LattleValidationError.FieldReference.key)
}

// .operations_research.lattle.LattleValidationError.FieldReference sub_field = 4;
inline bool LattleValidationError_FieldReference::_internal_has_sub_field() const {
  return this != internal_default_instance() && _impl_.sub_field_ != nullptr;
}
inline bool LattleValidationError_FieldReference::has_sub_field() const {
  return _internal_has_sub_field();
}
inline void LattleValidationError_FieldReference::clear_sub_field() {
  if (GetArenaForAllocation() == nullptr && _impl_.sub_field_ != nullptr) {
    delete _impl_.sub_field_;
  }
  _impl_.sub_field_ = nullptr;
}
inline const ::operations_research::lattle::LattleValidationError_FieldReference& LattleValidationError_FieldReference::_internal_sub_field() const {
  const ::operations_research::lattle::LattleValidationError_FieldReference* p = _impl_.sub_field_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::lattle::LattleValidationError_FieldReference&>(
      ::operations_research::lattle::_LattleValidationError_FieldReference_default_instance_);
}
inline const ::operations_research::lattle::LattleValidationError_FieldReference& LattleValidationError_FieldReference::sub_field() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LattleValidationError.FieldReference.sub_field)
  return _internal_sub_field();
}
inline void LattleValidationError_FieldReference::unsafe_arena_set_allocated_sub_field(
    ::operations_research::lattle::LattleValidationError_FieldReference* sub_field) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sub_field_);
  }
  _impl_.sub_field_ = sub_field;
  if (sub_field) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.LattleValidationError.FieldReference.sub_field)
}
inline ::operations_research::lattle::LattleValidationError_FieldReference* LattleValidationError_FieldReference::release_sub_field() {
  
  ::operations_research::lattle::LattleValidationError_FieldReference* temp = _impl_.sub_field_;
  _impl_.sub_field_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::operations_research::lattle::LattleValidationError_FieldReference* LattleValidationError_FieldReference::unsafe_arena_release_sub_field() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.LattleValidationError.FieldReference.sub_field)
  
  ::operations_research::lattle::LattleValidationError_FieldReference* temp = _impl_.sub_field_;
  _impl_.sub_field_ = nullptr;
  return temp;
}
inline ::operations_research::lattle::LattleValidationError_FieldReference* LattleValidationError_FieldReference::_internal_mutable_sub_field() {
  
  if (_impl_.sub_field_ == nullptr) {
    auto* p = CreateMaybeMessage<::operations_research::lattle::LattleValidationError_FieldReference>(GetArenaForAllocation());
    _impl_.sub_field_ = p;
  }
  return _impl_.sub_field_;
}
inline ::operations_research::lattle::LattleValidationError_FieldReference* LattleValidationError_FieldReference::mutable_sub_field() {
  ::operations_research::lattle::LattleValidationError_FieldReference* _msg = _internal_mutable_sub_field();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LattleValidationError.FieldReference.sub_field)
  return _msg;
}
inline void LattleValidationError_FieldReference::set_allocated_sub_field(::operations_research::lattle::LattleValidationError_FieldReference* sub_field) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sub_field_;
  }
  if (sub_field) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sub_field);
    if (message_arena != submessage_arena) {
      sub_field = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sub_field, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sub_field_ = sub_field;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.LattleValidationError.FieldReference.sub_field)
}

inline bool LattleValidationError_FieldReference::has_index_or_key() const {
  return index_or_key_case() != INDEX_OR_KEY_NOT_SET;
}
inline void LattleValidationError_FieldReference::clear_has_index_or_key() {
  _impl_._oneof_case_[0] = INDEX_OR_KEY_NOT_SET;
}
inline LattleValidationError_FieldReference::IndexOrKeyCase LattleValidationError_FieldReference::index_or_key_case() const {
  return LattleValidationError_FieldReference::IndexOrKeyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LattleValidationError

// .operations_research.lattle.LattleValidationError.Code code = 1;
inline void LattleValidationError::clear_code() {
  _impl_.code_ = 0;
}
inline ::operations_research::lattle::LattleValidationError_Code LattleValidationError::_internal_code() const {
  return static_cast< ::operations_research::lattle::LattleValidationError_Code >(_impl_.code_);
}
inline ::operations_research::lattle::LattleValidationError_Code LattleValidationError::code() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LattleValidationError.code)
  return _internal_code();
}
inline void LattleValidationError::_internal_set_code(::operations_research::lattle::LattleValidationError_Code value) {
  
  _impl_.code_ = value;
}
inline void LattleValidationError::set_code(::operations_research::lattle::LattleValidationError_Code value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:operations_research.lattle.LattleValidationError.code)
}

// .operations_research.lattle.LattleValidationError.FieldReference field = 2;
inline bool LattleValidationError::_internal_has_field() const {
  return this != internal_default_instance() && _impl_.field_ != nullptr;
}
inline bool LattleValidationError::has_field() const {
  return _internal_has_field();
}
inline void LattleValidationError::clear_field() {
  if (GetArenaForAllocation() == nullptr && _impl_.field_ != nullptr) {
    delete _impl_.field_;
  }
  _impl_.field_ = nullptr;
}
inline const ::operations_research::lattle::LattleValidationError_FieldReference& LattleValidationError::_internal_field() const {
  const ::operations_research::lattle::LattleValidationError_FieldReference* p = _impl_.field_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::lattle::LattleValidationError_FieldReference&>(
      ::operations_research::lattle::_LattleValidationError_FieldReference_default_instance_);
}
inline const ::operations_research::lattle::LattleValidationError_FieldReference& LattleValidationError::field() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LattleValidationError.field)
  return _internal_field();
}
inline void LattleValidationError::unsafe_arena_set_allocated_field(
    ::operations_research::lattle::LattleValidationError_FieldReference* field) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.field_);
  }
  _impl_.field_ = field;
  if (field) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.lattle.LattleValidationError.field)
}
inline ::operations_research::lattle::LattleValidationError_FieldReference* LattleValidationError::release_field() {
  
  ::operations_research::lattle::LattleValidationError_FieldReference* temp = _impl_.field_;
  _impl_.field_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::operations_research::lattle::LattleValidationError_FieldReference* LattleValidationError::unsafe_arena_release_field() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.LattleValidationError.field)
  
  ::operations_research::lattle::LattleValidationError_FieldReference* temp = _impl_.field_;
  _impl_.field_ = nullptr;
  return temp;
}
inline ::operations_research::lattle::LattleValidationError_FieldReference* LattleValidationError::_internal_mutable_field() {
  
  if (_impl_.field_ == nullptr) {
    auto* p = CreateMaybeMessage<::operations_research::lattle::LattleValidationError_FieldReference>(GetArenaForAllocation());
    _impl_.field_ = p;
  }
  return _impl_.field_;
}
inline ::operations_research::lattle::LattleValidationError_FieldReference* LattleValidationError::mutable_field() {
  ::operations_research::lattle::LattleValidationError_FieldReference* _msg = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LattleValidationError.field)
  return _msg;
}
inline void LattleValidationError::set_allocated_field(::operations_research::lattle::LattleValidationError_FieldReference* field) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.field_;
  }
  if (field) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(field);
    if (message_arena != submessage_arena) {
      field = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, field, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.field_ = field;
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.LattleValidationError.field)
}

// optional string error_message = 3;
inline bool LattleValidationError::_internal_has_error_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LattleValidationError::has_error_message() const {
  return _internal_has_error_message();
}
inline void LattleValidationError::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LattleValidationError::error_message() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LattleValidationError.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LattleValidationError::set_error_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.LattleValidationError.error_message)
}
inline std::string* LattleValidationError::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LattleValidationError.error_message)
  return _s;
}
inline const std::string& LattleValidationError::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void LattleValidationError::_internal_set_error_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* LattleValidationError::_internal_mutable_error_message() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* LattleValidationError::release_error_message() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.LattleValidationError.error_message)
  if (!_internal_has_error_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LattleValidationError::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.LattleValidationError.error_message)
}

// optional string offending_values = 4;
inline bool LattleValidationError::_internal_has_offending_values() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LattleValidationError::has_offending_values() const {
  return _internal_has_offending_values();
}
inline void LattleValidationError::clear_offending_values() {
  _impl_.offending_values_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LattleValidationError::offending_values() const {
  // @@protoc_insertion_point(field_get:operations_research.lattle.LattleValidationError.offending_values)
  return _internal_offending_values();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LattleValidationError::set_offending_values(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.offending_values_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.lattle.LattleValidationError.offending_values)
}
inline std::string* LattleValidationError::mutable_offending_values() {
  std::string* _s = _internal_mutable_offending_values();
  // @@protoc_insertion_point(field_mutable:operations_research.lattle.LattleValidationError.offending_values)
  return _s;
}
inline const std::string& LattleValidationError::_internal_offending_values() const {
  return _impl_.offending_values_.Get();
}
inline void LattleValidationError::_internal_set_offending_values(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.offending_values_.Set(value, GetArenaForAllocation());
}
inline std::string* LattleValidationError::_internal_mutable_offending_values() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.offending_values_.Mutable(GetArenaForAllocation());
}
inline std::string* LattleValidationError::release_offending_values() {
  // @@protoc_insertion_point(field_release:operations_research.lattle.LattleValidationError.offending_values)
  if (!_internal_has_offending_values()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.offending_values_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.offending_values_.IsDefault()) {
    _impl_.offending_values_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LattleValidationError::set_allocated_offending_values(std::string* offending_values) {
  if (offending_values != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.offending_values_.SetAllocated(offending_values, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.offending_values_.IsDefault()) {
    _impl_.offending_values_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.lattle.LattleValidationError.offending_values)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace lattle
}  // namespace operations_research

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::operations_research::lattle::LattleValidationError_Code> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::operations_research::lattle::LattleValidationError_Code>() {
  return ::operations_research::lattle::LattleValidationError_Code_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_lattle_2eproto
